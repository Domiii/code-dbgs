diff --git a/src/algorithms/cryptography/caesar-cipher/__test__/caesarCipher.test.js b/src/algorithms/cryptography/caesar-cipher/__test__/caesarCipher.test.js
index 90521ce..d437e54 100644
--- a/src/algorithms/cryptography/caesar-cipher/__test__/caesarCipher.test.js
+++ b/src/algorithms/cryptography/caesar-cipher/__test__/caesarCipher.test.js
@@ -1,40 +1,43 @@
-import { caesarCipherEncrypt, caesarCipherDecrypt } from '../caesarCipher';
+import { caesarCipherEncrypt, caesarCipherDecrypt } from "../caesarCipher";
 
-describe('caesarCipher', () => {
-  it('should not change a string with zero shift', () => {
-    expect(caesarCipherEncrypt('abcd', 0)).toBe('abcd');
-    expect(caesarCipherDecrypt('abcd', 0)).toBe('abcd');
+describe("caesarCipher", () => {
+  it("should not change a string with zero shift", () => {
+    expect(caesarCipherEncrypt("abcd", 0)).toBe("abcd");
+    expect(caesarCipherDecrypt("abcd", 0)).toBe("abcd");
   });
 
-  it('should cipher a string with different shifts', () => {
-    expect(caesarCipherEncrypt('abcde', 3)).toBe('defgh');
-    expect(caesarCipherDecrypt('defgh', 3)).toBe('abcde');
+  it("should cipher a string with different shifts", () => {
+    expect(caesarCipherEncrypt("abcde", 3)).toBe("defgh");
+    expect(caesarCipherDecrypt("defgh", 3)).toBe("abcde");
 
-    expect(caesarCipherEncrypt('abcde', 1)).toBe('bcdef');
-    expect(caesarCipherDecrypt('bcdef', 1)).toBe('abcde');
+    expect(caesarCipherEncrypt("abcde", 1)).toBe("bcdef");
+    expect(caesarCipherDecrypt("bcdef", 1)).toBe("abcde");
 
-    expect(caesarCipherEncrypt('xyz', 1)).toBe('yza');
-    expect(caesarCipherDecrypt('yza', 1)).toBe('xyz');
+    expect(caesarCipherEncrypt("xyz", 1)).toBe("yza");
+    expect(caesarCipherDecrypt("yza", 1)).toBe("xyz");
   });
 
-  it('should be case insensitive', () => {
-    expect(caesarCipherEncrypt('ABCDE', 3)).toBe('defgh');
+  it("should be case insensitive", () => {
+    expect(caesarCipherEncrypt("ABCDE", 3)).toBe("defgh");
   });
 
-  it('should correctly handle an empty strings', () => {
-    expect(caesarCipherEncrypt('', 3)).toBe('');
+  it("should correctly handle an empty strings", () => {
+    expect(caesarCipherEncrypt("", 3)).toBe("");
   });
 
-  it('should not cipher unknown chars', () => {
-    expect(caesarCipherEncrypt('ab2cde', 3)).toBe('de2fgh');
-    expect(caesarCipherDecrypt('de2fgh', 3)).toBe('ab2cde');
+  it("should not cipher unknown chars", () => {
+    expect(caesarCipherEncrypt("ab2cde", 3)).toBe("de2fgh");
+    expect(caesarCipherDecrypt("de2fgh", 3)).toBe("ab2cde");
   });
 
-  it('should encrypt and decrypt full phrases', () => {
-    expect(caesarCipherEncrypt('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', 23))
-      .toBe('qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald');
+  it("should encrypt and decrypt full phrases", () => {
+    expect(
+      caesarCipherEncrypt("THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG", 23)
+    ).toBe("qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald");
 
-    expect(caesarCipherDecrypt('qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald', 23))
-      .toBe('the quick brown fox jumps over the lazy dog');
+    expect(
+      caesarCipherDecrypt("qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald", 23)
+    ).toBe("the quick brown fox jumps over the lazy dog");
   });
 });
+
diff --git a/src/algorithms/cryptography/caesar-cipher/caesarCipher.js b/src/algorithms/cryptography/caesar-cipher/caesarCipher.js
index ba92299..c73ca98 100644
--- a/src/algorithms/cryptography/caesar-cipher/caesarCipher.js
+++ b/src/algorithms/cryptography/caesar-cipher/caesarCipher.js
@@ -1,5 +1,5 @@
 // Create alphabet array: ['a', 'b', 'c', ..., 'z'].
-const englishAlphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');
+const englishAlphabet = "abcdefghijklmnopqrstuvwxyz".split("");
 
 /**
  * Generates a cipher map out of the alphabet.
@@ -10,19 +10,18 @@ const englishAlphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');
  * @return {Object} - i.e. {'a': 'd', 'b': 'e', 'c': 'f', ..., 'z': 'c'}
  */
 const getCipherMap = (alphabet, shift) => {
-  return alphabet
-    .reduce((charsMap, currentChar, charIndex) => {
-      const charsMapClone = { ...charsMap };
-      // Making the shift to be cyclic (i.e. with a shift of 1 - 'z' would be mapped to 'a').
-      let encryptedCharIndex = (charIndex + shift) % alphabet.length;
-      // Support negative shifts for creating a map for decryption
-      // (i.e. with shift -1 - 'a' would be mapped to 'z').
-      if (encryptedCharIndex < 0) {
-        encryptedCharIndex += alphabet.length;
-      }
-      charsMapClone[currentChar] = alphabet[encryptedCharIndex];
-      return charsMapClone;
-    }, {});
+  return alphabet.reduce((charsMap, currentChar, charIndex) => {
+    const charsMapClone = { ...charsMap };
+    // Making the shift to be cyclic (i.e. with a shift of 1 - 'z' would be mapped to 'a').
+    let encryptedCharIndex = (charIndex + shift) % alphabet.length;
+    // Support negative shifts for creating a map for decryption
+    // (i.e. with shift -1 - 'a' would be mapped to 'z').
+    if (encryptedCharIndex < 0) {
+      encryptedCharIndex += alphabet.length;
+    }
+    charsMapClone[currentChar] = alphabet[encryptedCharIndex];
+    return charsMapClone;
+  }, {});
 };
 
 /**
@@ -31,14 +30,18 @@ const getCipherMap = (alphabet, shift) => {
  * @param {string[]} alphabet
  * @return {string}
  */
-export const caesarCipherEncrypt = (str, shift, alphabet = englishAlphabet) => {
+export const caesarCipherEncrypt = function (str, shift) {
+  let alphabet =
+    arguments.length > 2 && arguments[2] !== undefined
+      ? arguments[2]
+      : englishAlphabet;
   // Create a cipher map:
   const cipherMap = getCipherMap(alphabet, shift);
   return str
     .toLowerCase()
-    .split('')
+    .split("")
     .map((char) => cipherMap[char] || char)
-    .join('');
+    .join("");
 };
 
 /**
@@ -47,12 +50,17 @@ export const caesarCipherEncrypt = (str, shift, alphabet = englishAlphabet) => {
  * @param {string[]} alphabet
  * @return {string}
  */
-export const caesarCipherDecrypt = (str, shift, alphabet = englishAlphabet) => {
+export const caesarCipherDecrypt = function (str, shift) {
+  let alphabet =
+    arguments.length > 2 && arguments[2] !== undefined
+      ? arguments[2]
+      : englishAlphabet;
   // Create a cipher map:
   const cipherMap = getCipherMap(alphabet, -shift);
   return str
     .toLowerCase()
-    .split('')
+    .split("")
     .map((char) => cipherMap[char] || char)
-    .join('');
+    .join("");
 };
+
diff --git a/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js b/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js
index f540ae9..c61a9ad 100644
--- a/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js
+++ b/src/algorithms/cryptography/hill-cipher/_test_/hillCipher.test.js
@@ -1,46 +1,50 @@
-import { hillCipherEncrypt, hillCipherDecrypt } from '../hillCipher';
+import { hillCipherEncrypt, hillCipherDecrypt } from "../hillCipher";
 
-describe('hillCipher', () => {
-  it('should throw an exception when trying to decipher', () => {
-    expect(hillCipherDecrypt).toThrowError('This method is not implemented yet');
+describe("hillCipher", () => {
+  it("should throw an exception when trying to decipher", () => {
+    expect(hillCipherDecrypt).toThrowError(
+      "This method is not implemented yet"
+    );
   });
 
-  it('should throw an error when message or keyString contains none letter character', () => {
+  it("should throw an error when message or keyString contains none letter character", () => {
     const invalidCharacterInMessage = () => {
-      hillCipherEncrypt('hell3', 'helloworld');
+      hillCipherEncrypt("hell3", "helloworld");
     };
     const invalidCharacterInKeyString = () => {
-      hillCipherEncrypt('hello', 'hel12world');
+      hillCipherEncrypt("hello", "hel12world");
     };
     expect(invalidCharacterInMessage).toThrowError(
-      'The message and key string can only contain letters',
+      "The message and key string can only contain letters"
     );
+
     expect(invalidCharacterInKeyString).toThrowError(
-      'The message and key string can only contain letters',
+      "The message and key string can only contain letters"
     );
   });
 
-  it('should throw an error when the length of the keyString has a square root which is not integer', () => {
+  it("should throw an error when the length of the keyString has a square root which is not integer", () => {
     const invalidLengthOfKeyString = () => {
-      hillCipherEncrypt('ab', 'ab');
+      hillCipherEncrypt("ab", "ab");
     };
     expect(invalidLengthOfKeyString).toThrowError(
-      'Invalid key string length. The square root of the key string must be an integer',
+      "Invalid key string length. The square root of the key string must be an integer"
     );
   });
 
-  it('should throw an error when the length of the keyString does not equal to the power of length of the message', () => {
+  it("should throw an error when the length of the keyString does not equal to the power of length of the message", () => {
     const invalidLengthOfKeyString = () => {
-      hillCipherEncrypt('ab', 'aaabbbccc');
+      hillCipherEncrypt("ab", "aaabbbccc");
     };
     expect(invalidLengthOfKeyString).toThrowError(
-      'Invalid key string length. The key length must be a square of message length',
+      "Invalid key string length. The key length must be a square of message length"
     );
   });
 
-  it('should encrypt passed message using Hill Cipher', () => {
-    expect(hillCipherEncrypt('ACT', 'GYBNQKURP')).toBe('POH');
-    expect(hillCipherEncrypt('CAT', 'GYBNQKURP')).toBe('FIN');
-    expect(hillCipherEncrypt('GFG', 'HILLMAGIC')).toBe('SWK');
+  it("should encrypt passed message using Hill Cipher", () => {
+    expect(hillCipherEncrypt("ACT", "GYBNQKURP")).toBe("POH");
+    expect(hillCipherEncrypt("CAT", "GYBNQKURP")).toBe("FIN");
+    expect(hillCipherEncrypt("GFG", "HILLMAGIC")).toBe("SWK");
   });
 });
+
diff --git a/src/algorithms/cryptography/hill-cipher/hillCipher.js b/src/algorithms/cryptography/hill-cipher/hillCipher.js
index 1fe3033..a64cecf 100644
--- a/src/algorithms/cryptography/hill-cipher/hillCipher.js
+++ b/src/algorithms/cryptography/hill-cipher/hillCipher.js
@@ -1,7 +1,7 @@
-import * as mtrx from '../../math/matrix/Matrix';
+import * as mtrx from "../../math/matrix/Matrix";
 
 // The code of an 'A' character (equals to 65).
-const alphabetCodeShift = 'A'.codePointAt(0);
+const alphabetCodeShift = "A".codePointAt(0);
 const englishAlphabetSize = 26;
 
 /**
@@ -14,7 +14,7 @@ const generateKeyMatrix = (keyString) => {
   const matrixSize = Math.sqrt(keyString.length);
   if (!Number.isInteger(matrixSize)) {
     throw new Error(
-      'Invalid key string length. The square root of the key string must be an integer',
+      "Invalid key string length. The square root of the key string must be an integer"
     );
   }
   let keyStringIndex = 0;
@@ -24,10 +24,11 @@ const generateKeyMatrix = (keyString) => {
     // The order the matrix is being filled in is from left to right, from top to bottom.
     () => {
       // A → 0, B → 1, ..., a → 32, b → 33, ...
-      const charCodeShifted = (keyString.codePointAt(keyStringIndex)) % alphabetCodeShift;
+      const charCodeShifted =
+        keyString.codePointAt(keyStringIndex) % alphabetCodeShift;
       keyStringIndex += 1;
       return charCodeShifted;
-    },
+    }
   );
 };
 
@@ -45,7 +46,7 @@ const generateMessageVector = (message) => {
     (cellIndices) => {
       const rowIndex = cellIndices[0];
       return message.codePointAt(rowIndex) % alphabetCodeShift;
-    },
+    }
   );
 };
 
@@ -60,7 +61,7 @@ export function hillCipherEncrypt(message, keyString) {
   // The keyString and message can only contain letters.
   const onlyLettersRegExp = /^[a-zA-Z]+$/;
   if (!onlyLettersRegExp.test(message) || !onlyLettersRegExp.test(keyString)) {
-    throw new Error('The message and key string can only contain letters');
+    throw new Error("The message and key string can only contain letters");
   }
 
   const keyMatrix = generateKeyMatrix(keyString);
@@ -68,14 +69,18 @@ export function hillCipherEncrypt(message, keyString) {
 
   // keyString.length must equal to square of message.length
   if (keyMatrix.length !== message.length) {
-    throw new Error('Invalid key string length. The key length must be a square of message length');
+    throw new Error(
+      "Invalid key string length. The key length must be a square of message length"
+    );
   }
 
   const cipherVector = mtrx.dot(keyMatrix, messageVector);
-  let cipherString = '';
+  let cipherString = "";
   for (let row = 0; row < cipherVector.length; row += 1) {
     const item = cipherVector[row];
-    cipherString += String.fromCharCode((item % englishAlphabetSize) + alphabetCodeShift);
+    cipherString += String.fromCharCode(
+      (item % englishAlphabetSize) + alphabetCodeShift
+    );
   }
 
   return cipherString;
@@ -83,5 +88,6 @@ export function hillCipherEncrypt(message, keyString) {
 
 // @TODO: Implement this method.
 export const hillCipherDecrypt = () => {
-  throw new Error('This method is not implemented yet');
+  throw new Error("This method is not implemented yet");
 };
+
diff --git a/src/algorithms/cryptography/polynomial-hash/PolynomialHash.js b/src/algorithms/cryptography/polynomial-hash/PolynomialHash.js
index d6f774e..4188a38 100644
--- a/src/algorithms/cryptography/polynomial-hash/PolynomialHash.js
+++ b/src/algorithms/cryptography/polynomial-hash/PolynomialHash.js
@@ -6,7 +6,13 @@ export default class PolynomialHash {
    * @param {number} [base] - Base number that is used to create the polynomial.
    * @param {number} [modulus] - Modulus number that keeps the hash from overflowing.
    */
-  constructor({ base = DEFAULT_BASE, modulus = DEFAULT_MODULUS } = {}) {
+  constructor() {
+    let _ref =
+        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+      _ref$base = _ref.base,
+      base = _ref$base === void 0 ? DEFAULT_BASE : _ref$base,
+      _ref$modulus = _ref.modulus,
+      modulus = _ref$modulus === void 0 ? DEFAULT_MODULUS : _ref$modulus;
     this.base = base;
     this.modulus = modulus;
   }
@@ -87,3 +93,4 @@ export default class PolynomialHash {
     return charCode;
   }
 }
+
diff --git a/src/algorithms/cryptography/polynomial-hash/SimplePolynomialHash.js b/src/algorithms/cryptography/polynomial-hash/SimplePolynomialHash.js
index 8e1d512..1cfbc6a 100644
--- a/src/algorithms/cryptography/polynomial-hash/SimplePolynomialHash.js
+++ b/src/algorithms/cryptography/polynomial-hash/SimplePolynomialHash.js
@@ -4,7 +4,11 @@ export default class SimplePolynomialHash {
   /**
    * @param {number} [base] - Base number that is used to create the polynomial.
    */
-  constructor(base = DEFAULT_BASE) {
+  constructor() {
+    let base =
+      arguments.length > 0 && arguments[0] !== undefined
+        ? arguments[0]
+        : DEFAULT_BASE;
     this.base = base;
   }
 
@@ -24,7 +28,7 @@ export default class SimplePolynomialHash {
   hash(word) {
     let hash = 0;
     for (let charIndex = 0; charIndex < word.length; charIndex += 1) {
-      hash += word.charCodeAt(charIndex) * (this.base ** charIndex);
+      hash += word.charCodeAt(charIndex) * this.base ** charIndex;
     }
 
     return hash;
@@ -56,8 +60,9 @@ export default class SimplePolynomialHash {
 
     hash -= prevValue;
     hash /= this.base;
-    hash += newValue * (this.base ** (newWord.length - 1));
+    hash += newValue * this.base ** (newWord.length - 1);
 
     return hash;
   }
 }
+
diff --git a/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js b/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js
index 0d48784..f80189e 100644
--- a/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js
+++ b/src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js
@@ -1,18 +1,19 @@
-import PolynomialHash from '../PolynomialHash';
+import PolynomialHash from "../PolynomialHash";
 
-describe('PolynomialHash', () => {
-  it('should calculate new hash based on previous one', () => {
+describe("PolynomialHash", () => {
+  it("should calculate new hash based on previous one", () => {
     const bases = [3, 79, 101, 3251, 13229, 122743, 3583213];
     const mods = [79, 101];
     const frameSizes = [5, 20];
 
     // @TODO: Provide Unicode support.
-    const text = 'Lorem Ipsum is simply dummy text of the printing and '
-      + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
-      + 'galley of type and \u{ffff} scrambled it to make a type specimen book. It '
-      + 'electronic 耀 typesetting, remaining essentially unchanged. It was '
+    const text =
+      "Lorem Ipsum is simply dummy text of the printing and " +
+      "typesetting industry. Lorem Ipsum has been the industry's standard " +
+      "galley of type and \u{ffff} scrambled it to make a type specimen book. It " +
+      "electronic 耀 typesetting, remaining essentially unchanged. It was " +
       // + 'popularised in the \u{20005} \u{20000}1960s with the release of Letraset sheets '
-      + 'publishing software like Aldus PageMaker 耀 including versions of Lorem.';
+      "publishing software like Aldus PageMaker 耀 including versions of Lorem.";
 
     // Check hashing for different prime base.
     bases.forEach((base) => {
@@ -25,10 +26,18 @@ describe('PolynomialHash', () => {
           let previousHash = polynomialHash.hash(previousWord);
 
           // Shift frame through the whole text.
-          for (let frameShift = 1; frameShift < (text.length - frameSize); frameShift += 1) {
+          for (
+            let frameShift = 1;
+            frameShift < text.length - frameSize;
+            frameShift += 1
+          ) {
             const currentWord = text.substr(frameShift, frameSize);
             const currentHash = polynomialHash.hash(currentWord);
-            const currentRollingHash = polynomialHash.roll(previousHash, previousWord, currentWord);
+            const currentRollingHash = polynomialHash.roll(
+              previousHash,
+              previousWord,
+              currentWord
+            );
 
             // Check that rolling hash is the same as directly calculated hash.
             expect(currentRollingHash).toBe(currentHash);
@@ -41,19 +50,22 @@ describe('PolynomialHash', () => {
     });
   });
 
-  it('should generate numeric hashed less than 100', () => {
+  it("should generate numeric hashed less than 100", () => {
     const polynomialHash = new PolynomialHash({ modulus: 100 });
 
-    expect(polynomialHash.hash('Some long text that is used as a key')).toBe(41);
-    expect(polynomialHash.hash('Test')).toBe(92);
-    expect(polynomialHash.hash('a')).toBe(97);
-    expect(polynomialHash.hash('b')).toBe(98);
-    expect(polynomialHash.hash('c')).toBe(99);
-    expect(polynomialHash.hash('d')).toBe(0);
-    expect(polynomialHash.hash('e')).toBe(1);
-    expect(polynomialHash.hash('ab')).toBe(87);
+    expect(polynomialHash.hash("Some long text that is used as a key")).toBe(
+      41
+    );
+    expect(polynomialHash.hash("Test")).toBe(92);
+    expect(polynomialHash.hash("a")).toBe(97);
+    expect(polynomialHash.hash("b")).toBe(98);
+    expect(polynomialHash.hash("c")).toBe(99);
+    expect(polynomialHash.hash("d")).toBe(0);
+    expect(polynomialHash.hash("e")).toBe(1);
+    expect(polynomialHash.hash("ab")).toBe(87);
 
     // @TODO: Provide Unicode support.
-    expect(polynomialHash.hash('\u{20000}')).toBe(92);
+    expect(polynomialHash.hash("\u{20000}")).toBe(92);
   });
 });
+
diff --git a/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js b/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js
index 28c5519..e6a6cdb 100644
--- a/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js
+++ b/src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js
@@ -1,16 +1,17 @@
-import SimplePolynomialHash from '../SimplePolynomialHash';
+import SimplePolynomialHash from "../SimplePolynomialHash";
 
-describe('PolynomialHash', () => {
-  it('should calculate new hash based on previous one', () => {
+describe("PolynomialHash", () => {
+  it("should calculate new hash based on previous one", () => {
     const bases = [3, 5];
     const frameSizes = [5, 10];
 
-    const text = 'Lorem Ipsum is simply dummy text of the printing and '
-      + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
-      + 'galley of type and \u{ffff} scrambled it to make a type specimen book. It '
-      + 'electronic 耀 typesetting, remaining essentially unchanged. It was '
-      + 'popularised in the 1960s with the release of Letraset sheets '
-      + 'publishing software like Aldus 耀 PageMaker including versions of Lorem.';
+    const text =
+      "Lorem Ipsum is simply dummy text of the printing and " +
+      "typesetting industry. Lorem Ipsum has been the industry's standard " +
+      "galley of type and \u{ffff} scrambled it to make a type specimen book. It " +
+      "electronic 耀 typesetting, remaining essentially unchanged. It was " +
+      "popularised in the 1960s with the release of Letraset sheets " +
+      "publishing software like Aldus 耀 PageMaker including versions of Lorem.";
 
     // Check hashing for different prime base.
     bases.forEach((base) => {
@@ -22,10 +23,18 @@ describe('PolynomialHash', () => {
         let previousHash = polynomialHash.hash(previousWord);
 
         // Shift frame through the whole text.
-        for (let frameShift = 1; frameShift < (text.length - frameSize); frameShift += 1) {
+        for (
+          let frameShift = 1;
+          frameShift < text.length - frameSize;
+          frameShift += 1
+        ) {
           const currentWord = text.substr(frameShift, frameSize);
           const currentHash = polynomialHash.hash(currentWord);
-          const currentRollingHash = polynomialHash.roll(previousHash, previousWord, currentWord);
+          const currentRollingHash = polynomialHash.roll(
+            previousHash,
+            previousWord,
+            currentWord
+          );
 
           // Check that rolling hash is the same as directly calculated hash.
           expect(currentRollingHash).toBe(currentHash);
@@ -37,16 +46,17 @@ describe('PolynomialHash', () => {
     });
   });
 
-  it('should generate numeric hashed', () => {
+  it("should generate numeric hashed", () => {
     const polynomialHash = new SimplePolynomialHash();
 
-    expect(polynomialHash.hash('Test')).toBe(604944);
-    expect(polynomialHash.hash('a')).toBe(97);
-    expect(polynomialHash.hash('b')).toBe(98);
-    expect(polynomialHash.hash('c')).toBe(99);
-    expect(polynomialHash.hash('d')).toBe(100);
-    expect(polynomialHash.hash('e')).toBe(101);
-    expect(polynomialHash.hash('ab')).toBe(1763);
-    expect(polynomialHash.hash('abc')).toBe(30374);
+    expect(polynomialHash.hash("Test")).toBe(604944);
+    expect(polynomialHash.hash("a")).toBe(97);
+    expect(polynomialHash.hash("b")).toBe(98);
+    expect(polynomialHash.hash("c")).toBe(99);
+    expect(polynomialHash.hash("d")).toBe(100);
+    expect(polynomialHash.hash("e")).toBe(101);
+    expect(polynomialHash.hash("ab")).toBe(1763);
+    expect(polynomialHash.hash("abc")).toBe(30374);
   });
 });
+
diff --git a/src/algorithms/cryptography/rail-fence-cipher/__test__/railFenceCipher.test.js b/src/algorithms/cryptography/rail-fence-cipher/__test__/railFenceCipher.test.js
index db0c49e..7795b61 100644
--- a/src/algorithms/cryptography/rail-fence-cipher/__test__/railFenceCipher.test.js
+++ b/src/algorithms/cryptography/rail-fence-cipher/__test__/railFenceCipher.test.js
@@ -1,43 +1,43 @@
-import { encodeRailFenceCipher, decodeRailFenceCipher } from '../railFenceCipher';
+import {
+  encodeRailFenceCipher,
+  decodeRailFenceCipher,
+} from "../railFenceCipher";
 
-describe('railFenceCipher', () => {
-  it('encodes a string correctly for base=3', () => {
-    expect(encodeRailFenceCipher('', 3)).toBe('');
-    expect(encodeRailFenceCipher('12345', 3)).toBe(
-      '15243',
-    );
-    expect(encodeRailFenceCipher('WEAREDISCOVEREDFLEEATONCE', 3)).toBe(
-      'WECRLTEERDSOEEFEAOCAIVDEN',
-    );
-    expect(encodeRailFenceCipher('Hello, World!', 3)).toBe(
-      'Hoo!el,Wrdl l',
+describe("railFenceCipher", () => {
+  it("encodes a string correctly for base=3", () => {
+    expect(encodeRailFenceCipher("", 3)).toBe("");
+    expect(encodeRailFenceCipher("12345", 3)).toBe("15243");
+
+    expect(encodeRailFenceCipher("WEAREDISCOVEREDFLEEATONCE", 3)).toBe(
+      "WECRLTEERDSOEEFEAOCAIVDEN"
     );
+
+    expect(encodeRailFenceCipher("Hello, World!", 3)).toBe("Hoo!el,Wrdl l");
   });
 
-  it('decodes a string correctly for base=3', () => {
-    expect(decodeRailFenceCipher('', 3)).toBe('');
-    expect(decodeRailFenceCipher('WECRLTEERDSOEEFEAOCAIVDEN', 3)).toBe(
-      'WEAREDISCOVEREDFLEEATONCE',
-    );
-    expect(decodeRailFenceCipher('Hoo!el,Wrdl l', 3)).toBe(
-      'Hello, World!',
-    );
-    expect(decodeRailFenceCipher('15243', 3)).toBe(
-      '12345',
+  it("decodes a string correctly for base=3", () => {
+    expect(decodeRailFenceCipher("", 3)).toBe("");
+    expect(decodeRailFenceCipher("WECRLTEERDSOEEFEAOCAIVDEN", 3)).toBe(
+      "WEAREDISCOVEREDFLEEATONCE"
     );
+
+    expect(decodeRailFenceCipher("Hoo!el,Wrdl l", 3)).toBe("Hello, World!");
+
+    expect(decodeRailFenceCipher("15243", 3)).toBe("12345");
   });
 
-  it('encodes a string correctly for base=4', () => {
-    expect(encodeRailFenceCipher('', 4)).toBe('');
-    expect(encodeRailFenceCipher('THEYAREATTACKINGFROMTHENORTH', 4)).toBe(
-      'TEKOOHRACIRMNREATANFTETYTGHH',
+  it("encodes a string correctly for base=4", () => {
+    expect(encodeRailFenceCipher("", 4)).toBe("");
+    expect(encodeRailFenceCipher("THEYAREATTACKINGFROMTHENORTH", 4)).toBe(
+      "TEKOOHRACIRMNREATANFTETYTGHH"
     );
   });
 
-  it('decodes a string correctly for base=4', () => {
-    expect(decodeRailFenceCipher('', 4)).toBe('');
-    expect(decodeRailFenceCipher('TEKOOHRACIRMNREATANFTETYTGHH', 4)).toBe(
-      'THEYAREATTACKINGFROMTHENORTH',
+  it("decodes a string correctly for base=4", () => {
+    expect(decodeRailFenceCipher("", 4)).toBe("");
+    expect(decodeRailFenceCipher("TEKOOHRACIRMNREATANFTETYTGHH", 4)).toBe(
+      "THEYAREATTACKINGFROMTHENORTH"
     );
   });
 });
+
diff --git a/src/algorithms/cryptography/rail-fence-cipher/railFenceCipher.js b/src/algorithms/cryptography/rail-fence-cipher/railFenceCipher.js
index 7b58037..35e2858 100644
--- a/src/algorithms/cryptography/rail-fence-cipher/railFenceCipher.js
+++ b/src/algorithms/cryptography/rail-fence-cipher/railFenceCipher.js
@@ -1,3 +1,76 @@
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _toArray(arr) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArray(iter) {
+  if (
+    (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||
+    iter["@@iterator"] != null
+  )
+    return Array.from(iter);
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
 /**
  * @typedef {string[]} Rail
  * @typedef {Rail[]} Fence
@@ -18,9 +91,10 @@ const DIRECTIONS = { UP: -1, DOWN: 1 };
  * @param {number} rowsNum
  * @returns {Fence}
  */
-const buildFence = (rowsNum) => Array(rowsNum)
-  .fill(null)
-  .map(() => []);
+const buildFence = (rowsNum) =>
+  Array(rowsNum)
+    .fill(null)
+    .map(() => []);
 
 /**
  * Get next direction to move (based on the current one) while traversing the fence.
@@ -31,7 +105,10 @@ const buildFence = (rowsNum) => Array(rowsNum)
  * @param {Direction} params.direction - Current direction
  * @returns {Direction} - The next direction to take
  */
-const getNextDirection = ({ railCount, currentRail, direction }) => {
+const getNextDirection = (_ref) => {
+  let railCount = _ref.railCount,
+    currentRail = _ref.currentRail,
+    direction = _ref.direction;
   switch (currentRail) {
     case 0:
       // Go down if we're on top of the fence.
@@ -59,9 +136,7 @@ const addCharToRail = (targetRailIndex, letter) => {
    * @returns {Rail}
    */
   function onEachRail(rail, currentRail) {
-    return currentRail === targetRailIndex
-      ? [...rail, letter]
-      : rail;
+    return currentRail === targetRailIndex ? [...rail, letter] : rail;
   }
   return onEachRail;
 };
@@ -76,12 +151,11 @@ const addCharToRail = (targetRailIndex, letter) => {
  * @param {string[]} params.chars
  * @returns {Fence}
  */
-const fillEncodeFence = ({
-  fence,
-  currentRail,
-  direction,
-  chars,
-}) => {
+const fillEncodeFence = (_ref2) => {
+  let fence = _ref2.fence,
+    currentRail = _ref2.currentRail,
+    direction = _ref2.direction,
+    chars = _ref2.chars;
   if (chars.length === 0) {
     // All chars have been placed on a fence.
     return fence;
@@ -90,7 +164,9 @@ const fillEncodeFence = ({
   const railCount = fence.length;
 
   // Getting the next character to place on a fence.
-  const [letter, ...nextChars] = chars;
+  const _chars = _toArray(chars),
+    letter = _chars[0],
+    nextChars = _chars.slice(1);
   const nextDirection = getNextDirection({
     railCount,
     currentRail,
@@ -116,9 +192,12 @@ const fillEncodeFence = ({
  * @returns {Fence}
  */
 const fillDecodeFence = (params) => {
-  const {
-    strLen, chars, fence, targetRail, direction, coords,
-  } = params;
+  const strLen = params.strLen,
+    chars = params.chars,
+    fence = params.fence,
+    targetRail = params.targetRail,
+    direction = params.direction,
+    coords = params.coords;
 
   const railCount = fence.length;
 
@@ -126,13 +205,14 @@ const fillDecodeFence = (params) => {
     return fence;
   }
 
-  const [currentRail, currentColumn] = coords;
+  const _coords = _slicedToArray(coords, 2),
+    currentRail = _coords[0],
+    currentColumn = _coords[1];
   const shouldGoNextRail = currentColumn === strLen - 1;
   const nextDirection = shouldGoNextRail
     ? DIRECTIONS.DOWN
-    : getNextDirection(
-      { railCount, currentRail, direction },
-    );
+    : getNextDirection({ railCount, currentRail, direction });
+
   const nextRail = shouldGoNextRail ? targetRail + 1 : targetRail;
   const nextCoords = [
     shouldGoNextRail ? 0 : currentRail + nextDirection,
@@ -140,9 +220,13 @@ const fillDecodeFence = (params) => {
   ];
 
   const shouldAddChar = currentRail === targetRail;
-  const [currentChar, ...remainderChars] = chars;
+  const _chars2 = _toArray(chars),
+    currentChar = _chars2[0],
+    remainderChars = _chars2.slice(1);
   const nextString = shouldAddChar ? remainderChars : chars;
-  const nextFence = shouldAddChar ? fence.map(addCharToRail(currentRail, currentChar)) : fence;
+  const nextFence = shouldAddChar
+    ? fence.map(addCharToRail(currentRail, currentChar))
+    : fence;
 
   return fillDecodeFence({
     strLen,
@@ -164,24 +248,22 @@ const fillDecodeFence = (params) => {
  * @returns {string}
  */
 const decodeFence = (params) => {
-  const {
-    strLen,
-    fence,
-    currentRail,
-    direction,
-    code,
-  } = params;
+  const strLen = params.strLen,
+    fence = params.fence,
+    currentRail = params.currentRail,
+    direction = params.direction,
+    code = params.code;
 
   if (code.length === strLen) {
-    return code.join('');
+    return code.join("");
   }
 
   const railCount = fence.length;
 
-  const [currentChar, ...nextRail] = fence[currentRail];
-  const nextDirection = getNextDirection(
-    { railCount, currentRail, direction },
-  );
+  const _fence$currentRail = _toArray(fence[currentRail]),
+    currentChar = _fence$currentRail[0],
+    nextRail = _fence$currentRail.slice(1);
+  const nextDirection = getNextDirection({ railCount, currentRail, direction });
 
   return decodeFence({
     railCount,
@@ -207,10 +289,10 @@ export const encodeRailFenceCipher = (string, railCount) => {
     fence,
     currentRail: 0,
     direction: DIRECTIONS.DOWN,
-    chars: string.split(''),
+    chars: string.split(""),
   });
 
-  return filledFence.flat().join('');
+  return filledFence.flat().join("");
 };
 
 /**
@@ -225,7 +307,7 @@ export const decodeRailFenceCipher = (string, railCount) => {
   const emptyFence = buildFence(railCount);
   const filledFence = fillDecodeFence({
     strLen,
-    chars: string.split(''),
+    chars: string.split(""),
     fence: emptyFence,
     targetRail: 0,
     direction: DIRECTIONS.DOWN,
@@ -240,3 +322,4 @@ export const decodeRailFenceCipher = (string, railCount) => {
     code: [],
   });
 };
+
diff --git a/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js b/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js
index b021305..bb9e4d9 100644
--- a/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js
+++ b/src/algorithms/graph/articulation-points/__test__/articulationPoints.test.js
@@ -1,14 +1,14 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import articulationPoints from '../articulationPoints';
-
-describe('articulationPoints', () => {
-  it('should find articulation points in simple graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import articulationPoints from "../articulationPoints";
+
+describe("articulationPoints", () => {
+  it("should find articulation points in simple graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -16,10 +16,7 @@ describe('articulationPoints', () => {
 
     const graph = new Graph();
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD);
 
     const articulationPointsSet = Object.values(articulationPoints(graph));
 
@@ -28,11 +25,11 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[1].getKey()).toBe(vertexB.getKey());
   });
 
-  it('should find articulation points in simple graph with back edge', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should find articulation points in simple graph with back edge", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -41,11 +38,7 @@ describe('articulationPoints', () => {
 
     const graph = new Graph();
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeAC)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD);
+    graph.addEdge(edgeAB).addEdge(edgeAC).addEdge(edgeBC).addEdge(edgeCD);
 
     const articulationPointsSet = Object.values(articulationPoints(graph));
 
@@ -53,12 +46,12 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
   });
 
-  it('should find articulation points in simple graph with back edge #2', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
+  it("should find articulation points in simple graph with back edge #2", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -81,15 +74,15 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
   });
 
-  it('should find articulation points in graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+  it("should find articulation points in graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -123,15 +116,15 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[3].getKey()).toBe(vertexC.getKey());
   });
 
-  it('should find articulation points in graph starting with articulation root vertex', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+  it("should find articulation points in graph starting with articulation root vertex", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -165,12 +158,12 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[3].getKey()).toBe(vertexD.getKey());
   });
 
-  it('should find articulation points in yet another graph #1', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
+  it("should find articulation points in yet another graph #1", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
@@ -194,14 +187,14 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[1].getKey()).toBe(vertexC.getKey());
   });
 
-  it('should find articulation points in yet another graph #2', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+  it("should find articulation points in yet another graph #2", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
@@ -230,3 +223,4 @@ describe('articulationPoints', () => {
     expect(articulationPointsSet[0].getKey()).toBe(vertexC.getKey());
   });
 });
+
diff --git a/src/algorithms/graph/articulation-points/articulationPoints.js b/src/algorithms/graph/articulation-points/articulationPoints.js
index 0cc1db6..f99509d 100644
--- a/src/algorithms/graph/articulation-points/articulationPoints.js
+++ b/src/algorithms/graph/articulation-points/articulationPoints.js
@@ -1,10 +1,12 @@
-import depthFirstSearch from '../depth-first-search/depthFirstSearch';
+import depthFirstSearch from "../depth-first-search/depthFirstSearch";
 
 /**
  * Helper class for visited vertex metadata.
  */
 class VisitMetadata {
-  constructor({ discoveryTime, lowDiscoveryTime }) {
+  constructor(_ref) {
+    let discoveryTime = _ref.discoveryTime,
+      lowDiscoveryTime = _ref.lowDiscoveryTime;
     this.discoveryTime = discoveryTime;
     this.lowDiscoveryTime = lowDiscoveryTime;
     // We need this in order to check graph root node, whether it has two
@@ -37,7 +39,9 @@ export default function articulationPoints(graph) {
      * @param {GraphVertex} currentVertex
      * @param {GraphVertex} previousVertex
      */
-    enterVertex: ({ currentVertex, previousVertex }) => {
+    enterVertex: (_ref2) => {
+      let currentVertex = _ref2.currentVertex,
+        previousVertex = _ref2.previousVertex;
       // Tick discovery time.
       discoveryTime += 1;
 
@@ -56,7 +60,9 @@ export default function articulationPoints(graph) {
      * @param {GraphVertex} currentVertex
      * @param {GraphVertex} previousVertex
      */
-    leaveVertex: ({ currentVertex, previousVertex }) => {
+    leaveVertex: (_ref3) => {
+      let currentVertex = _ref3.currentVertex,
+        previousVertex = _ref3.previousVertex;
       if (previousVertex === null) {
         // Don't do anything for the root vertex if it is already current (not previous one)
         return;
@@ -65,19 +71,21 @@ export default function articulationPoints(graph) {
       // Update the low time with the smallest time of adjacent vertices.
       // Get minimum low discovery time from all neighbors.
       /** @param {GraphVertex} neighbor */
-      visitedSet[currentVertex.getKey()].lowDiscoveryTime = currentVertex.getNeighbors()
-        .filter((earlyNeighbor) => earlyNeighbor.getKey() !== previousVertex.getKey())
+      visitedSet[currentVertex.getKey()].lowDiscoveryTime = currentVertex
+        .getNeighbors()
+        .filter(
+          (earlyNeighbor) => earlyNeighbor.getKey() !== previousVertex.getKey()
+        )
         /**
          * @param {number} lowestDiscoveryTime
          * @param {GraphVertex} neighbor
-         */
-        .reduce(
-          (lowestDiscoveryTime, neighbor) => {
-            const neighborLowTime = visitedSet[neighbor.getKey()].lowDiscoveryTime;
-            return neighborLowTime < lowestDiscoveryTime ? neighborLowTime : lowestDiscoveryTime;
-          },
-          visitedSet[currentVertex.getKey()].lowDiscoveryTime,
-        );
+         */ .reduce((lowestDiscoveryTime, neighbor) => {
+          const neighborLowTime =
+            visitedSet[neighbor.getKey()].lowDiscoveryTime;
+          return neighborLowTime < lowestDiscoveryTime
+            ? neighborLowTime
+            : lowestDiscoveryTime;
+        }, visitedSet[currentVertex.getKey()].lowDiscoveryTime);
 
       // Detect whether previous vertex is articulation point or not.
       // To do so we need to check two [OR] conditions:
@@ -90,18 +98,21 @@ export default function articulationPoints(graph) {
         }
       } else {
         // Get current vertex low discovery time.
-        const currentLowDiscoveryTime = visitedSet[currentVertex.getKey()].lowDiscoveryTime;
+        const currentLowDiscoveryTime =
+          visitedSet[currentVertex.getKey()].lowDiscoveryTime;
 
         // Compare current vertex low discovery time with parent discovery time. Check if there
         // are any short path (back edge) exists. If we can't get to current vertex other then
         // via parent then the parent vertex is articulation point for current one.
-        const parentDiscoveryTime = visitedSet[previousVertex.getKey()].discoveryTime;
+        const parentDiscoveryTime =
+          visitedSet[previousVertex.getKey()].discoveryTime;
         if (parentDiscoveryTime <= currentLowDiscoveryTime) {
           articulationPointsSet[previousVertex.getKey()] = previousVertex;
         }
       }
     },
-    allowTraversal: ({ nextVertex }) => {
+    allowTraversal: (_ref4) => {
+      let nextVertex = _ref4.nextVertex;
       return !visitedSet[nextVertex.getKey()];
     },
   };
@@ -111,3 +122,4 @@ export default function articulationPoints(graph) {
 
   return articulationPointsSet;
 }
+
diff --git a/src/algorithms/graph/bellman-ford/__test__/bellmanFord.test.js b/src/algorithms/graph/bellman-ford/__test__/bellmanFord.test.js
index ffa30eb..eea02cd 100644
--- a/src/algorithms/graph/bellman-ford/__test__/bellmanFord.test.js
+++ b/src/algorithms/graph/bellman-ford/__test__/bellmanFord.test.js
@@ -1,18 +1,18 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import bellmanFord from '../bellmanFord';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import bellmanFord from "../bellmanFord";
 
-describe('bellmanFord', () => {
-  it('should find minimum paths to all vertices for undirected graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+describe("bellmanFord", () => {
+  it("should find minimum paths to all vertices for undirected graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 4);
     const edgeAE = new GraphEdge(vertexA, vertexE, 7);
@@ -43,7 +43,9 @@ describe('bellmanFord', () => {
       .addEdge(edgeFG)
       .addEdge(edgeEG);
 
-    const { distances, previousVertices } = bellmanFord(graph, vertexA);
+    const _bellmanFord = bellmanFord(graph, vertexA),
+      distances = _bellmanFord.distances,
+      previousVertices = _bellmanFord.previousVertices;
 
     expect(distances).toEqual({
       H: Infinity,
@@ -56,23 +58,23 @@ describe('bellmanFord', () => {
       F: 11,
     });
 
-    expect(previousVertices.F.getKey()).toBe('D');
-    expect(previousVertices.D.getKey()).toBe('B');
-    expect(previousVertices.B.getKey()).toBe('A');
-    expect(previousVertices.G.getKey()).toBe('E');
-    expect(previousVertices.C.getKey()).toBe('A');
+    expect(previousVertices.F.getKey()).toBe("D");
+    expect(previousVertices.D.getKey()).toBe("B");
+    expect(previousVertices.B.getKey()).toBe("A");
+    expect(previousVertices.G.getKey()).toBe("E");
+    expect(previousVertices.C.getKey()).toBe("A");
     expect(previousVertices.A).toBeNull();
     expect(previousVertices.H).toBeNull();
   });
 
-  it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
-    const vertexS = new GraphVertex('S');
-    const vertexE = new GraphVertex('E');
-    const vertexA = new GraphVertex('A');
-    const vertexD = new GraphVertex('D');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexH = new GraphVertex('H');
+  it("should find minimum paths to all vertices for directed graph with negative edge weights", () => {
+    const vertexS = new GraphVertex("S");
+    const vertexE = new GraphVertex("E");
+    const vertexA = new GraphVertex("A");
+    const vertexD = new GraphVertex("D");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexH = new GraphVertex("H");
 
     const edgeSE = new GraphEdge(vertexS, vertexE, 8);
     const edgeSA = new GraphEdge(vertexS, vertexA, 10);
@@ -95,7 +97,9 @@ describe('bellmanFord', () => {
       .addEdge(edgeCB)
       .addEdge(edgeBA);
 
-    const { distances, previousVertices } = bellmanFord(graph, vertexS);
+    const _bellmanFord2 = bellmanFord(graph, vertexS),
+      distances = _bellmanFord2.distances,
+      previousVertices = _bellmanFord2.previousVertices;
 
     expect(distances).toEqual({
       H: Infinity,
@@ -109,9 +113,10 @@ describe('bellmanFord', () => {
 
     expect(previousVertices.H).toBeNull();
     expect(previousVertices.S).toBeNull();
-    expect(previousVertices.B.getKey()).toBe('C');
-    expect(previousVertices.C.getKey()).toBe('A');
-    expect(previousVertices.A.getKey()).toBe('D');
-    expect(previousVertices.D.getKey()).toBe('E');
+    expect(previousVertices.B.getKey()).toBe("C");
+    expect(previousVertices.C.getKey()).toBe("A");
+    expect(previousVertices.A.getKey()).toBe("D");
+    expect(previousVertices.D.getKey()).toBe("E");
   });
 });
+
diff --git a/src/algorithms/graph/bellman-ford/bellmanFord.js b/src/algorithms/graph/bellman-ford/bellmanFord.js
index 70e811d..56a1402 100644
--- a/src/algorithms/graph/bellman-ford/bellmanFord.js
+++ b/src/algorithms/graph/bellman-ford/bellmanFord.js
@@ -18,7 +18,11 @@ export default function bellmanFord(graph, startVertex) {
   });
 
   // We need (|V| - 1) iterations.
-  for (let iteration = 0; iteration < (graph.getAllVertices().length - 1); iteration += 1) {
+  for (
+    let iteration = 0;
+    iteration < graph.getAllVertices().length - 1;
+    iteration += 1
+  ) {
     // During each iteration go through all vertices.
     Object.keys(distances).forEach((vertexKey) => {
       const vertex = graph.getVertexByKey(vertexKey);
@@ -43,3 +47,4 @@ export default function bellmanFord(graph, startVertex) {
     previousVertices,
   };
 }
+
diff --git a/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js b/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js
index c9bff22..e4bebda 100644
--- a/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js
+++ b/src/algorithms/graph/breadth-first-search/__test__/breadthFirstSearch.test.js
@@ -1,20 +1,20 @@
-import Graph from '../../../../data-structures/graph/Graph';
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import breadthFirstSearch from '../breadthFirstSearch';
+import Graph from "../../../../data-structures/graph/Graph";
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import breadthFirstSearch from "../breadthFirstSearch";
 
-describe('breadthFirstSearch', () => {
-  it('should perform BFS operation on graph', () => {
+describe("breadthFirstSearch", () => {
+  it("should perform BFS operation on graph", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -37,7 +37,7 @@ describe('breadthFirstSearch', () => {
       .addEdge(edgeDH)
       .addEdge(edgeGH);
 
-    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');
+    expect(graph.toString()).toBe("A,B,C,G,D,E,F,H");
 
     const enterVertexCallback = jest.fn();
     const leaveVertexCallback = jest.fn();
@@ -65,10 +65,18 @@ describe('breadthFirstSearch', () => {
       { currentVertex: vertexG, previousVertex: vertexF },
     ];
 
-    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
+    for (
+      let callIndex = 0;
+      callIndex < graph.getAllVertices().length;
+      callIndex += 1
+    ) {
       const params = enterVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        enterVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        enterVertexParamsMap[callIndex].previousVertex
+      );
     }
 
     const leaveVertexParamsMap = [
@@ -82,24 +90,32 @@ describe('breadthFirstSearch', () => {
       { currentVertex: vertexG, previousVertex: vertexF },
     ];
 
-    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
+    for (
+      let callIndex = 0;
+      callIndex < graph.getAllVertices().length;
+      callIndex += 1
+    ) {
       const params = leaveVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        leaveVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        leaveVertexParamsMap[callIndex].previousVertex
+      );
     }
   });
 
-  it('should allow to create custom vertex visiting logic', () => {
+  it("should allow to create custom vertex visiting logic", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -122,7 +138,7 @@ describe('breadthFirstSearch', () => {
       .addEdge(edgeDH)
       .addEdge(edgeGH);
 
-    expect(graph.toString()).toBe('A,B,C,G,D,E,F,H');
+    expect(graph.toString()).toBe("A,B,C,G,D,E,F,H");
 
     const enterVertexCallback = jest.fn();
     const leaveVertexCallback = jest.fn();
@@ -131,7 +147,9 @@ describe('breadthFirstSearch', () => {
     breadthFirstSearch(graph, vertexA, {
       enterVertex: enterVertexCallback,
       leaveVertex: leaveVertexCallback,
-      allowTraversal: ({ currentVertex, nextVertex }) => {
+      allowTraversal: (_ref) => {
+        let currentVertex = _ref.currentVertex,
+          nextVertex = _ref.nextVertex;
         return !(currentVertex === vertexA && nextVertex === vertexB);
       },
     });
@@ -151,8 +169,12 @@ describe('breadthFirstSearch', () => {
 
     for (let callIndex = 0; callIndex < 7; callIndex += 1) {
       const params = enterVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        enterVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        enterVertexParamsMap[callIndex].previousVertex
+      );
     }
 
     const leaveVertexParamsMap = [
@@ -167,8 +189,13 @@ describe('breadthFirstSearch', () => {
 
     for (let callIndex = 0; callIndex < 7; callIndex += 1) {
       const params = leaveVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        leaveVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        leaveVertexParamsMap[callIndex].previousVertex
+      );
     }
   });
 });
+
diff --git a/src/algorithms/graph/breadth-first-search/breadthFirstSearch.js b/src/algorithms/graph/breadth-first-search/breadthFirstSearch.js
index d4b955e..d672a8a 100644
--- a/src/algorithms/graph/breadth-first-search/breadthFirstSearch.js
+++ b/src/algorithms/graph/breadth-first-search/breadthFirstSearch.js
@@ -1,4 +1,4 @@
-import Queue from '../../../data-structures/queue/Queue';
+import Queue from "../../../data-structures/queue/Queue";
 
 /**
  * @typedef {Object} Callbacks
@@ -16,25 +16,27 @@ import Queue from '../../../data-structures/queue/Queue';
  * @param {Callbacks} [callbacks]
  * @returns {Callbacks}
  */
-function initCallbacks(callbacks = {}) {
+function initCallbacks() {
+  let callbacks =
+    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
   const initiatedCallback = callbacks;
 
   const stubCallback = () => {};
 
-  const allowTraversalCallback = (
-    () => {
-      const seen = {};
-      return ({ nextVertex }) => {
-        if (!seen[nextVertex.getKey()]) {
-          seen[nextVertex.getKey()] = true;
-          return true;
-        }
-        return false;
-      };
-    }
-  )();
+  const allowTraversalCallback = (() => {
+    const seen = {};
+    return (_ref) => {
+      let nextVertex = _ref.nextVertex;
+      if (!seen[nextVertex.getKey()]) {
+        seen[nextVertex.getKey()] = true;
+        return true;
+      }
+      return false;
+    };
+  })();
 
-  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
+  initiatedCallback.allowTraversal =
+    callbacks.allowTraversal || allowTraversalCallback;
   initiatedCallback.enterVertex = callbacks.enterVertex || stubCallback;
   initiatedCallback.leaveVertex = callbacks.leaveVertex || stubCallback;
 
@@ -46,7 +48,11 @@ function initCallbacks(callbacks = {}) {
  * @param {GraphVertex} startVertex
  * @param {Callbacks} [originalCallbacks]
  */
-export default function breadthFirstSearch(graph, startVertex, originalCallbacks) {
+export default function breadthFirstSearch(
+  graph,
+  startVertex,
+  originalCallbacks
+) {
   const callbacks = initCallbacks(originalCallbacks);
   const vertexQueue = new Queue();
 
@@ -62,7 +68,9 @@ export default function breadthFirstSearch(graph, startVertex, originalCallbacks
 
     // Add all neighbors to the queue for future traversals.
     graph.getNeighbors(currentVertex).forEach((nextVertex) => {
-      if (callbacks.allowTraversal({ previousVertex, currentVertex, nextVertex })) {
+      if (
+        callbacks.allowTraversal({ previousVertex, currentVertex, nextVertex })
+      ) {
         vertexQueue.enqueue(nextVertex);
       }
     });
@@ -73,3 +81,4 @@ export default function breadthFirstSearch(graph, startVertex, originalCallbacks
     previousVertex = currentVertex;
   }
 }
+
diff --git a/src/algorithms/graph/bridges/__test__/graphBridges.test.js b/src/algorithms/graph/bridges/__test__/graphBridges.test.js
index 0183752..6dd9916 100644
--- a/src/algorithms/graph/bridges/__test__/graphBridges.test.js
+++ b/src/algorithms/graph/bridges/__test__/graphBridges.test.js
@@ -1,14 +1,14 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import graphBridges from '../graphBridges';
-
-describe('graphBridges', () => {
-  it('should find bridges in simple graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import graphBridges from "../graphBridges";
+
+describe("graphBridges", () => {
+  it("should find bridges in simple graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -16,10 +16,7 @@ describe('graphBridges', () => {
 
     const graph = new Graph();
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD);
 
     const bridges = Object.values(graphBridges(graph));
 
@@ -29,11 +26,11 @@ describe('graphBridges', () => {
     expect(bridges[2].getKey()).toBe(edgeAB.getKey());
   });
 
-  it('should find bridges in simple graph with back edge', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should find bridges in simple graph with back edge", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -42,11 +39,7 @@ describe('graphBridges', () => {
 
     const graph = new Graph();
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeAC)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD);
+    graph.addEdge(edgeAB).addEdge(edgeAC).addEdge(edgeBC).addEdge(edgeCD);
 
     const bridges = Object.values(graphBridges(graph));
 
@@ -54,15 +47,15 @@ describe('graphBridges', () => {
     expect(bridges[0].getKey()).toBe(edgeCD.getKey());
   });
 
-  it('should find bridges in graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+  it("should find bridges in graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -95,15 +88,15 @@ describe('graphBridges', () => {
     expect(bridges[2].getKey()).toBe(edgeCD.getKey());
   });
 
-  it('should find bridges in graph starting with different root vertex', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+  it("should find bridges in graph starting with different root vertex", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -136,12 +129,12 @@ describe('graphBridges', () => {
     expect(bridges[2].getKey()).toBe(edgeCD.getKey());
   });
 
-  it('should find bridges in yet another graph #1', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
+  it("should find bridges in yet another graph #1", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
@@ -165,14 +158,14 @@ describe('graphBridges', () => {
     expect(bridges[1].getKey()).toBe(edgeCD.getKey());
   });
 
-  it('should find bridges in yet another graph #2', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+  it("should find bridges in yet another graph #2", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
@@ -201,3 +194,4 @@ describe('graphBridges', () => {
     expect(bridges[0].getKey()).toBe(edgeCD.getKey());
   });
 });
+
diff --git a/src/algorithms/graph/bridges/graphBridges.js b/src/algorithms/graph/bridges/graphBridges.js
index 58a6400..8c6f070 100644
--- a/src/algorithms/graph/bridges/graphBridges.js
+++ b/src/algorithms/graph/bridges/graphBridges.js
@@ -1,10 +1,12 @@
-import depthFirstSearch from '../depth-first-search/depthFirstSearch';
+import depthFirstSearch from "../depth-first-search/depthFirstSearch";
 
 /**
  * Helper class for visited vertex metadata.
  */
 class VisitMetadata {
-  constructor({ discoveryTime, lowDiscoveryTime }) {
+  constructor(_ref) {
+    let discoveryTime = _ref.discoveryTime,
+      lowDiscoveryTime = _ref.lowDiscoveryTime;
     this.discoveryTime = discoveryTime;
     this.lowDiscoveryTime = lowDiscoveryTime;
   }
@@ -31,7 +33,8 @@ export default function graphBridges(graph) {
     /**
      * @param {GraphVertex} currentVertex
      */
-    enterVertex: ({ currentVertex }) => {
+    enterVertex: (_ref2) => {
+      let currentVertex = _ref2.currentVertex;
       // Tick discovery time.
       discoveryTime += 1;
 
@@ -45,45 +48,58 @@ export default function graphBridges(graph) {
      * @param {GraphVertex} currentVertex
      * @param {GraphVertex} previousVertex
      */
-    leaveVertex: ({ currentVertex, previousVertex }) => {
+    leaveVertex: (_ref3) => {
+      let currentVertex = _ref3.currentVertex,
+        previousVertex = _ref3.previousVertex;
       if (previousVertex === null) {
         // Don't do anything for the root vertex if it is already current (not previous one).
         return;
       }
 
       // Check if current node is connected to any early node other then previous one.
-      visitedSet[currentVertex.getKey()].lowDiscoveryTime = currentVertex.getNeighbors()
-        .filter((earlyNeighbor) => earlyNeighbor.getKey() !== previousVertex.getKey())
+      visitedSet[currentVertex.getKey()].lowDiscoveryTime = currentVertex
+        .getNeighbors()
+        .filter(
+          (earlyNeighbor) => earlyNeighbor.getKey() !== previousVertex.getKey()
+        )
         .reduce(
           /**
            * @param {number} lowestDiscoveryTime
            * @param {GraphVertex} neighbor
            */
           (lowestDiscoveryTime, neighbor) => {
-            const neighborLowTime = visitedSet[neighbor.getKey()].lowDiscoveryTime;
-            return neighborLowTime < lowestDiscoveryTime ? neighborLowTime : lowestDiscoveryTime;
+            const neighborLowTime =
+              visitedSet[neighbor.getKey()].lowDiscoveryTime;
+            return neighborLowTime < lowestDiscoveryTime
+              ? neighborLowTime
+              : lowestDiscoveryTime;
           },
-          visitedSet[currentVertex.getKey()].lowDiscoveryTime,
+          visitedSet[currentVertex.getKey()].lowDiscoveryTime
         );
 
       // Compare low discovery times. In case if current low discovery time is less than the one
       // in previous vertex then update previous vertex low time.
-      const currentLowDiscoveryTime = visitedSet[currentVertex.getKey()].lowDiscoveryTime;
-      const previousLowDiscoveryTime = visitedSet[previousVertex.getKey()].lowDiscoveryTime;
+      const currentLowDiscoveryTime =
+        visitedSet[currentVertex.getKey()].lowDiscoveryTime;
+      const previousLowDiscoveryTime =
+        visitedSet[previousVertex.getKey()].lowDiscoveryTime;
       if (currentLowDiscoveryTime < previousLowDiscoveryTime) {
-        visitedSet[previousVertex.getKey()].lowDiscoveryTime = currentLowDiscoveryTime;
+        visitedSet[previousVertex.getKey()].lowDiscoveryTime =
+          currentLowDiscoveryTime;
       }
 
       // Compare current vertex low discovery time with parent discovery time. Check if there
       // are any short path (back edge) exists. If we can't get to current vertex other then
       // via parent then the parent vertex is articulation point for current one.
-      const parentDiscoveryTime = visitedSet[previousVertex.getKey()].discoveryTime;
+      const parentDiscoveryTime =
+        visitedSet[previousVertex.getKey()].discoveryTime;
       if (parentDiscoveryTime < currentLowDiscoveryTime) {
         const bridge = graph.findEdge(previousVertex, currentVertex);
         bridges[bridge.getKey()] = bridge;
       }
     },
-    allowTraversal: ({ nextVertex }) => {
+    allowTraversal: (_ref4) => {
+      let nextVertex = _ref4.nextVertex;
       return !visitedSet[nextVertex.getKey()];
     },
   };
@@ -93,3 +109,4 @@ export default function graphBridges(graph) {
 
   return bridges;
 }
+
diff --git a/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js b/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js
index 93ed610..f53071c 100644
--- a/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js
+++ b/src/algorithms/graph/depth-first-search/__test__/depthFirstSearch.test.js
@@ -1,19 +1,19 @@
-import Graph from '../../../../data-structures/graph/Graph';
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import depthFirstSearch from '../depthFirstSearch';
+import Graph from "../../../../data-structures/graph/Graph";
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import depthFirstSearch from "../depthFirstSearch";
 
-describe('depthFirstSearch', () => {
-  it('should perform DFS operation on graph', () => {
+describe("depthFirstSearch", () => {
+  it("should perform DFS operation on graph", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -34,7 +34,7 @@ describe('depthFirstSearch', () => {
       .addEdge(edgeFD)
       .addEdge(edgeDG);
 
-    expect(graph.toString()).toBe('A,B,C,G,D,E,F');
+    expect(graph.toString()).toBe("A,B,C,G,D,E,F");
 
     const enterVertexCallback = jest.fn();
     const leaveVertexCallback = jest.fn();
@@ -48,8 +48,12 @@ describe('depthFirstSearch', () => {
       leaveVertex: leaveVertexCallback,
     });
 
-    expect(enterVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
-    expect(leaveVertexCallback).toHaveBeenCalledTimes(graph.getAllVertices().length);
+    expect(enterVertexCallback).toHaveBeenCalledTimes(
+      graph.getAllVertices().length
+    );
+    expect(leaveVertexCallback).toHaveBeenCalledTimes(
+      graph.getAllVertices().length
+    );
 
     const enterVertexParamsMap = [
       { currentVertex: vertexA, previousVertex: null },
@@ -61,10 +65,18 @@ describe('depthFirstSearch', () => {
       { currentVertex: vertexF, previousVertex: vertexE },
     ];
 
-    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
+    for (
+      let callIndex = 0;
+      callIndex < graph.getAllVertices().length;
+      callIndex += 1
+    ) {
       const params = enterVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        enterVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        enterVertexParamsMap[callIndex].previousVertex
+      );
     }
 
     const leaveVertexParamsMap = [
@@ -77,23 +89,31 @@ describe('depthFirstSearch', () => {
       { currentVertex: vertexA, previousVertex: null },
     ];
 
-    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
+    for (
+      let callIndex = 0;
+      callIndex < graph.getAllVertices().length;
+      callIndex += 1
+    ) {
       const params = leaveVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        leaveVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        leaveVertexParamsMap[callIndex].previousVertex
+      );
     }
   });
 
-  it('allow users to redefine vertex visiting logic', () => {
+  it("allow users to redefine vertex visiting logic", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -114,7 +134,7 @@ describe('depthFirstSearch', () => {
       .addEdge(edgeFD)
       .addEdge(edgeDG);
 
-    expect(graph.toString()).toBe('A,B,C,G,D,E,F');
+    expect(graph.toString()).toBe("A,B,C,G,D,E,F");
 
     const enterVertexCallback = jest.fn();
     const leaveVertexCallback = jest.fn();
@@ -122,7 +142,9 @@ describe('depthFirstSearch', () => {
     depthFirstSearch(graph, vertexA, {
       enterVertex: enterVertexCallback,
       leaveVertex: leaveVertexCallback,
-      allowTraversal: ({ currentVertex, nextVertex }) => {
+      allowTraversal: (_ref) => {
+        let currentVertex = _ref.currentVertex,
+          nextVertex = _ref.nextVertex;
         return !(currentVertex === vertexA && nextVertex === vertexB);
       },
     });
@@ -140,10 +162,18 @@ describe('depthFirstSearch', () => {
       { currentVertex: vertexG, previousVertex: vertexD },
     ];
 
-    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
+    for (
+      let callIndex = 0;
+      callIndex < graph.getAllVertices().length;
+      callIndex += 1
+    ) {
       const params = enterVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        enterVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        enterVertexParamsMap[callIndex].previousVertex
+      );
     }
 
     const leaveVertexParamsMap = [
@@ -156,10 +186,19 @@ describe('depthFirstSearch', () => {
       { currentVertex: vertexA, previousVertex: null },
     ];
 
-    for (let callIndex = 0; callIndex < graph.getAllVertices().length; callIndex += 1) {
+    for (
+      let callIndex = 0;
+      callIndex < graph.getAllVertices().length;
+      callIndex += 1
+    ) {
       const params = leaveVertexCallback.mock.calls[callIndex][0];
-      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);
-      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);
+      expect(params.currentVertex).toEqual(
+        leaveVertexParamsMap[callIndex].currentVertex
+      );
+      expect(params.previousVertex).toEqual(
+        leaveVertexParamsMap[callIndex].previousVertex
+      );
     }
   });
 });
+
diff --git a/src/algorithms/graph/depth-first-search/depthFirstSearch.js b/src/algorithms/graph/depth-first-search/depthFirstSearch.js
index a77c672..0a9f2c6 100644
--- a/src/algorithms/graph/depth-first-search/depthFirstSearch.js
+++ b/src/algorithms/graph/depth-first-search/depthFirstSearch.js
@@ -14,25 +14,27 @@
  * @param {Callbacks} [callbacks]
  * @returns {Callbacks}
  */
-function initCallbacks(callbacks = {}) {
+function initCallbacks() {
+  let callbacks =
+    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
   const initiatedCallback = callbacks;
 
   const stubCallback = () => {};
 
-  const allowTraversalCallback = (
-    () => {
-      const seen = {};
-      return ({ nextVertex }) => {
-        if (!seen[nextVertex.getKey()]) {
-          seen[nextVertex.getKey()] = true;
-          return true;
-        }
-        return false;
-      };
-    }
-  )();
+  const allowTraversalCallback = (() => {
+    const seen = {};
+    return (_ref) => {
+      let nextVertex = _ref.nextVertex;
+      if (!seen[nextVertex.getKey()]) {
+        seen[nextVertex.getKey()] = true;
+        return true;
+      }
+      return false;
+    };
+  })();
 
-  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
+  initiatedCallback.allowTraversal =
+    callbacks.allowTraversal || allowTraversalCallback;
   initiatedCallback.enterVertex = callbacks.enterVertex || stubCallback;
   initiatedCallback.leaveVertex = callbacks.leaveVertex || stubCallback;
 
@@ -45,11 +47,18 @@ function initCallbacks(callbacks = {}) {
  * @param {GraphVertex} previousVertex
  * @param {Callbacks} callbacks
  */
-function depthFirstSearchRecursive(graph, currentVertex, previousVertex, callbacks) {
+function depthFirstSearchRecursive(
+  graph,
+  currentVertex,
+  previousVertex,
+  callbacks
+) {
   callbacks.enterVertex({ currentVertex, previousVertex });
 
   graph.getNeighbors(currentVertex).forEach((nextVertex) => {
-    if (callbacks.allowTraversal({ previousVertex, currentVertex, nextVertex })) {
+    if (
+      callbacks.allowTraversal({ previousVertex, currentVertex, nextVertex })
+    ) {
       depthFirstSearchRecursive(graph, nextVertex, currentVertex, callbacks);
     }
   });
@@ -64,5 +73,11 @@ function depthFirstSearchRecursive(graph, currentVertex, previousVertex, callbac
  */
 export default function depthFirstSearch(graph, startVertex, callbacks) {
   const previousVertex = null;
-  depthFirstSearchRecursive(graph, startVertex, previousVertex, initCallbacks(callbacks));
+  depthFirstSearchRecursive(
+    graph,
+    startVertex,
+    previousVertex,
+    initCallbacks(callbacks)
+  );
 }
+
diff --git a/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js b/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js
index 64a4149..ff2d988 100644
--- a/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js
+++ b/src/algorithms/graph/detect-cycle/__test__/detectDirectedCycle.test.js
@@ -1,16 +1,16 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import detectDirectedCycle from '../detectDirectedCycle';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import detectDirectedCycle from "../detectDirectedCycle";
 
-describe('detectDirectedCycle', () => {
-  it('should detect directed cycle', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
+describe("detectDirectedCycle", () => {
+  it("should detect directed cycle", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -40,3 +40,4 @@ describe('detectDirectedCycle', () => {
     });
   });
 });
+
diff --git a/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js b/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js
index c3f9903..b33700d 100644
--- a/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js
+++ b/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycle.test.js
@@ -1,16 +1,16 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import detectUndirectedCycle from '../detectUndirectedCycle';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import detectUndirectedCycle from "../detectUndirectedCycle";
 
-describe('detectUndirectedCycle', () => {
-  it('should detect undirected cycle', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
+describe("detectUndirectedCycle", () => {
+  it("should detect undirected cycle", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
 
     const edgeAF = new GraphEdge(vertexA, vertexF);
     const edgeAB = new GraphEdge(vertexA, vertexB);
@@ -39,3 +39,4 @@ describe('detectUndirectedCycle', () => {
     });
   });
 });
+
diff --git a/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js b/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js
index 15cb153..fddec17 100644
--- a/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js
+++ b/src/algorithms/graph/detect-cycle/__test__/detectUndirectedCycleUsingDisjointSet.test.js
@@ -1,16 +1,16 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import detectUndirectedCycleUsingDisjointSet from '../detectUndirectedCycleUsingDisjointSet';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import detectUndirectedCycleUsingDisjointSet from "../detectUndirectedCycleUsingDisjointSet";
 
-describe('detectUndirectedCycleUsingDisjointSet', () => {
-  it('should detect undirected cycle', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
+describe("detectUndirectedCycleUsingDisjointSet", () => {
+  it("should detect undirected cycle", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
 
     const edgeAF = new GraphEdge(vertexA, vertexF);
     const edgeAB = new GraphEdge(vertexA, vertexB);
@@ -34,3 +34,4 @@ describe('detectUndirectedCycleUsingDisjointSet', () => {
     expect(detectUndirectedCycleUsingDisjointSet(graph)).toBe(true);
   });
 });
+
diff --git a/src/algorithms/graph/detect-cycle/detectDirectedCycle.js b/src/algorithms/graph/detect-cycle/detectDirectedCycle.js
index 73b2b22..b56f49a 100644
--- a/src/algorithms/graph/detect-cycle/detectDirectedCycle.js
+++ b/src/algorithms/graph/detect-cycle/detectDirectedCycle.js
@@ -1,4 +1,4 @@
-import depthFirstSearch from '../depth-first-search/depthFirstSearch';
+import depthFirstSearch from "../depth-first-search/depthFirstSearch";
 
 /**
  * Detect cycle in directed graph using Depth First Search.
@@ -35,7 +35,9 @@ export default function detectDirectedCycle(graph) {
 
   // Describe BFS callbacks.
   const callbacks = {
-    enterVertex: ({ currentVertex, previousVertex }) => {
+    enterVertex: (_ref) => {
+      let currentVertex = _ref.currentVertex,
+        previousVertex = _ref.previousVertex;
       if (graySet[currentVertex.getKey()]) {
         // If current vertex already in grey set it means that cycle is detected.
         // Let's detect cycle path.
@@ -60,13 +62,15 @@ export default function detectDirectedCycle(graph) {
         dfsParentMap[currentVertex.getKey()] = previousVertex;
       }
     },
-    leaveVertex: ({ currentVertex }) => {
+    leaveVertex: (_ref2) => {
+      let currentVertex = _ref2.currentVertex;
       // If all node's children has been visited let's remove it from gray set
       // and move it to the black set meaning that all its neighbors are visited.
       blackSet[currentVertex.getKey()] = currentVertex;
       delete graySet[currentVertex.getKey()];
     },
-    allowTraversal: ({ nextVertex }) => {
+    allowTraversal: (_ref3) => {
+      let nextVertex = _ref3.nextVertex;
       // If cycle was detected we must forbid all further traversing since it will
       // cause infinite traversal loop.
       if (cycle) {
@@ -91,3 +95,4 @@ export default function detectDirectedCycle(graph) {
 
   return cycle;
 }
+
diff --git a/src/algorithms/graph/detect-cycle/detectUndirectedCycle.js b/src/algorithms/graph/detect-cycle/detectUndirectedCycle.js
index 5bcc9bb..34d2eda 100644
--- a/src/algorithms/graph/detect-cycle/detectUndirectedCycle.js
+++ b/src/algorithms/graph/detect-cycle/detectUndirectedCycle.js
@@ -1,4 +1,4 @@
-import depthFirstSearch from '../depth-first-search/depthFirstSearch';
+import depthFirstSearch from "../depth-first-search/depthFirstSearch";
 
 /**
  * Detect cycle in undirected graph using Depth First Search.
@@ -16,7 +16,9 @@ export default function detectUndirectedCycle(graph) {
 
   // Callbacks for DFS traversing.
   const callbacks = {
-    allowTraversal: ({ currentVertex, nextVertex }) => {
+    allowTraversal: (_ref) => {
+      let currentVertex = _ref.currentVertex,
+        nextVertex = _ref.nextVertex;
       // Don't allow further traversal in case if cycle has been detected.
       if (cycle) {
         return false;
@@ -24,11 +26,15 @@ export default function detectUndirectedCycle(graph) {
 
       // Don't allow traversal from child back to its parent.
       const currentVertexParent = parents[currentVertex.getKey()];
-      const currentVertexParentKey = currentVertexParent ? currentVertexParent.getKey() : null;
+      const currentVertexParentKey = currentVertexParent
+        ? currentVertexParent.getKey()
+        : null;
 
       return currentVertexParentKey !== nextVertex.getKey();
     },
-    enterVertex: ({ currentVertex, previousVertex }) => {
+    enterVertex: (_ref2) => {
+      let currentVertex = _ref2.currentVertex,
+        previousVertex = _ref2.previousVertex;
       if (visitedVertices[currentVertex.getKey()]) {
         // Compile cycle path based on parents of previous vertices.
         cycle = {};
@@ -57,3 +63,4 @@ export default function detectUndirectedCycle(graph) {
 
   return cycle;
 }
+
diff --git a/src/algorithms/graph/detect-cycle/detectUndirectedCycleUsingDisjointSet.js b/src/algorithms/graph/detect-cycle/detectUndirectedCycleUsingDisjointSet.js
index 7dec9c2..5b5f48b 100644
--- a/src/algorithms/graph/detect-cycle/detectUndirectedCycleUsingDisjointSet.js
+++ b/src/algorithms/graph/detect-cycle/detectUndirectedCycleUsingDisjointSet.js
@@ -1,4 +1,4 @@
-import DisjointSet from '../../../data-structures/disjoint-set/DisjointSet';
+import DisjointSet from "../../../data-structures/disjoint-set/DisjointSet";
 
 /**
  * Detect cycle in undirected graph using disjoint sets.
@@ -10,7 +10,9 @@ export default function detectUndirectedCycleUsingDisjointSet(graph) {
   /** @param {GraphVertex} graphVertex */
   const keyExtractor = (graphVertex) => graphVertex.getKey();
   const disjointSet = new DisjointSet(keyExtractor);
-  graph.getAllVertices().forEach((graphVertex) => disjointSet.makeSet(graphVertex));
+  graph
+    .getAllVertices()
+    .forEach((graphVertex) => disjointSet.makeSet(graphVertex));
 
   // Go trough all graph edges one by one and check if edge vertices are from the
   // different sets. In this case joint those sets together. Do this until you find
@@ -29,3 +31,4 @@ export default function detectUndirectedCycleUsingDisjointSet(graph) {
 
   return cycleFound;
 }
+
diff --git a/src/algorithms/graph/dijkstra/__test__/dijkstra.test.js b/src/algorithms/graph/dijkstra/__test__/dijkstra.test.js
index f6c5a26..7de1f6e 100644
--- a/src/algorithms/graph/dijkstra/__test__/dijkstra.test.js
+++ b/src/algorithms/graph/dijkstra/__test__/dijkstra.test.js
@@ -1,18 +1,18 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import dijkstra from '../dijkstra';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import dijkstra from "../dijkstra";
 
-describe('dijkstra', () => {
-  it('should find minimum paths to all vertices for undirected graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+describe("dijkstra", () => {
+  it("should find minimum paths to all vertices for undirected graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 4);
     const edgeAE = new GraphEdge(vertexA, vertexE, 7);
@@ -43,7 +43,9 @@ describe('dijkstra', () => {
       .addEdge(edgeFG)
       .addEdge(edgeEG);
 
-    const { distances, previousVertices } = dijkstra(graph, vertexA);
+    const _dijkstra = dijkstra(graph, vertexA),
+      distances = _dijkstra.distances,
+      previousVertices = _dijkstra.previousVertices;
 
     expect(distances).toEqual({
       H: Infinity,
@@ -56,23 +58,23 @@ describe('dijkstra', () => {
       F: 11,
     });
 
-    expect(previousVertices.F.getKey()).toBe('D');
-    expect(previousVertices.D.getKey()).toBe('B');
-    expect(previousVertices.B.getKey()).toBe('A');
-    expect(previousVertices.G.getKey()).toBe('E');
-    expect(previousVertices.C.getKey()).toBe('A');
+    expect(previousVertices.F.getKey()).toBe("D");
+    expect(previousVertices.D.getKey()).toBe("B");
+    expect(previousVertices.B.getKey()).toBe("A");
+    expect(previousVertices.G.getKey()).toBe("E");
+    expect(previousVertices.C.getKey()).toBe("A");
     expect(previousVertices.A).toBeNull();
     expect(previousVertices.H).toBeNull();
   });
 
-  it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
-    const vertexS = new GraphVertex('S');
-    const vertexE = new GraphVertex('E');
-    const vertexA = new GraphVertex('A');
-    const vertexD = new GraphVertex('D');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexH = new GraphVertex('H');
+  it("should find minimum paths to all vertices for directed graph with negative edge weights", () => {
+    const vertexS = new GraphVertex("S");
+    const vertexE = new GraphVertex("E");
+    const vertexA = new GraphVertex("A");
+    const vertexD = new GraphVertex("D");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexH = new GraphVertex("H");
 
     const edgeSE = new GraphEdge(vertexS, vertexE, 8);
     const edgeSA = new GraphEdge(vertexS, vertexA, 10);
@@ -95,7 +97,9 @@ describe('dijkstra', () => {
       .addEdge(edgeCB)
       .addEdge(edgeBA);
 
-    const { distances, previousVertices } = dijkstra(graph, vertexS);
+    const _dijkstra2 = dijkstra(graph, vertexS),
+      distances = _dijkstra2.distances,
+      previousVertices = _dijkstra2.previousVertices;
 
     expect(distances).toEqual({
       H: Infinity,
@@ -109,9 +113,10 @@ describe('dijkstra', () => {
 
     expect(previousVertices.H).toBeNull();
     expect(previousVertices.S).toBeNull();
-    expect(previousVertices.B.getKey()).toBe('C');
-    expect(previousVertices.C.getKey()).toBe('A');
-    expect(previousVertices.A.getKey()).toBe('D');
-    expect(previousVertices.D.getKey()).toBe('E');
+    expect(previousVertices.B.getKey()).toBe("C");
+    expect(previousVertices.C.getKey()).toBe("A");
+    expect(previousVertices.A.getKey()).toBe("D");
+    expect(previousVertices.D.getKey()).toBe("E");
   });
 });
+
diff --git a/src/algorithms/graph/dijkstra/dijkstra.js b/src/algorithms/graph/dijkstra/dijkstra.js
index c5b47b0..c394c29 100644
--- a/src/algorithms/graph/dijkstra/dijkstra.js
+++ b/src/algorithms/graph/dijkstra/dijkstra.js
@@ -1,4 +1,4 @@
-import PriorityQueue from '../../../data-structures/priority-queue/PriorityQueue';
+import PriorityQueue from "../../../data-structures/priority-queue/PriorityQueue";
 
 /**
  * @typedef {Object} ShortestPaths
@@ -45,7 +45,8 @@ export default function dijkstra(graph, startVertex) {
         const edge = graph.findEdge(currentVertex, neighbor);
 
         const existingDistanceToNeighbor = distances[neighbor.getKey()];
-        const distanceToNeighborFromCurrent = distances[currentVertex.getKey()] + edge.weight;
+        const distanceToNeighborFromCurrent =
+          distances[currentVertex.getKey()] + edge.weight;
 
         // If we've found shorter path to the neighbor - update it.
         if (distanceToNeighborFromCurrent < existingDistanceToNeighbor) {
@@ -78,3 +79,4 @@ export default function dijkstra(graph, startVertex) {
     previousVertices,
   };
 }
+
diff --git a/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js b/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js
index d10d980..e4d0569 100644
--- a/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js
+++ b/src/algorithms/graph/eulerian-path/__test__/eulerianPath.test.js
@@ -1,16 +1,16 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import eulerianPath from '../eulerianPath';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import eulerianPath from "../eulerianPath";
 
-describe('eulerianPath', () => {
-  it('should throw an error when graph is not Eulerian', () => {
+describe("eulerianPath", () => {
+  it("should throw an error when graph is not Eulerian", () => {
     function findEulerianPathInNotEulerianGraph() {
-      const vertexA = new GraphVertex('A');
-      const vertexB = new GraphVertex('B');
-      const vertexC = new GraphVertex('C');
-      const vertexD = new GraphVertex('D');
-      const vertexE = new GraphVertex('E');
+      const vertexA = new GraphVertex("A");
+      const vertexB = new GraphVertex("B");
+      const vertexC = new GraphVertex("C");
+      const vertexD = new GraphVertex("D");
+      const vertexE = new GraphVertex("E");
 
       const edgeAB = new GraphEdge(vertexA, vertexB);
       const edgeAC = new GraphEdge(vertexA, vertexC);
@@ -33,14 +33,14 @@ describe('eulerianPath', () => {
     expect(findEulerianPathInNotEulerianGraph).toThrowError();
   });
 
-  it('should find Eulerian Circuit in graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+  it("should find Eulerian Circuit in graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAE = new GraphEdge(vertexA, vertexE);
@@ -86,15 +86,15 @@ describe('eulerianPath', () => {
     expect(eulerianPathSet[10].getKey()).toBe(vertexA.getKey());
   });
 
-  it('should find Eulerian Path in graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+  it("should find Eulerian Path in graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
@@ -137,3 +137,4 @@ describe('eulerianPath', () => {
     expect(eulerianPathSet[9].getKey()).toBe(vertexF.getKey());
   });
 });
+
diff --git a/src/algorithms/graph/eulerian-path/eulerianPath.js b/src/algorithms/graph/eulerian-path/eulerianPath.js
index c82c6fd..8155360 100644
--- a/src/algorithms/graph/eulerian-path/eulerianPath.js
+++ b/src/algorithms/graph/eulerian-path/eulerianPath.js
@@ -1,4 +1,62 @@
-import graphBridges from '../bridges/graphBridges';
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+import graphBridges from "../bridges/graphBridges";
 
 /**
  * Fleury's algorithm of finding Eulerian Path (visit all graph edges exactly once).
@@ -38,7 +96,7 @@ export default function eulerianPath(graph) {
   const isCircuit = !Object.values(oddRankVertices).length;
 
   if (!isCircuit && Object.values(oddRankVertices).length !== 2) {
-    throw new Error('Eulerian path must contain two odd-ranked vertices');
+    throw new Error("Eulerian path must contain two odd-ranked vertices");
   }
 
   // Pick start vertex for traversal.
@@ -72,10 +130,15 @@ export default function eulerianPath(graph) {
     let edgeToDelete = null;
     if (currentEdges.length === 1) {
       // If there is only one edge left we need to peek it.
-      [edgeToDelete] = currentEdges;
+      var _currentEdges = _slicedToArray(currentEdges, 1);
+      edgeToDelete = _currentEdges[0];
     } else {
       // If there are many edges left then we need to peek any of those except bridges.
-      [edgeToDelete] = currentEdges.filter((edge) => !bridges[edge.getKey()]);
+      var _currentEdges$filter = currentEdges.filter(
+        (edge) => !bridges[edge.getKey()]
+      );
+      var _currentEdges$filter2 = _slicedToArray(_currentEdges$filter, 1);
+      edgeToDelete = _currentEdges$filter2[0];
     }
 
     // Detect next current vertex.
@@ -99,3 +162,4 @@ export default function eulerianPath(graph) {
 
   return eulerianPathVertices;
 }
+
diff --git a/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js b/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js
index dea170c..234b831 100644
--- a/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js
+++ b/src/algorithms/graph/floyd-warshall/__test__/floydWarshall.test.js
@@ -1,18 +1,18 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import floydWarshall from '../floydWarshall';
-
-describe('floydWarshall', () => {
-  it('should find minimum paths to all vertices for undirected graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import floydWarshall from "../floydWarshall";
+
+describe("floydWarshall", () => {
+  it("should find minimum paths to all vertices for undirected graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 4);
     const edgeAE = new GraphEdge(vertexA, vertexE, 7);
@@ -55,7 +55,9 @@ describe('floydWarshall', () => {
       .addEdge(edgeFG)
       .addEdge(edgeEG);
 
-    const { distances, nextVertices } = floydWarshall(graph);
+    const _floydWarshall = floydWarshall(graph),
+      distances = _floydWarshall.distances,
+      nextVertices = _floydWarshall.nextVertices;
 
     const vertices = graph.getAllVertices();
 
@@ -86,11 +88,11 @@ describe('floydWarshall', () => {
     expect(nextVertices[vertexAIndex][vertexHIndex]).toBe(null);
   });
 
-  it('should find minimum paths to all vertices for directed graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should find minimum paths to all vertices for directed graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 3);
     const edgeBA = new GraphEdge(vertexB, vertexA, 8);
@@ -119,7 +121,9 @@ describe('floydWarshall', () => {
       .addEdge(edgeCA)
       .addEdge(edgeCD);
 
-    const { distances, nextVertices } = floydWarshall(graph);
+    const _floydWarshall2 = floydWarshall(graph),
+      distances = _floydWarshall2.distances,
+      nextVertices = _floydWarshall2.nextVertices;
 
     const vertices = graph.getAllVertices();
 
@@ -147,14 +151,14 @@ describe('floydWarshall', () => {
     expect(nextVertices[vertexAIndex][vertexBIndex]).toBe(vertexA);
   });
 
-  it('should find minimum paths to all vertices for directed graph with negative edge weights', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+  it("should find minimum paths to all vertices for directed graph with negative edge weights", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeFE = new GraphEdge(vertexF, vertexE, 8);
     const edgeFA = new GraphEdge(vertexF, vertexA, 10);
@@ -188,7 +192,9 @@ describe('floydWarshall', () => {
       .addEdge(edgeCB)
       .addEdge(edgeBA);
 
-    const { distances, nextVertices } = floydWarshall(graph);
+    const _floydWarshall3 = floydWarshall(graph),
+      distances = _floydWarshall3.distances,
+      nextVertices = _floydWarshall3.nextVertices;
 
     const vertices = graph.getAllVertices();
 
@@ -218,3 +224,4 @@ describe('floydWarshall', () => {
     expect(nextVertices[vertexCIndex][vertexBIndex]).toBe(vertexC);
   });
 });
+
diff --git a/src/algorithms/graph/floyd-warshall/floydWarshall.js b/src/algorithms/graph/floyd-warshall/floydWarshall.js
index 870d78a..eebbd24 100644
--- a/src/algorithms/graph/floyd-warshall/floydWarshall.js
+++ b/src/algorithms/graph/floyd-warshall/floydWarshall.js
@@ -8,15 +8,19 @@ export default function floydWarshall(graph) {
 
   // Init previous vertices matrix with nulls meaning that there are no
   // previous vertices exist that will give us shortest path.
-  const nextVertices = Array(vertices.length).fill(null).map(() => {
-    return Array(vertices.length).fill(null);
-  });
+  const nextVertices = Array(vertices.length)
+    .fill(null)
+    .map(() => {
+      return Array(vertices.length).fill(null);
+    });
 
   // Init distances matrix with Infinities meaning there are no paths
   // between vertices exist so far.
-  const distances = Array(vertices.length).fill(null).map(() => {
-    return Array(vertices.length).fill(Infinity);
-  });
+  const distances = Array(vertices.length)
+    .fill(null)
+    .map(() => {
+      return Array(vertices.length).fill(Infinity);
+    });
 
   // Init distance matrix with the distance we already now (from existing edges).
   // And also init previous vertices from the edges.
@@ -55,7 +59,8 @@ export default function floydWarshall(graph) {
         // from startVertex to endVertex but via middleVertex.
         // Save the shortest distance and previous vertex that allows
         // us to have this shortest distance.
-        const distViaMiddle = distances[startIndex][middleIndex] + distances[middleIndex][endIndex];
+        const distViaMiddle =
+          distances[startIndex][middleIndex] + distances[middleIndex][endIndex];
 
         if (distances[startIndex][endIndex] > distViaMiddle) {
           // We've found a shortest pass via middle vertex.
@@ -70,3 +75,4 @@ export default function floydWarshall(graph) {
   // Next vertex after x one in path from x to y: nextVertices[x][y].
   return { distances, nextVertices };
 }
+
diff --git a/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js b/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js
index eab0d33..997e86f 100644
--- a/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js
+++ b/src/algorithms/graph/hamiltonian-cycle/__test__/hamiltonianCycle.test.js
@@ -1,15 +1,15 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import hamiltonianCycle from '../hamiltonianCycle';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import hamiltonianCycle from "../hamiltonianCycle";
 
-describe('hamiltonianCycle', () => {
-  it('should find hamiltonian paths in graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
+describe("hamiltonianCycle", () => {
+  it("should find hamiltonian paths in graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAE = new GraphEdge(vertexA, vertexE);
@@ -60,12 +60,12 @@ describe('hamiltonianCycle', () => {
     expect(hamiltonianCycleSet[3][4].getKey()).toBe(vertexC.getKey());
   });
 
-  it('should return false for graph without Hamiltonian path', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
+  it("should return false for graph without Hamiltonian path", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAE = new GraphEdge(vertexA, vertexE);
@@ -88,3 +88,4 @@ describe('hamiltonianCycle', () => {
     expect(hamiltonianCycleSet.length).toBe(0);
   });
 });
+
diff --git a/src/algorithms/graph/hamiltonian-cycle/hamiltonianCycle.js b/src/algorithms/graph/hamiltonian-cycle/hamiltonianCycle.js
index 2a33bf7..83ec883 100644
--- a/src/algorithms/graph/hamiltonian-cycle/hamiltonianCycle.js
+++ b/src/algorithms/graph/hamiltonian-cycle/hamiltonianCycle.js
@@ -1,4 +1,4 @@
-import GraphVertex from '../../../data-structures/graph/GraphVertex';
+import GraphVertex from "../../../data-structures/graph/GraphVertex";
 
 /**
  * @param {number[][]} adjacencyMatrix
@@ -11,16 +11,22 @@ function isSafe(adjacencyMatrix, verticesIndices, cycle, vertexCandidate) {
   const endVertex = cycle[cycle.length - 1];
 
   // Get end and candidate vertices indices in adjacency matrix.
-  const candidateVertexAdjacencyIndex = verticesIndices[vertexCandidate.getKey()];
+  const candidateVertexAdjacencyIndex =
+    verticesIndices[vertexCandidate.getKey()];
   const endVertexAdjacencyIndex = verticesIndices[endVertex.getKey()];
 
   // Check if last vertex in the path and candidate vertex are adjacent.
-  if (adjacencyMatrix[endVertexAdjacencyIndex][candidateVertexAdjacencyIndex] === Infinity) {
+  if (
+    adjacencyMatrix[endVertexAdjacencyIndex][candidateVertexAdjacencyIndex] ===
+    Infinity
+  ) {
     return false;
   }
 
   // Check if vertexCandidate is being added to the path for the first time.
-  const candidateDuplicate = cycle.find((vertex) => vertex.getKey() === vertexCandidate.getKey());
+  const candidateDuplicate = cycle.find(
+    (vertex) => vertex.getKey() === vertexCandidate.getKey()
+  );
 
   return !candidateDuplicate;
 }
@@ -43,7 +49,10 @@ function isCycle(adjacencyMatrix, verticesIndices, cycle) {
   const endVertexAdjacencyIndex = verticesIndices[endVertex.getKey()];
 
   // Check if we can go from end vertex to the start one.
-  return adjacencyMatrix[endVertexAdjacencyIndex][startVertexAdjacencyIndex] !== Infinity;
+  return (
+    adjacencyMatrix[endVertexAdjacencyIndex][startVertexAdjacencyIndex] !==
+    Infinity
+  );
 }
 
 /**
@@ -53,15 +62,16 @@ function isCycle(adjacencyMatrix, verticesIndices, cycle) {
  * @param {GraphVertex[][]} cycles
  * @param {GraphVertex[]} cycle
  */
-function hamiltonianCycleRecursive({
-  adjacencyMatrix,
-  vertices,
-  verticesIndices,
-  cycles,
-  cycle,
-}) {
+function hamiltonianCycleRecursive(_ref) {
+  let adjacencyMatrix = _ref.adjacencyMatrix,
+    vertices = _ref.vertices,
+    verticesIndices = _ref.verticesIndices,
+    cycles = _ref.cycles,
+    cycle = _ref.cycle;
   // Clone cycle in order to prevent it from modification by other DFS branches.
-  const currentCycle = [...cycle].map((vertex) => new GraphVertex(vertex.value));
+  const currentCycle = [...cycle].map(
+    (vertex) => new GraphVertex(vertex.value)
+  );
 
   if (vertices.length === currentCycle.length) {
     // Hamiltonian path is found.
@@ -78,7 +88,9 @@ function hamiltonianCycleRecursive({
     const vertexCandidate = vertices[vertexIndex];
 
     // Check if it is safe to put vertex candidate to cycle.
-    if (isSafe(adjacencyMatrix, verticesIndices, currentCycle, vertexCandidate)) {
+    if (
+      isSafe(adjacencyMatrix, verticesIndices, currentCycle, vertexCandidate)
+    ) {
       // Add candidate vertex to cycle path.
       currentCycle.push(vertexCandidate);
 
@@ -132,3 +144,4 @@ export default function hamiltonianCycle(graph) {
   // Return found cycles.
   return cycles;
 }
+
diff --git a/src/algorithms/graph/kruskal/__test__/kruskal.test.js b/src/algorithms/graph/kruskal/__test__/kruskal.test.js
index da71d13..7e6aac6 100644
--- a/src/algorithms/graph/kruskal/__test__/kruskal.test.js
+++ b/src/algorithms/graph/kruskal/__test__/kruskal.test.js
@@ -1,10 +1,10 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import kruskal from '../kruskal';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import kruskal from "../kruskal";
 
-describe('kruskal', () => {
-  it('should fire an error for directed graph', () => {
+describe("kruskal", () => {
+  it("should fire an error for directed graph", () => {
     function applyPrimToDirectedGraph() {
       const graph = new Graph(true);
 
@@ -14,14 +14,14 @@ describe('kruskal', () => {
     expect(applyPrimToDirectedGraph).toThrowError();
   });
 
-  it('should find minimum spanning tree', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+  it("should find minimum spanning tree", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 2);
     const edgeAD = new GraphEdge(vertexA, vertexD, 3);
@@ -53,16 +53,20 @@ describe('kruskal', () => {
     const minimumSpanningTree = kruskal(graph);
 
     expect(minimumSpanningTree.getWeight()).toBe(24);
-    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
-    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
-    expect(minimumSpanningTree.toString()).toBe('E,C,A,B,D,F,G');
+    expect(minimumSpanningTree.getAllVertices().length).toBe(
+      graph.getAllVertices().length
+    );
+    expect(minimumSpanningTree.getAllEdges().length).toBe(
+      graph.getAllVertices().length - 1
+    );
+    expect(minimumSpanningTree.toString()).toBe("E,C,A,B,D,F,G");
   });
 
-  it('should find minimum spanning tree for simple graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should find minimum spanning tree for simple graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 1);
     const edgeAD = new GraphEdge(vertexA, vertexD, 3);
@@ -84,8 +88,13 @@ describe('kruskal', () => {
     const minimumSpanningTree = kruskal(graph);
 
     expect(minimumSpanningTree.getWeight()).toBe(3);
-    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
-    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
-    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
+    expect(minimumSpanningTree.getAllVertices().length).toBe(
+      graph.getAllVertices().length
+    );
+    expect(minimumSpanningTree.getAllEdges().length).toBe(
+      graph.getAllVertices().length - 1
+    );
+    expect(minimumSpanningTree.toString()).toBe("A,B,C,D");
   });
 });
+
diff --git a/src/algorithms/graph/kruskal/kruskal.js b/src/algorithms/graph/kruskal/kruskal.js
index 296616a..c674610 100644
--- a/src/algorithms/graph/kruskal/kruskal.js
+++ b/src/algorithms/graph/kruskal/kruskal.js
@@ -1,6 +1,6 @@
-import Graph from '../../../data-structures/graph/Graph';
-import QuickSort from '../../sorting/quick-sort/QuickSort';
-import DisjointSet from '../../../data-structures/disjoint-set/DisjointSet';
+import Graph from "../../../data-structures/graph/Graph";
+import QuickSort from "../../sorting/quick-sort/QuickSort";
+import DisjointSet from "../../../data-structures/disjoint-set/DisjointSet";
 
 /**
  * @param {Graph} graph
@@ -10,7 +10,7 @@ export default function kruskal(graph) {
   // It should fire error if graph is directed since the algorithm works only
   // for undirected graphs.
   if (graph.isDirected) {
-    throw new Error('Kruskal\'s algorithms works only for undirected graphs');
+    throw new Error("Kruskal's algorithms works only for undirected graphs");
   }
 
   // Init new graph that will contain minimum spanning tree of original graph.
@@ -30,6 +30,7 @@ export default function kruskal(graph) {
       return graphEdgeA.weight <= graphEdgeB.weight ? -1 : 1;
     },
   };
+
   const sortedEdges = new QuickSort(sortingCallbacks).sort(graph.getAllEdges());
 
   // Create disjoint sets for all graph vertices.
@@ -49,7 +50,9 @@ export default function kruskal(graph) {
     const currentEdge = sortedEdges[edgeIndex];
 
     // Check if edge forms the cycle. If it does then skip it.
-    if (!disjointSet.inSameSet(currentEdge.startVertex, currentEdge.endVertex)) {
+    if (
+      !disjointSet.inSameSet(currentEdge.startVertex, currentEdge.endVertex)
+    ) {
       // Unite two subsets into one.
       disjointSet.union(currentEdge.startVertex, currentEdge.endVertex);
 
@@ -60,3 +63,4 @@ export default function kruskal(graph) {
 
   return minimumSpanningTree;
 }
+
diff --git a/src/algorithms/graph/prim/__test__/prim.test.js b/src/algorithms/graph/prim/__test__/prim.test.js
index ac608df..e557c26 100644
--- a/src/algorithms/graph/prim/__test__/prim.test.js
+++ b/src/algorithms/graph/prim/__test__/prim.test.js
@@ -1,10 +1,10 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import prim from '../prim';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import prim from "../prim";
 
-describe('prim', () => {
-  it('should fire an error for directed graph', () => {
+describe("prim", () => {
+  it("should fire an error for directed graph", () => {
     function applyPrimToDirectedGraph() {
       const graph = new Graph(true);
 
@@ -14,14 +14,14 @@ describe('prim', () => {
     expect(applyPrimToDirectedGraph).toThrowError();
   });
 
-  it('should find minimum spanning tree', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
+  it("should find minimum spanning tree", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 2);
     const edgeAD = new GraphEdge(vertexA, vertexD, 3);
@@ -53,16 +53,20 @@ describe('prim', () => {
     const minimumSpanningTree = prim(graph);
 
     expect(minimumSpanningTree.getWeight()).toBe(24);
-    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
-    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
-    expect(minimumSpanningTree.toString()).toBe('A,B,C,E,D,F,G');
+    expect(minimumSpanningTree.getAllVertices().length).toBe(
+      graph.getAllVertices().length
+    );
+    expect(minimumSpanningTree.getAllEdges().length).toBe(
+      graph.getAllVertices().length - 1
+    );
+    expect(minimumSpanningTree.toString()).toBe("A,B,C,E,D,F,G");
   });
 
-  it('should find minimum spanning tree for simple graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should find minimum spanning tree for simple graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 1);
     const edgeAD = new GraphEdge(vertexA, vertexD, 3);
@@ -84,8 +88,13 @@ describe('prim', () => {
     const minimumSpanningTree = prim(graph);
 
     expect(minimumSpanningTree.getWeight()).toBe(3);
-    expect(minimumSpanningTree.getAllVertices().length).toBe(graph.getAllVertices().length);
-    expect(minimumSpanningTree.getAllEdges().length).toBe(graph.getAllVertices().length - 1);
-    expect(minimumSpanningTree.toString()).toBe('A,B,C,D');
+    expect(minimumSpanningTree.getAllVertices().length).toBe(
+      graph.getAllVertices().length
+    );
+    expect(minimumSpanningTree.getAllEdges().length).toBe(
+      graph.getAllVertices().length - 1
+    );
+    expect(minimumSpanningTree.toString()).toBe("A,B,C,D");
   });
 });
+
diff --git a/src/algorithms/graph/prim/prim.js b/src/algorithms/graph/prim/prim.js
index 03b7a0b..0b8e5e2 100644
--- a/src/algorithms/graph/prim/prim.js
+++ b/src/algorithms/graph/prim/prim.js
@@ -1,5 +1,5 @@
-import Graph from '../../../data-structures/graph/Graph';
-import PriorityQueue from '../../../data-structures/priority-queue/PriorityQueue';
+import Graph from "../../../data-structures/graph/Graph";
+import PriorityQueue from "../../../data-structures/priority-queue/PriorityQueue";
 
 /**
  * @param {Graph} graph
@@ -9,7 +9,7 @@ export default function prim(graph) {
   // It should fire error if graph is directed since the algorithm works only
   // for undirected graphs.
   if (graph.isDirected) {
-    throw new Error('Prim\'s algorithms works only for undirected graphs');
+    throw new Error("Prim's algorithms works only for undirected graphs");
   }
 
   // Init new graph that will contain minimum spanning tree of original graph.
@@ -60,8 +60,8 @@ export default function prim(graph) {
       nextMinVertex.getEdges().forEach((graphEdge) => {
         // Add only vertices that link to unvisited nodes.
         if (
-          !visitedVertices[graphEdge.startVertex.getKey()]
-          || !visitedVertices[graphEdge.endVertex.getKey()]
+          !visitedVertices[graphEdge.startVertex.getKey()] ||
+          !visitedVertices[graphEdge.endVertex.getKey()]
         ) {
           edgesQueue.add(graphEdge, graphEdge.weight);
         }
@@ -71,3 +71,4 @@ export default function prim(graph) {
 
   return minimumSpanningTree;
 }
+
diff --git a/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js b/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js
index 3379ca7..348b86f 100644
--- a/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js
+++ b/src/algorithms/graph/strongly-connected-components/__test__/stronglyConnectedComponents.test.js
@@ -1,14 +1,14 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import stronglyConnectedComponents from '../stronglyConnectedComponents';
-
-describe('stronglyConnectedComponents', () => {
-  it('should detect strongly connected components in simple graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import stronglyConnectedComponents from "../stronglyConnectedComponents";
+
+describe("stronglyConnectedComponents", () => {
+  it("should detect strongly connected components in simple graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -17,11 +17,7 @@ describe('stronglyConnectedComponents', () => {
 
     const graph = new Graph(true);
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCA)
-      .addEdge(edgeCD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCA).addEdge(edgeCD);
 
     const components = stronglyConnectedComponents(graph);
 
@@ -35,18 +31,18 @@ describe('stronglyConnectedComponents', () => {
     expect(components[1][0].getKey()).toBe(vertexD.getKey());
   });
 
-  it('should detect strongly connected components in graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
-    const vertexI = new GraphVertex('I');
-    const vertexJ = new GraphVertex('J');
-    const vertexK = new GraphVertex('K');
+  it("should detect strongly connected components in graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
+    const vertexI = new GraphVertex("I");
+    const vertexJ = new GraphVertex("J");
+    const vertexK = new GraphVertex("K");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -100,3 +96,4 @@ describe('stronglyConnectedComponents', () => {
     expect(components[3][2].getKey()).toBe(vertexE.getKey());
   });
 });
+
diff --git a/src/algorithms/graph/strongly-connected-components/stronglyConnectedComponents.js b/src/algorithms/graph/strongly-connected-components/stronglyConnectedComponents.js
index 8096277..85994b2 100644
--- a/src/algorithms/graph/strongly-connected-components/stronglyConnectedComponents.js
+++ b/src/algorithms/graph/strongly-connected-components/stronglyConnectedComponents.js
@@ -1,5 +1,5 @@
-import Stack from '../../../data-structures/stack/Stack';
-import depthFirstSearch from '../depth-first-search/depthFirstSearch';
+import Stack from "../../../data-structures/stack/Stack";
+import depthFirstSearch from "../depth-first-search/depthFirstSearch";
 
 /**
  * @param {Graph} graph
@@ -23,19 +23,22 @@ function getVerticesSortedByDfsFinishTime(graph) {
 
   // Specify DFS traversal callbacks.
   const dfsCallbacks = {
-    enterVertex: ({ currentVertex }) => {
+    enterVertex: (_ref) => {
+      let currentVertex = _ref.currentVertex;
       // Add current vertex to visited set.
       visitedVerticesSet[currentVertex.getKey()] = currentVertex;
 
       // Delete current vertex from not visited set.
       delete notVisitedVerticesSet[currentVertex.getKey()];
     },
-    leaveVertex: ({ currentVertex }) => {
+    leaveVertex: (_ref2) => {
+      let currentVertex = _ref2.currentVertex;
       // Push vertex to the stack when leaving it.
       // This will make stack to be ordered by finish time in decreasing order.
       verticesByDfsFinishTime.push(currentVertex);
     },
-    allowTraversal: ({ nextVertex }) => {
+    allowTraversal: (_ref3) => {
+      let nextVertex = _ref3.nextVertex;
       // Don't allow to traverse the nodes that have been already visited.
       return !visitedVerticesSet[nextVertex.getKey()];
     },
@@ -71,23 +74,28 @@ function getSCCSets(graph, verticesByFinishTime) {
 
   // Callbacks for DFS traversal.
   const dfsCallbacks = {
-    enterVertex: ({ currentVertex }) => {
+    enterVertex: (_ref4) => {
+      let currentVertex = _ref4.currentVertex;
       // Add current vertex to SCC set of current DFS round.
       stronglyConnectedComponentsSet.push(currentVertex);
 
       // Add current vertex to visited set.
       visitedVerticesSet[currentVertex.getKey()] = currentVertex;
     },
-    leaveVertex: ({ previousVertex }) => {
+    leaveVertex: (_ref5) => {
+      let previousVertex = _ref5.previousVertex;
       // Once DFS traversal is finished push the set of found strongly connected
       // components during current DFS round to overall strongly connected components set.
       // The sign that traversal is about to be finished is that we came back to start vertex
       // which doesn't have parent.
       if (previousVertex === null) {
-        stronglyConnectedComponentsSets.push([...stronglyConnectedComponentsSet]);
+        stronglyConnectedComponentsSets.push([
+          ...stronglyConnectedComponentsSet,
+        ]);
       }
     },
-    allowTraversal: ({ nextVertex }) => {
+    allowTraversal: (_ref6) => {
+      let nextVertex = _ref6.nextVertex;
       // Don't allow traversal of already visited vertices.
       return !visitedVerticesSet[nextVertex.getKey()];
     },
@@ -131,3 +139,4 @@ export default function stronglyConnectedComponents(graph) {
   // Do DFS once again on reversed graph.
   return getSCCSets(graph, verticesByFinishTime);
 }
+
diff --git a/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js b/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js
index e2904cf..550f1ae 100644
--- a/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js
+++ b/src/algorithms/graph/topological-sorting/__test__/topologicalSort.test.js
@@ -1,18 +1,18 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import topologicalSort from '../topologicalSort';
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import topologicalSort from "../topologicalSort";
 
-describe('topologicalSort', () => {
-  it('should do topological sorting on graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
-    const vertexE = new GraphVertex('E');
-    const vertexF = new GraphVertex('F');
-    const vertexG = new GraphVertex('G');
-    const vertexH = new GraphVertex('H');
+describe("topologicalSort", () => {
+  it("should do topological sorting on graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
+    const vertexE = new GraphVertex("E");
+    const vertexF = new GraphVertex("F");
+    const vertexG = new GraphVertex("G");
+    const vertexH = new GraphVertex("H");
 
     const edgeAC = new GraphEdge(vertexA, vertexC);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -51,3 +51,4 @@ describe('topologicalSort', () => {
     ]);
   });
 });
+
diff --git a/src/algorithms/graph/topological-sorting/topologicalSort.js b/src/algorithms/graph/topological-sorting/topologicalSort.js
index cd7bdd3..bf75d49 100644
--- a/src/algorithms/graph/topological-sorting/topologicalSort.js
+++ b/src/algorithms/graph/topological-sorting/topologicalSort.js
@@ -1,5 +1,5 @@
-import Stack from '../../../data-structures/stack/Stack';
-import depthFirstSearch from '../depth-first-search/depthFirstSearch';
+import Stack from "../../../data-structures/stack/Stack";
+import depthFirstSearch from "../depth-first-search/depthFirstSearch";
 
 /**
  * @param {Graph} graph
@@ -18,18 +18,21 @@ export default function topologicalSort(graph) {
   const sortedStack = new Stack();
 
   const dfsCallbacks = {
-    enterVertex: ({ currentVertex }) => {
+    enterVertex: (_ref) => {
+      let currentVertex = _ref.currentVertex;
       // Add vertex to visited set in case if all its children has been explored.
       visitedSet[currentVertex.getKey()] = currentVertex;
 
       // Remove this vertex from unvisited set.
       delete unvisitedSet[currentVertex.getKey()];
     },
-    leaveVertex: ({ currentVertex }) => {
+    leaveVertex: (_ref2) => {
+      let currentVertex = _ref2.currentVertex;
       // If the vertex has been totally explored then we may push it to stack.
       sortedStack.push(currentVertex);
     },
-    allowTraversal: ({ nextVertex }) => {
+    allowTraversal: (_ref3) => {
+      let nextVertex = _ref3.nextVertex;
       return !visitedSet[nextVertex.getKey()];
     },
   };
@@ -45,3 +48,4 @@ export default function topologicalSort(graph) {
 
   return sortedStack.toArray();
 }
+
diff --git a/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js b/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js
index 54eb07d..4b7d59b 100644
--- a/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js
+++ b/src/algorithms/graph/travelling-salesman/__test__/bfTravellingSalesman.test.js
@@ -1,14 +1,14 @@
-import GraphVertex from '../../../../data-structures/graph/GraphVertex';
-import GraphEdge from '../../../../data-structures/graph/GraphEdge';
-import Graph from '../../../../data-structures/graph/Graph';
-import bfTravellingSalesman from '../bfTravellingSalesman';
-
-describe('bfTravellingSalesman', () => {
-  it('should solve problem for simple graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+import GraphVertex from "../../../../data-structures/graph/GraphVertex";
+import GraphEdge from "../../../../data-structures/graph/GraphEdge";
+import Graph from "../../../../data-structures/graph/Graph";
+import bfTravellingSalesman from "../bfTravellingSalesman";
+
+describe("bfTravellingSalesman", () => {
+  it("should solve problem for simple graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 1);
     const edgeBD = new GraphEdge(vertexB, vertexD, 1);
@@ -49,3 +49,4 @@ describe('bfTravellingSalesman', () => {
     expect(salesmanPath[3].getKey()).toEqual(vertexC.getKey());
   });
 });
+
diff --git a/src/algorithms/graph/travelling-salesman/bfTravellingSalesman.js b/src/algorithms/graph/travelling-salesman/bfTravellingSalesman.js
index a13fa24..072f983 100644
--- a/src/algorithms/graph/travelling-salesman/bfTravellingSalesman.js
+++ b/src/algorithms/graph/travelling-salesman/bfTravellingSalesman.js
@@ -4,7 +4,11 @@
  * @param {GraphVertex[][]} [paths]
  * @param {GraphVertex[]} [path]
  */
-function findAllPaths(startVertex, paths = [], path = []) {
+function findAllPaths(startVertex) {
+  let paths =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
+  let path =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
   // Clone path.
   const currentPath = [...path];
 
@@ -32,7 +36,11 @@ function findAllPaths(startVertex, paths = [], path = []) {
   }
 
   // Go through all the neighbors.
-  for (let neighborIndex = 0; neighborIndex < unvisitedNeighbors.length; neighborIndex += 1) {
+  for (
+    let neighborIndex = 0;
+    neighborIndex < unvisitedNeighbors.length;
+    neighborIndex += 1
+  ) {
     const currentUnvisitedNeighbor = unvisitedNeighbors[neighborIndex];
     findAllPaths(currentUnvisitedNeighbor, paths, currentPath);
   }
@@ -88,12 +96,23 @@ export default function bfTravellingSalesman(graph) {
   const verticesIndices = graph.getVerticesIndices();
   let salesmanPath = [];
   let salesmanPathWeight = null;
-  for (let cycleIndex = 0; cycleIndex < allPossibleCycles.length; cycleIndex += 1) {
+  for (
+    let cycleIndex = 0;
+    cycleIndex < allPossibleCycles.length;
+    cycleIndex += 1
+  ) {
     const currentCycle = allPossibleCycles[cycleIndex];
-    const currentCycleWeight = getCycleWeight(adjacencyMatrix, verticesIndices, currentCycle);
+    const currentCycleWeight = getCycleWeight(
+      adjacencyMatrix,
+      verticesIndices,
+      currentCycle
+    );
 
     // If current cycle weight is smaller then previous ones treat current cycle as most optimal.
-    if (salesmanPathWeight === null || currentCycleWeight < salesmanPathWeight) {
+    if (
+      salesmanPathWeight === null ||
+      currentCycleWeight < salesmanPathWeight
+    ) {
       salesmanPath = currentCycle;
       salesmanPathWeight = currentCycleWeight;
     }
@@ -102,3 +121,4 @@ export default function bfTravellingSalesman(graph) {
   // Return the solution.
   return salesmanPath;
 }
+
diff --git a/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.test.js b/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.test.js
index 9afed97..a0f3b01 100644
--- a/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.test.js
+++ b/src/algorithms/image-processing/seam-carving/__tests__/resizeImageWidth.test.js
@@ -1,8 +1,68 @@
-import { createCanvas, loadImage } from 'canvas';
-import resizeImageWidth from '../resizeImageWidth';
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+import { createCanvas, loadImage } from "canvas";
+import resizeImageWidth from "../resizeImageWidth";
 
-const testImageBeforePath = './src/algorithms/image-processing/seam-carving/__tests__/test-image-before.jpg';
-const testImageAfterPath = './src/algorithms/image-processing/seam-carving/__tests__/test-image-after.jpg';
+const testImageBeforePath =
+  "./src/algorithms/image-processing/seam-carving/__tests__/test-image-before.jpg";
+const testImageAfterPath =
+  "./src/algorithms/image-processing/seam-carving/__tests__/test-image-after.jpg";
 
 /**
  * Compares two images and finds the number of different pixels.
@@ -12,18 +72,38 @@ const testImageAfterPath = './src/algorithms/image-processing/seam-carving/__tes
  * @param {number} threshold - Color difference threshold [0..255]. Smaller - stricter.
  * @returns {number} - Number of different pixels.
  */
-function pixelsDiff(imgA, imgB, threshold = 0) {
+function pixelsDiff(imgA, imgB) {
+  let threshold =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
   if (imgA.width !== imgB.width || imgA.height !== imgB.height) {
-    throw new Error('Images must have the same size');
+    throw new Error("Images must have the same size");
   }
 
   let differentPixels = 0;
   const numColorParams = 4; // RGBA
 
-  for (let pixelIndex = 0; pixelIndex < imgA.data.length; pixelIndex += numColorParams) {
+  for (
+    let pixelIndex = 0;
+    pixelIndex < imgA.data.length;
+    pixelIndex += numColorParams
+  ) {
     // Get pixel's color for each image.
-    const [aR, aG, aB] = imgA.data.subarray(pixelIndex, pixelIndex + numColorParams);
-    const [bR, bG, bB] = imgB.data.subarray(pixelIndex, pixelIndex + numColorParams);
+    const _imgA$data$subarray = imgA.data.subarray(
+        pixelIndex,
+        pixelIndex + numColorParams
+      ),
+      _imgA$data$subarray2 = _slicedToArray(_imgA$data$subarray, 3),
+      aR = _imgA$data$subarray2[0],
+      aG = _imgA$data$subarray2[1],
+      aB = _imgA$data$subarray2[2];
+    const _imgB$data$subarray = imgB.data.subarray(
+        pixelIndex,
+        pixelIndex + numColorParams
+      ),
+      _imgB$data$subarray2 = _slicedToArray(_imgB$data$subarray, 3),
+      bR = _imgB$data$subarray2[0],
+      bG = _imgB$data$subarray2[1],
+      bB = _imgB$data$subarray2[2];
 
     // Get average pixel's color for each image (make them greyscale).
     const aAvgColor = Math.floor((aR + aG + aB) / 3);
@@ -38,40 +118,68 @@ function pixelsDiff(imgA, imgB, threshold = 0) {
   return differentPixels;
 }
 
-describe('resizeImageWidth', () => {
-  it('should perform content-aware image width reduction', () => {
+describe("resizeImageWidth", () => {
+  it("should perform content-aware image width reduction", () => {
     // @see: https://jestjs.io/docs/asynchronous
     return Promise.all([
       loadImage(testImageBeforePath),
       loadImage(testImageAfterPath),
-    ]).then(([imgBefore, imgAfter]) => {
+    ]).then((_ref) => {
+      let _ref2 = _slicedToArray(_ref, 2),
+        imgBefore = _ref2[0],
+        imgAfter = _ref2[1];
       // Original image.
       const canvasBefore = createCanvas(imgBefore.width, imgBefore.height);
-      const ctxBefore = canvasBefore.getContext('2d');
+      const ctxBefore = canvasBefore.getContext("2d");
       ctxBefore.drawImage(imgBefore, 0, 0, imgBefore.width, imgBefore.height);
-      const imgDataBefore = ctxBefore.getImageData(0, 0, imgBefore.width, imgBefore.height);
+      const imgDataBefore = ctxBefore.getImageData(
+        0,
+        0,
+        imgBefore.width,
+        imgBefore.height
+      );
 
       // Resized image saved.
       const canvasAfter = createCanvas(imgAfter.width, imgAfter.height);
-      const ctxAfter = canvasAfter.getContext('2d');
+      const ctxAfter = canvasAfter.getContext("2d");
       ctxAfter.drawImage(imgAfter, 0, 0, imgAfter.width, imgAfter.height);
-      const imgDataAfter = ctxAfter.getImageData(0, 0, imgAfter.width, imgAfter.height);
+      const imgDataAfter = ctxAfter.getImageData(
+        0,
+        0,
+        imgAfter.width,
+        imgAfter.height
+      );
 
       const toWidth = Math.floor(imgBefore.width / 2);
 
-      const {
-        img: resizedImg,
-        size: resizedSize,
-      } = resizeImageWidth({ img: imgDataBefore, toWidth });
+      const _resizeImageWidth = resizeImageWidth({
+          img: imgDataBefore,
+          toWidth,
+        }),
+        resizedImg = _resizeImageWidth.img,
+        resizedSize = _resizeImageWidth.size;
 
       expect(resizedImg).toBeDefined();
       expect(resizedSize).toBeDefined();
 
       // Resized image generated.
       const canvasTest = createCanvas(resizedSize.w, resizedSize.h);
-      const ctxTest = canvasTest.getContext('2d');
-      ctxTest.putImageData(resizedImg, 0, 0, 0, 0, resizedSize.w, resizedSize.h);
-      const imgDataTest = ctxTest.getImageData(0, 0, resizedSize.w, resizedSize.h);
+      const ctxTest = canvasTest.getContext("2d");
+      ctxTest.putImageData(
+        resizedImg,
+        0,
+        0,
+        0,
+        0,
+        resizedSize.w,
+        resizedSize.h
+      );
+      const imgDataTest = ctxTest.getImageData(
+        0,
+        0,
+        resizedSize.w,
+        resizedSize.h
+      );
 
       expect(resizedSize).toEqual({ w: toWidth, h: imgBefore.height });
       expect(imgDataTest.width).toBe(toWidth);
@@ -80,12 +188,19 @@ describe('resizeImageWidth', () => {
       expect(imgDataTest.height).toBe(imgAfter.height);
 
       const colorThreshold = 50;
-      const differentPixels = pixelsDiff(imgDataTest, imgDataAfter, colorThreshold);
+      const differentPixels = pixelsDiff(
+        imgDataTest,
+        imgDataAfter,
+        colorThreshold
+      );
 
       // Allow 10% of pixels to be different
-      const pixelsThreshold = Math.floor((imgAfter.width * imgAfter.height) / 10);
+      const pixelsThreshold = Math.floor(
+        (imgAfter.width * imgAfter.height) / 10
+      );
 
       expect(differentPixels).toBeLessThanOrEqual(pixelsThreshold);
     });
   });
 });
+
diff --git a/src/algorithms/image-processing/seam-carving/resizeImageWidth.js b/src/algorithms/image-processing/seam-carving/resizeImageWidth.js
index 9f2c92f..9d6012c 100644
--- a/src/algorithms/image-processing/seam-carving/resizeImageWidth.js
+++ b/src/algorithms/image-processing/seam-carving/resizeImageWidth.js
@@ -1,4 +1,62 @@
-import { getPixel, setPixel } from '../utils/imageData';
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+import { getPixel, setPixel } from "../utils/imageData";
 
 /**
  * The seam is a sequence of pixels (coordinates).
@@ -47,11 +105,9 @@ import { getPixel, setPixel } from '../utils/imageData';
  * @returns {?(number | SeamPixelMeta)[][]}
  */
 const matrix = (w, h, filler) => {
-  return new Array(h)
-    .fill(null)
-    .map(() => {
-      return new Array(w).fill(filler);
-    });
+  return new Array(h).fill(null).map(() => {
+    return new Array(w).fill(filler);
+  });
 };
 
 /**
@@ -63,19 +119,28 @@ const matrix = (w, h, filler) => {
  */
 const getPixelEnergy = (left, middle, right) => {
   // Middle pixel is the pixel we're calculating the energy for.
-  const [mR, mG, mB] = middle;
+  const _middle = _slicedToArray(middle, 3),
+    mR = _middle[0],
+    mG = _middle[1],
+    mB = _middle[2];
 
   // Energy from the left pixel (if it exists).
   let lEnergy = 0;
   if (left) {
-    const [lR, lG, lB] = left;
+    const _left = _slicedToArray(left, 3),
+      lR = _left[0],
+      lG = _left[1],
+      lB = _left[2];
     lEnergy = (lR - mR) ** 2 + (lG - mG) ** 2 + (lB - mB) ** 2;
   }
 
   // Energy from the right pixel (if it exists).
   let rEnergy = 0;
   if (right) {
-    const [rR, rG, rB] = right;
+    const _right = _slicedToArray(right, 3),
+      rR = _right[0],
+      rG = _right[1],
+      rB = _right[2];
     rEnergy = (rR - mR) ** 2 + (rG - mG) ** 2 + (rB - mB) ** 2;
   }
 
@@ -89,18 +154,20 @@ const getPixelEnergy = (left, middle, right) => {
  * @param {ImageSize} size
  * @returns {EnergyMap}
  */
-const calculateEnergyMap = (img, { w, h }) => {
+const calculateEnergyMap = (img, _ref) => {
+  let w = _ref.w,
+    h = _ref.h;
   // Create an empty energy map where each pixel has infinitely high energy.
   // We will update the energy of each pixel.
   const energyMap = matrix(w, h, Infinity);
   for (let y = 0; y < h; y += 1) {
     for (let x = 0; x < w; x += 1) {
       // Left pixel might not exist if we're on the very left edge of the image.
-      const left = (x - 1) >= 0 ? getPixel(img, { x: x - 1, y }) : null;
+      const left = x - 1 >= 0 ? getPixel(img, { x: x - 1, y }) : null;
       // The color of the middle pixel that we're calculating the energy for.
       const middle = getPixel(img, { x, y });
       // Right pixel might not exist if we're on the very right edge of the image.
-      const right = (x + 1) < w ? getPixel(img, { x: x + 1, y }) : null;
+      const right = x + 1 < w ? getPixel(img, { x: x + 1, y }) : null;
       energyMap[y][x] = getPixelEnergy(left, middle, right);
     }
   }
@@ -114,7 +181,9 @@ const calculateEnergyMap = (img, { w, h }) => {
  * @param {ImageSize} size
  * @returns {Seam}
  */
-const findLowEnergySeam = (energyMap, { w, h }) => {
+const findLowEnergySeam = (energyMap, _ref2) => {
+  let w = _ref2.w,
+    h = _ref2.h;
   // The 2D array of the size of w and h, where each pixel contains the
   // seam metadata (pixel energy, pixel coordinate and previous pixel from
   // the lowest energy seam at this point).
@@ -141,7 +210,7 @@ const findLowEnergySeam = (energyMap, { w, h }) => {
       // us to the current pixel with the coordinates x and y.
       let minPrevEnergy = Infinity;
       let minPrevX = x;
-      for (let i = (x - 1); i <= (x + 1); i += 1) {
+      for (let i = x - 1; i <= x + 1; i += 1) {
         if (i >= 0 && i < w && seamPixelsMap[y - 1][i].energy < minPrevEnergy) {
           minPrevEnergy = seamPixelsMap[y - 1][i].energy;
           minPrevX = i;
@@ -175,7 +244,9 @@ const findLowEnergySeam = (energyMap, { w, h }) => {
   // energy seam based on the "previous" value of the seam pixel metadata.
   const seam = [];
 
-  const { x: lastMinX, y: lastMinY } = lastMinCoordinate;
+  const _lastMinCoordinate = lastMinCoordinate,
+    lastMinX = _lastMinCoordinate.x,
+    lastMinY = _lastMinCoordinate.y;
 
   // Adding new pixel to the seam path one by one until we reach the top.
   let currentSeam = seamPixelsMap[lastMinY][lastMinX];
@@ -185,7 +256,8 @@ const findLowEnergySeam = (energyMap, { w, h }) => {
     if (!prevMinCoordinates) {
       currentSeam = null;
     } else {
-      const { x: prevMinX, y: prevMinY } = prevMinCoordinates;
+      const prevMinX = prevMinCoordinates.x,
+        prevMinY = prevMinCoordinates.y;
       currentSeam = seamPixelsMap[prevMinY][prevMinX];
     }
   }
@@ -200,9 +272,12 @@ const findLowEnergySeam = (energyMap, { w, h }) => {
  * @param {Seam} seam
  * @param {ImageSize} size
  */
-const deleteSeam = (img, seam, { w }) => {
-  seam.forEach(({ x: seamX, y: seamY }) => {
-    for (let x = seamX; x < (w - 1); x += 1) {
+const deleteSeam = (img, seam, _ref3) => {
+  let w = _ref3.w;
+  seam.forEach((_ref4) => {
+    let seamX = _ref4.x,
+      seamY = _ref4.y;
+    for (let x = seamX; x < w - 1; x += 1) {
       const nextPixel = getPixel(img, { x: x + 1, y: seamY });
       setPixel(img, { x, y: seamY }, nextPixel);
     }
@@ -214,7 +289,9 @@ const deleteSeam = (img, seam, { w }) => {
  * @param {ResizeImageWidthArgs} args
  * @returns {ResizeImageWidthResult}
  */
-const resizeImageWidth = ({ img, toWidth }) => {
+const resizeImageWidth = (_ref5) => {
+  let img = _ref5.img,
+    toWidth = _ref5.toWidth;
   /**
    * For performance reasons we want to avoid changing the img data array size.
    * Instead we'll just keep the record of the resized image width and height separately.
@@ -251,3 +328,4 @@ const resizeImageWidth = ({ img, toWidth }) => {
 };
 
 export default resizeImageWidth;
+
diff --git a/src/algorithms/image-processing/utils/imageData.js b/src/algorithms/image-processing/utils/imageData.js
index de397b8..fccdaff 100644
--- a/src/algorithms/image-processing/utils/imageData.js
+++ b/src/algorithms/image-processing/utils/imageData.js
@@ -14,14 +14,19 @@
  * @param {PixelCoordinate} coordinate
  * @returns {PixelColor}
  */
-export const getPixel = (img, { x, y }) => {
+export const getPixel = (img, _ref) => {
+  let x = _ref.x,
+    y = _ref.y;
   // The ImageData data array is a flat 1D array.
   // Thus we need to convert x and y coordinates to the linear index.
   const i = y * img.width + x;
   const cellsPerColor = 4; // RGBA
   // For better efficiency, instead of creating a new sub-array we return
   // a pointer to the part of the ImageData array.
-  return img.data.subarray(i * cellsPerColor, i * cellsPerColor + cellsPerColor);
+  return img.data.subarray(
+    i * cellsPerColor,
+    i * cellsPerColor + cellsPerColor
+  );
 };
 
 /**
@@ -30,10 +35,13 @@ export const getPixel = (img, { x, y }) => {
  * @param {PixelCoordinate} coordinate
  * @param {PixelColor} color
  */
-export const setPixel = (img, { x, y }, color) => {
+export const setPixel = (img, _ref2, color) => {
+  let x = _ref2.x,
+    y = _ref2.y;
   // The ImageData data array is a flat 1D array.
   // Thus we need to convert x and y coordinates to the linear index.
   const i = y * img.width + x;
   const cellsPerColor = 4; // RGBA
   img.data.set(color, i * cellsPerColor);
 };
+
diff --git a/src/algorithms/linked-list/reverse-traversal/__test__/reverseTraversal.test.js b/src/algorithms/linked-list/reverse-traversal/__test__/reverseTraversal.test.js
index 2fb5af9..b55782e 100644
--- a/src/algorithms/linked-list/reverse-traversal/__test__/reverseTraversal.test.js
+++ b/src/algorithms/linked-list/reverse-traversal/__test__/reverseTraversal.test.js
@@ -1,14 +1,11 @@
-import LinkedList from '../../../../data-structures/linked-list/LinkedList';
-import reverseTraversal from '../reverseTraversal';
+import LinkedList from "../../../../data-structures/linked-list/LinkedList";
+import reverseTraversal from "../reverseTraversal";
 
-describe('reverseTraversal', () => {
-  it('should traverse linked list in reverse order', () => {
+describe("reverseTraversal", () => {
+  it("should traverse linked list in reverse order", () => {
     const linkedList = new LinkedList();
 
-    linkedList
-      .append(1)
-      .append(2)
-      .append(3);
+    linkedList.append(1).append(2).append(3);
 
     const traversedNodeValues = [];
     const traversalCallback = (nodeValue) => {
@@ -33,3 +30,4 @@ describe('reverseTraversal', () => {
 //   expect(linkedList.reverseTraversal(linkedList.head, value => value * 2)).toEqual([6, 4, 2]);
 //   expect(() => linkedList.reverseTraversal(linkedList.head)).toThrow();
 // });
+
diff --git a/src/algorithms/linked-list/reverse-traversal/reverseTraversal.js b/src/algorithms/linked-list/reverse-traversal/reverseTraversal.js
index d39260a..91cbae7 100644
--- a/src/algorithms/linked-list/reverse-traversal/reverseTraversal.js
+++ b/src/algorithms/linked-list/reverse-traversal/reverseTraversal.js
@@ -22,3 +22,4 @@ function reverseTraversalRecursive(node, callback) {
 export default function reverseTraversal(linkedList, callback) {
   reverseTraversalRecursive(linkedList.head, callback);
 }
+
diff --git a/src/algorithms/linked-list/traversal/__test__/traversal.test.js b/src/algorithms/linked-list/traversal/__test__/traversal.test.js
index 77ce79b..dd665bc 100644
--- a/src/algorithms/linked-list/traversal/__test__/traversal.test.js
+++ b/src/algorithms/linked-list/traversal/__test__/traversal.test.js
@@ -1,14 +1,11 @@
-import LinkedList from '../../../../data-structures/linked-list/LinkedList';
-import traversal from '../traversal';
+import LinkedList from "../../../../data-structures/linked-list/LinkedList";
+import traversal from "../traversal";
 
-describe('traversal', () => {
-  it('should traverse linked list', () => {
+describe("traversal", () => {
+  it("should traverse linked list", () => {
     const linkedList = new LinkedList();
 
-    linkedList
-      .append(1)
-      .append(2)
-      .append(3);
+    linkedList.append(1).append(2).append(3);
 
     const traversedNodeValues = [];
     const traversalCallback = (nodeValue) => {
@@ -20,3 +17,4 @@ describe('traversal', () => {
     expect(traversedNodeValues).toEqual([1, 2, 3]);
   });
 });
+
diff --git a/src/algorithms/linked-list/traversal/traversal.js b/src/algorithms/linked-list/traversal/traversal.js
index cfbfe4f..7b6ec71 100644
--- a/src/algorithms/linked-list/traversal/traversal.js
+++ b/src/algorithms/linked-list/traversal/traversal.js
@@ -16,3 +16,4 @@ export default function traversal(linkedList, callback) {
     currentNode = currentNode.next;
   }
 }
+
diff --git a/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js b/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js
index 53afe69..351983d 100644
--- a/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js
+++ b/src/algorithms/math/binary-floating-point/__tests__/bitsToFloat.test.js
@@ -1,32 +1,122 @@
-import { testCases16Bits, testCases32Bits, testCases64Bits } from '../testCases';
-import { bitsToFloat16, bitsToFloat32, bitsToFloat64 } from '../bitsToFloat';
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+import {
+  testCases16Bits,
+  testCases32Bits,
+  testCases64Bits,
+} from "../testCases";
+import { bitsToFloat16, bitsToFloat32, bitsToFloat64 } from "../bitsToFloat";
 
-describe('bitsToFloat16', () => {
-  it('should convert floating point binary bits to floating point decimal number', () => {
-    for (let testCaseIndex = 0; testCaseIndex < testCases16Bits.length; testCaseIndex += 1) {
-      const [decimal, binary] = testCases16Bits[testCaseIndex];
-      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
+describe("bitsToFloat16", () => {
+  it("should convert floating point binary bits to floating point decimal number", () => {
+    for (
+      let testCaseIndex = 0;
+      testCaseIndex < testCases16Bits.length;
+      testCaseIndex += 1
+    ) {
+      const _testCases16Bits$test = _slicedToArray(
+          testCases16Bits[testCaseIndex],
+          2
+        ),
+        decimal = _testCases16Bits$test[0],
+        binary = _testCases16Bits$test[1];
+      const bits = binary.split("").map((bitString) => parseInt(bitString, 10));
       expect(bitsToFloat16(bits)).toBeCloseTo(decimal, 4);
     }
   });
 });
 
-describe('bitsToFloat32', () => {
-  it('should convert floating point binary bits to floating point decimal number', () => {
-    for (let testCaseIndex = 0; testCaseIndex < testCases32Bits.length; testCaseIndex += 1) {
-      const [decimal, binary] = testCases32Bits[testCaseIndex];
-      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
+describe("bitsToFloat32", () => {
+  it("should convert floating point binary bits to floating point decimal number", () => {
+    for (
+      let testCaseIndex = 0;
+      testCaseIndex < testCases32Bits.length;
+      testCaseIndex += 1
+    ) {
+      const _testCases32Bits$test = _slicedToArray(
+          testCases32Bits[testCaseIndex],
+          2
+        ),
+        decimal = _testCases32Bits$test[0],
+        binary = _testCases32Bits$test[1];
+      const bits = binary.split("").map((bitString) => parseInt(bitString, 10));
       expect(bitsToFloat32(bits)).toBeCloseTo(decimal, 7);
     }
   });
 });
 
-describe('bitsToFloat64', () => {
-  it('should convert floating point binary bits to floating point decimal number', () => {
-    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
-      const [decimal, binary] = testCases64Bits[testCaseIndex];
-      const bits = binary.split('').map((bitString) => parseInt(bitString, 10));
+describe("bitsToFloat64", () => {
+  it("should convert floating point binary bits to floating point decimal number", () => {
+    for (
+      let testCaseIndex = 0;
+      testCaseIndex < testCases64Bits.length;
+      testCaseIndex += 1
+    ) {
+      const _testCases64Bits$test = _slicedToArray(
+          testCases64Bits[testCaseIndex],
+          2
+        ),
+        decimal = _testCases64Bits$test[0],
+        binary = _testCases64Bits$test[1];
+      const bits = binary.split("").map((bitString) => parseInt(bitString, 10));
       expect(bitsToFloat64(bits)).toBeCloseTo(decimal, 14);
     }
   });
 });
+
diff --git a/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js b/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js
index efb8a2b..bef1651 100644
--- a/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js
+++ b/src/algorithms/math/binary-floating-point/__tests__/floatAsBinaryString.test.js
@@ -1,20 +1,100 @@
-import { floatAs32BinaryString, floatAs64BinaryString } from '../floatAsBinaryString';
-import { testCases32Bits, testCases64Bits } from '../testCases';
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+import {
+  floatAs32BinaryString,
+  floatAs64BinaryString,
+} from "../floatAsBinaryString";
+import { testCases32Bits, testCases64Bits } from "../testCases";
 
-describe('floatAs32Binary', () => {
-  it('should create a binary representation of the floating numbers', () => {
-    for (let testCaseIndex = 0; testCaseIndex < testCases32Bits.length; testCaseIndex += 1) {
-      const [decimal, binary] = testCases32Bits[testCaseIndex];
+describe("floatAs32Binary", () => {
+  it("should create a binary representation of the floating numbers", () => {
+    for (
+      let testCaseIndex = 0;
+      testCaseIndex < testCases32Bits.length;
+      testCaseIndex += 1
+    ) {
+      const _testCases32Bits$test = _slicedToArray(
+          testCases32Bits[testCaseIndex],
+          2
+        ),
+        decimal = _testCases32Bits$test[0],
+        binary = _testCases32Bits$test[1];
       expect(floatAs32BinaryString(decimal)).toBe(binary);
     }
   });
 });
 
-describe('floatAs64Binary', () => {
-  it('should create a binary representation of the floating numbers', () => {
-    for (let testCaseIndex = 0; testCaseIndex < testCases64Bits.length; testCaseIndex += 1) {
-      const [decimal, binary] = testCases64Bits[testCaseIndex];
+describe("floatAs64Binary", () => {
+  it("should create a binary representation of the floating numbers", () => {
+    for (
+      let testCaseIndex = 0;
+      testCaseIndex < testCases64Bits.length;
+      testCaseIndex += 1
+    ) {
+      const _testCases64Bits$test = _slicedToArray(
+          testCases64Bits[testCaseIndex],
+          2
+        ),
+        decimal = _testCases64Bits$test[0],
+        binary = _testCases64Bits$test[1];
       expect(floatAs64BinaryString(decimal)).toBe(binary);
     }
   });
 });
+
diff --git a/src/algorithms/math/binary-floating-point/bitsToFloat.js b/src/algorithms/math/binary-floating-point/bitsToFloat.js
index 6d1ef0d..09b02ba 100644
--- a/src/algorithms/math/binary-floating-point/bitsToFloat.js
+++ b/src/algorithms/math/binary-floating-point/bitsToFloat.js
@@ -35,12 +35,14 @@ const precisionConfigs = {
     exponentBitsCount: 5,
     fractionBitsCount: 10,
   },
+
   // @see: https://en.wikipedia.org/wiki/Single-precision_floating-point_format
   single: {
     signBitsCount: 1,
     exponentBitsCount: 8,
     fractionBitsCount: 23,
   },
+
   // @see: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
   double: {
     signBitsCount: 1,
@@ -57,21 +59,26 @@ const precisionConfigs = {
  * @return {number} - floating point number decoded from its binary representation.
  */
 function bitsToFloat(bits, precisionConfig) {
-  const { signBitsCount, exponentBitsCount } = precisionConfig;
+  const signBitsCount = precisionConfig.signBitsCount,
+    exponentBitsCount = precisionConfig.exponentBitsCount;
 
   // Figuring out the sign.
   const sign = (-1) ** bits[0]; // -1^1 = -1, -1^0 = 1
 
   // Calculating the exponent value.
   const exponentBias = 2 ** (exponentBitsCount - 1) - 1;
-  const exponentBits = bits.slice(signBitsCount, signBitsCount + exponentBitsCount);
+  const exponentBits = bits.slice(
+    signBitsCount,
+    signBitsCount + exponentBitsCount
+  );
   const exponentUnbiased = exponentBits.reduce(
     (exponentSoFar, currentBit, bitIndex) => {
       const bitPowerOfTwo = 2 ** (exponentBitsCount - bitIndex - 1);
       return exponentSoFar + currentBit * bitPowerOfTwo;
     },
-    0,
+    0
   );
+
   const exponent = exponentUnbiased - exponentBias;
 
   // Calculating the fraction value.
@@ -81,11 +88,11 @@ function bitsToFloat(bits, precisionConfig) {
       const bitPowerOfTwo = 2 ** -(bitIndex + 1);
       return fractionSoFar + currentBit * bitPowerOfTwo;
     },
-    0,
+    0
   );
 
   // Putting all parts together to calculate the final number.
-  return sign * (2 ** exponent) * (1 + fraction);
+  return sign * 2 ** exponent * (1 + fraction);
 }
 
 /**
@@ -117,3 +124,4 @@ export function bitsToFloat32(bits) {
 export function bitsToFloat64(bits) {
   return bitsToFloat(bits, precisionConfigs.double);
 }
+
diff --git a/src/algorithms/math/binary-floating-point/floatAsBinaryString.js b/src/algorithms/math/binary-floating-point/floatAsBinaryString.js
index aa907ac..f8b7c1c 100644
--- a/src/algorithms/math/binary-floating-point/floatAsBinaryString.js
+++ b/src/algorithms/math/binary-floating-point/floatAsBinaryString.js
@@ -15,7 +15,7 @@ const bitsInByte = 8;
  * @return {string} - binary string representation of the float number.
  */
 function floatAsBinaryString(floatNumber, byteLength) {
-  let numberAsBinaryString = '';
+  let numberAsBinaryString = "";
 
   const arrayBuffer = new ArrayBuffer(byteLength);
   const dataView = new DataView(arrayBuffer);
@@ -32,7 +32,7 @@ function floatAsBinaryString(floatNumber, byteLength) {
   for (let byteIndex = 0; byteIndex < byteLength; byteIndex += 1) {
     let bits = dataView.getUint8(byteIndex).toString(2);
     if (bits.length < bitsInByte) {
-      bits = new Array(bitsInByte - bits.length).fill('0').join('') + bits;
+      bits = new Array(bitsInByte - bits.length).fill("0").join("") + bits;
     }
     numberAsBinaryString += bits;
   }
@@ -59,3 +59,4 @@ export function floatAs64BinaryString(floatNumber) {
 export function floatAs32BinaryString(floatNumber) {
   return floatAsBinaryString(floatNumber, singlePrecisionBytesLength);
 }
+
diff --git a/src/algorithms/math/binary-floating-point/testCases.js b/src/algorithms/math/binary-floating-point/testCases.js
index 54b9b80..77fa19c 100644
--- a/src/algorithms/math/binary-floating-point/testCases.js
+++ b/src/algorithms/math/binary-floating-point/testCases.js
@@ -8,64 +8,83 @@
  * @type {TestCase[]}
  */
 export const testCases16Bits = [
-  [-65504, '1111101111111111'],
-  [-10344, '1111000100001101'],
-  [-27.15625, '1100111011001010'],
-  [-1, '1011110000000000'],
-  [-0.09997558, '1010111001100110'],
-  [0, '0000000000000000'],
-  [5.9604644775390625e-8, '0000000000000001'],
-  [0.000004529, '0000000001001100'],
-  [0.0999755859375, '0010111001100110'],
-  [0.199951171875, '0011001001100110'],
-  [0.300048828125, '0011010011001101'],
-  [1, '0011110000000000'],
-  [1.5, '0011111000000000'],
-  [1.75, '0011111100000000'],
-  [1.875, '0011111110000000'],
-  [65504, '0111101111111111'],
+  [-65504, "1111101111111111"],
+  [-10344, "1111000100001101"],
+  [-27.15625, "1100111011001010"],
+  [-1, "1011110000000000"],
+  [-0.09997558, "1010111001100110"],
+  [0, "0000000000000000"],
+  [5.9604644775390625e-8, "0000000000000001"],
+  [0.000004529, "0000000001001100"],
+  [0.0999755859375, "0010111001100110"],
+  [0.199951171875, "0011001001100110"],
+  [0.300048828125, "0011010011001101"],
+  [1, "0011110000000000"],
+  [1.5, "0011111000000000"],
+  [1.75, "0011111100000000"],
+  [1.875, "0011111110000000"],
+  [65504, "0111101111111111"],
 ];
 
 /**
  * @type {TestCase[]}
  */
 export const testCases32Bits = [
-  [-3.40282346638528859812e+38, '11111111011111111111111111111111'],
-  [-10345.5595703125, '11000110001000011010011000111101'],
-  [-27.15625, '11000001110110010100000000000000'],
-  [-1, '10111111100000000000000000000000'],
-  [-0.1, '10111101110011001100110011001101'],
-  [0, '00000000000000000000000000000000'],
-  [1.40129846432481707092e-45, '00000000000000000000000000000001'],
-  [0.000004560, '00110110100110010000001000011010'],
-  [0.1, '00111101110011001100110011001101'],
-  [0.2, '00111110010011001100110011001101'],
-  [0.3, '00111110100110011001100110011010'],
-  [1, '00111111100000000000000000000000'],
-  [1.5, '00111111110000000000000000000000'],
-  [1.75, '00111111111000000000000000000000'],
-  [1.875, '00111111111100000000000000000000'],
-  [3.40282346638528859812e+38, '01111111011111111111111111111111'],
+  [-3.40282346638528859812e38, "11111111011111111111111111111111"],
+  [-10345.5595703125, "11000110001000011010011000111101"],
+  [-27.15625, "11000001110110010100000000000000"],
+  [-1, "10111111100000000000000000000000"],
+  [-0.1, "10111101110011001100110011001101"],
+  [0, "00000000000000000000000000000000"],
+  [1.40129846432481707092e-45, "00000000000000000000000000000001"],
+  [0.00000456, "00110110100110010000001000011010"],
+  [0.1, "00111101110011001100110011001101"],
+  [0.2, "00111110010011001100110011001101"],
+  [0.3, "00111110100110011001100110011010"],
+  [1, "00111111100000000000000000000000"],
+  [1.5, "00111111110000000000000000000000"],
+  [1.75, "00111111111000000000000000000000"],
+  [1.875, "00111111111100000000000000000000"],
+  [3.40282346638528859812e38, "01111111011111111111111111111111"],
 ];
 
 /**
  * @type {TestCase[]}
  */
 export const testCases64Bits = [
-  [-1.79769313486231570815e+308, '1111111111101111111111111111111111111111111111111111111111111111'],
-  [-10345.5595703125, '1100000011000100001101001100011110100000000000000000000000000000'],
-  [-27.15625, '1100000000111011001010000000000000000000000000000000000000000000'],
-  [-1, '1011111111110000000000000000000000000000000000000000000000000000'],
-  [-0.1, '1011111110111001100110011001100110011001100110011001100110011010'],
-  [0, '0000000000000000000000000000000000000000000000000000000000000000'],
-  [4.94065645841246544177e-324, '0000000000000000000000000000000000000000000000000000000000000001'],
-  [0.000004560, '0011111011010011001000000100001101000001011100110011110011100100'],
-  [0.1, '0011111110111001100110011001100110011001100110011001100110011010'],
-  [0.2, '0011111111001001100110011001100110011001100110011001100110011010'],
-  [0.3, '0011111111010011001100110011001100110011001100110011001100110011'],
-  [1, '0011111111110000000000000000000000000000000000000000000000000000'],
-  [1.5, '0011111111111000000000000000000000000000000000000000000000000000'],
-  [1.75, '0011111111111100000000000000000000000000000000000000000000000000'],
-  [1.875, '0011111111111110000000000000000000000000000000000000000000000000'],
-  [1.79769313486231570815e+308, '0111111111101111111111111111111111111111111111111111111111111111'],
+  [
+    -1.79769313486231570815e308,
+    "1111111111101111111111111111111111111111111111111111111111111111",
+  ],
+  [
+    -10345.5595703125,
+    "1100000011000100001101001100011110100000000000000000000000000000",
+  ],
+  [
+    -27.15625,
+    "1100000000111011001010000000000000000000000000000000000000000000",
+  ],
+  [-1, "1011111111110000000000000000000000000000000000000000000000000000"],
+  [-0.1, "1011111110111001100110011001100110011001100110011001100110011010"],
+  [0, "0000000000000000000000000000000000000000000000000000000000000000"],
+  [
+    4.94065645841246544177e-324,
+    "0000000000000000000000000000000000000000000000000000000000000001",
+  ],
+  [
+    0.00000456,
+    "0011111011010011001000000100001101000001011100110011110011100100",
+  ],
+  [0.1, "0011111110111001100110011001100110011001100110011001100110011010"],
+  [0.2, "0011111111001001100110011001100110011001100110011001100110011010"],
+  [0.3, "0011111111010011001100110011001100110011001100110011001100110011"],
+  [1, "0011111111110000000000000000000000000000000000000000000000000000"],
+  [1.5, "0011111111111000000000000000000000000000000000000000000000000000"],
+  [1.75, "0011111111111100000000000000000000000000000000000000000000000000"],
+  [1.875, "0011111111111110000000000000000000000000000000000000000000000000"],
+  [
+    1.79769313486231570815e308,
+    "0111111111101111111111111111111111111111111111111111111111111111",
+  ],
 ];
+
diff --git a/src/algorithms/math/bits/__test__/bitLength.test.js b/src/algorithms/math/bits/__test__/bitLength.test.js
index 1731b56..7a4bf78 100644
--- a/src/algorithms/math/bits/__test__/bitLength.test.js
+++ b/src/algorithms/math/bits/__test__/bitLength.test.js
@@ -1,7 +1,7 @@
-import bitLength from '../bitLength';
+import bitLength from "../bitLength";
 
-describe('bitLength', () => {
-  it('should calculate number of bits that the number is consists of', () => {
+describe("bitLength", () => {
+  it("should calculate number of bits that the number is consists of", () => {
     expect(bitLength(0b0)).toBe(0);
     expect(bitLength(0b1)).toBe(1);
     expect(bitLength(0b01)).toBe(1);
@@ -12,3 +12,4 @@ describe('bitLength', () => {
     expect(bitLength(0b00011110101)).toBe(8);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/bitsDiff.test.js b/src/algorithms/math/bits/__test__/bitsDiff.test.js
index e1fd641..5252c6a 100644
--- a/src/algorithms/math/bits/__test__/bitsDiff.test.js
+++ b/src/algorithms/math/bits/__test__/bitsDiff.test.js
@@ -1,7 +1,7 @@
-import bitsDiff from '../bitsDiff';
+import bitsDiff from "../bitsDiff";
 
-describe('bitsDiff', () => {
-  it('should calculate bits difference between two numbers', () => {
+describe("bitsDiff", () => {
+  it("should calculate bits difference between two numbers", () => {
     expect(bitsDiff(0, 0)).toBe(0);
     expect(bitsDiff(1, 1)).toBe(0);
     expect(bitsDiff(124, 124)).toBe(0);
@@ -11,3 +11,4 @@ describe('bitsDiff', () => {
     expect(bitsDiff(1, 3)).toBe(1);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/clearBit.test.js b/src/algorithms/math/bits/__test__/clearBit.test.js
index 2d75877..4011886 100644
--- a/src/algorithms/math/bits/__test__/clearBit.test.js
+++ b/src/algorithms/math/bits/__test__/clearBit.test.js
@@ -1,7 +1,7 @@
-import clearBit from '../clearBit';
+import clearBit from "../clearBit";
 
-describe('clearBit', () => {
-  it('should clear bit at specific position', () => {
+describe("clearBit", () => {
+  it("should clear bit at specific position", () => {
     // 1 = 0b0001
     expect(clearBit(1, 0)).toBe(0);
     expect(clearBit(1, 1)).toBe(1);
@@ -13,3 +13,4 @@ describe('clearBit', () => {
     expect(clearBit(10, 3)).toBe(2);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/countSetBits.test.js b/src/algorithms/math/bits/__test__/countSetBits.test.js
index a6c0fb9..2d39815 100644
--- a/src/algorithms/math/bits/__test__/countSetBits.test.js
+++ b/src/algorithms/math/bits/__test__/countSetBits.test.js
@@ -1,7 +1,7 @@
-import countSetBits from '../countSetBits';
+import countSetBits from "../countSetBits";
 
-describe('countSetBits', () => {
-  it('should return number of set bits', () => {
+describe("countSetBits", () => {
+  it("should return number of set bits", () => {
     expect(countSetBits(0)).toBe(0);
     expect(countSetBits(1)).toBe(1);
     expect(countSetBits(2)).toBe(1);
@@ -18,3 +18,4 @@ describe('countSetBits', () => {
     expect(countSetBits(-4294967296)).toBe(0);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/divideByTwo.test.js b/src/algorithms/math/bits/__test__/divideByTwo.test.js
index ec82936..af2b9a4 100644
--- a/src/algorithms/math/bits/__test__/divideByTwo.test.js
+++ b/src/algorithms/math/bits/__test__/divideByTwo.test.js
@@ -1,7 +1,7 @@
-import divideByTwo from '../divideByTwo';
+import divideByTwo from "../divideByTwo";
 
-describe('divideByTwo', () => {
-  it('should divide numbers by two using bitwise operations', () => {
+describe("divideByTwo", () => {
+  it("should divide numbers by two using bitwise operations", () => {
     expect(divideByTwo(0)).toBe(0);
     expect(divideByTwo(1)).toBe(0);
     expect(divideByTwo(3)).toBe(1);
@@ -10,3 +10,4 @@ describe('divideByTwo', () => {
     expect(divideByTwo(125)).toBe(62);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/fullAdder.test.js b/src/algorithms/math/bits/__test__/fullAdder.test.js
index 529187d..35dbe79 100644
--- a/src/algorithms/math/bits/__test__/fullAdder.test.js
+++ b/src/algorithms/math/bits/__test__/fullAdder.test.js
@@ -1,7 +1,7 @@
-import fullAdder from '../fullAdder';
+import fullAdder from "../fullAdder";
 
-describe('fullAdder', () => {
-  it('should add up two numbers', () => {
+describe("fullAdder", () => {
+  it("should add up two numbers", () => {
     expect(fullAdder(0, 0)).toBe(0);
     expect(fullAdder(2, 0)).toBe(2);
     expect(fullAdder(0, 2)).toBe(2);
@@ -16,3 +16,4 @@ describe('fullAdder', () => {
     expect(fullAdder(121, 2)).toBe(123);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/getBit.test.js b/src/algorithms/math/bits/__test__/getBit.test.js
index 3a7026f..5ad4e78 100644
--- a/src/algorithms/math/bits/__test__/getBit.test.js
+++ b/src/algorithms/math/bits/__test__/getBit.test.js
@@ -1,7 +1,7 @@
-import getBit from '../getBit';
+import getBit from "../getBit";
 
-describe('getBit', () => {
-  it('should get bit at specific position', () => {
+describe("getBit", () => {
+  it("should get bit at specific position", () => {
     // 1 = 0b0001
     expect(getBit(1, 0)).toBe(1);
     expect(getBit(1, 1)).toBe(0);
@@ -21,3 +21,4 @@ describe('getBit', () => {
     expect(getBit(10, 3)).toBe(1);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/isEven.test.js b/src/algorithms/math/bits/__test__/isEven.test.js
index b21bbfb..e232c55 100644
--- a/src/algorithms/math/bits/__test__/isEven.test.js
+++ b/src/algorithms/math/bits/__test__/isEven.test.js
@@ -1,7 +1,7 @@
-import isEven from '../isEven';
+import isEven from "../isEven";
 
-describe('isEven', () => {
-  it('should detect if a number is even', () => {
+describe("isEven", () => {
+  it("should detect if a number is even", () => {
     expect(isEven(0)).toBe(true);
     expect(isEven(2)).toBe(true);
     expect(isEven(-2)).toBe(true);
@@ -17,3 +17,4 @@ describe('isEven', () => {
     expect(isEven(1202)).toBe(true);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/isPositive.test.js b/src/algorithms/math/bits/__test__/isPositive.test.js
index 45dcca0..bd6437f 100644
--- a/src/algorithms/math/bits/__test__/isPositive.test.js
+++ b/src/algorithms/math/bits/__test__/isPositive.test.js
@@ -1,7 +1,7 @@
-import isPositive from '../isPositive';
+import isPositive from "../isPositive";
 
-describe('isPositive', () => {
-  it('should detect if a number is positive', () => {
+describe("isPositive", () => {
+  it("should detect if a number is positive", () => {
     expect(isPositive(1)).toBe(true);
     expect(isPositive(2)).toBe(true);
     expect(isPositive(3)).toBe(true);
@@ -17,3 +17,4 @@ describe('isPositive', () => {
     expect(isPositive(-56644325)).toBe(false);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/isPowerOfTwo.test.js b/src/algorithms/math/bits/__test__/isPowerOfTwo.test.js
index 3408f2c..a7957ce 100644
--- a/src/algorithms/math/bits/__test__/isPowerOfTwo.test.js
+++ b/src/algorithms/math/bits/__test__/isPowerOfTwo.test.js
@@ -1,7 +1,7 @@
-import isPowerOfTwo from '../isPowerOfTwo';
+import isPowerOfTwo from "../isPowerOfTwo";
 
-describe('isPowerOfTwo', () => {
-  it('should detect if the number is power of two', () => {
+describe("isPowerOfTwo", () => {
+  it("should detect if the number is power of two", () => {
     expect(isPowerOfTwo(1)).toBe(true);
     expect(isPowerOfTwo(2)).toBe(true);
     expect(isPowerOfTwo(3)).toBe(false);
@@ -18,3 +18,4 @@ describe('isPowerOfTwo', () => {
     expect(isPowerOfTwo(128)).toBe(true);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/multiply.test.js b/src/algorithms/math/bits/__test__/multiply.test.js
index c219570..a8cf602 100644
--- a/src/algorithms/math/bits/__test__/multiply.test.js
+++ b/src/algorithms/math/bits/__test__/multiply.test.js
@@ -1,7 +1,7 @@
-import multiply from '../multiply';
+import multiply from "../multiply";
 
-describe('multiply', () => {
-  it('should multiply two numbers', () => {
+describe("multiply", () => {
+  it("should multiply two numbers", () => {
     expect(multiply(0, 0)).toBe(0);
     expect(multiply(2, 0)).toBe(0);
     expect(multiply(0, 2)).toBe(0);
@@ -16,3 +16,4 @@ describe('multiply', () => {
     expect(multiply(121, 2)).toBe(242);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/multiplyByTwo.test.js b/src/algorithms/math/bits/__test__/multiplyByTwo.test.js
index 07934c5..c73fc9c 100644
--- a/src/algorithms/math/bits/__test__/multiplyByTwo.test.js
+++ b/src/algorithms/math/bits/__test__/multiplyByTwo.test.js
@@ -1,7 +1,7 @@
-import multiplyByTwo from '../multiplyByTwo';
+import multiplyByTwo from "../multiplyByTwo";
 
-describe('multiplyByTwo', () => {
-  it('should multiply numbers by two using bitwise operations', () => {
+describe("multiplyByTwo", () => {
+  it("should multiply numbers by two using bitwise operations", () => {
     expect(multiplyByTwo(0)).toBe(0);
     expect(multiplyByTwo(1)).toBe(2);
     expect(multiplyByTwo(3)).toBe(6);
@@ -10,3 +10,4 @@ describe('multiplyByTwo', () => {
     expect(multiplyByTwo(125)).toBe(250);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js b/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js
index d444dc1..a3ecf78 100644
--- a/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js
+++ b/src/algorithms/math/bits/__test__/multiplyUnsigned.test.js
@@ -1,7 +1,7 @@
-import multiplyUnsigned from '../multiplyUnsigned';
+import multiplyUnsigned from "../multiplyUnsigned";
 
-describe('multiplyUnsigned', () => {
-  it('should multiply two unsigned numbers', () => {
+describe("multiplyUnsigned", () => {
+  it("should multiply two unsigned numbers", () => {
     expect(multiplyUnsigned(0, 2)).toBe(0);
     expect(multiplyUnsigned(2, 0)).toBe(0);
     expect(multiplyUnsigned(1, 1)).toBe(1);
@@ -13,3 +13,4 @@ describe('multiplyUnsigned', () => {
     expect(multiplyUnsigned(170, 2340)).toBe(397800);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/setBit.test.js b/src/algorithms/math/bits/__test__/setBit.test.js
index d53d60c..7b42e40 100644
--- a/src/algorithms/math/bits/__test__/setBit.test.js
+++ b/src/algorithms/math/bits/__test__/setBit.test.js
@@ -1,7 +1,7 @@
-import setBit from '../setBit';
+import setBit from "../setBit";
 
-describe('setBit', () => {
-  it('should set bit at specific position', () => {
+describe("setBit", () => {
+  it("should set bit at specific position", () => {
     // 1 = 0b0001
     expect(setBit(1, 0)).toBe(1);
     expect(setBit(1, 1)).toBe(3);
@@ -13,3 +13,4 @@ describe('setBit', () => {
     expect(setBit(10, 2)).toBe(14);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/switchSign.test.js b/src/algorithms/math/bits/__test__/switchSign.test.js
index af3f36d..803d52f 100644
--- a/src/algorithms/math/bits/__test__/switchSign.test.js
+++ b/src/algorithms/math/bits/__test__/switchSign.test.js
@@ -1,7 +1,7 @@
-import switchSign from '../switchSign';
+import switchSign from "../switchSign";
 
-describe('switchSign', () => {
-  it('should switch the sign of the number using twos complement approach', () => {
+describe("switchSign", () => {
+  it("should switch the sign of the number using twos complement approach", () => {
     expect(switchSign(0)).toBe(0);
     expect(switchSign(1)).toBe(-1);
     expect(switchSign(-1)).toBe(1);
@@ -11,3 +11,4 @@ describe('switchSign', () => {
     expect(switchSign(-23)).toBe(23);
   });
 });
+
diff --git a/src/algorithms/math/bits/__test__/updateBit.test.js b/src/algorithms/math/bits/__test__/updateBit.test.js
index e2ac2db..858cf4c 100644
--- a/src/algorithms/math/bits/__test__/updateBit.test.js
+++ b/src/algorithms/math/bits/__test__/updateBit.test.js
@@ -1,7 +1,7 @@
-import updateBit from '../updateBit';
+import updateBit from "../updateBit";
 
-describe('updateBit', () => {
-  it('should update bit at specific position', () => {
+describe("updateBit", () => {
+  it("should update bit at specific position", () => {
     // 1 = 0b0001
     expect(updateBit(1, 0, 1)).toBe(1);
     expect(updateBit(1, 0, 0)).toBe(0);
@@ -17,3 +17,4 @@ describe('updateBit', () => {
     expect(updateBit(10, 2, 0)).toBe(10);
   });
 });
+
diff --git a/src/algorithms/math/bits/bitLength.js b/src/algorithms/math/bits/bitLength.js
index 0fc2727..c60dd5d 100644
--- a/src/algorithms/math/bits/bitLength.js
+++ b/src/algorithms/math/bits/bitLength.js
@@ -7,9 +7,10 @@
 export default function bitLength(number) {
   let bitsCounter = 0;
 
-  while ((1 << bitsCounter) <= number) {
+  while (1 << bitsCounter <= number) {
     bitsCounter += 1;
   }
 
   return bitsCounter;
 }
+
diff --git a/src/algorithms/math/bits/bitsDiff.js b/src/algorithms/math/bits/bitsDiff.js
index dbb77b8..6218fb4 100644
--- a/src/algorithms/math/bits/bitsDiff.js
+++ b/src/algorithms/math/bits/bitsDiff.js
@@ -1,4 +1,4 @@
-import countSetBits from './countSetBits';
+import countSetBits from "./countSetBits";
 
 /**
  * Counts the number of bits that need to be change in order
@@ -11,3 +11,4 @@ import countSetBits from './countSetBits';
 export default function bitsDiff(numberA, numberB) {
   return countSetBits(numberA ^ numberB);
 }
+
diff --git a/src/algorithms/math/bits/clearBit.js b/src/algorithms/math/bits/clearBit.js
index 0329a04..55458cd 100644
--- a/src/algorithms/math/bits/clearBit.js
+++ b/src/algorithms/math/bits/clearBit.js
@@ -8,3 +8,4 @@ export default function clearBit(number, bitPosition) {
 
   return number & mask;
 }
+
diff --git a/src/algorithms/math/bits/countSetBits.js b/src/algorithms/math/bits/countSetBits.js
index 63839d4..fdd4c06 100644
--- a/src/algorithms/math/bits/countSetBits.js
+++ b/src/algorithms/math/bits/countSetBits.js
@@ -16,3 +16,4 @@ export default function countSetBits(originalNumber) {
 
   return setBitsCount;
 }
+
diff --git a/src/algorithms/math/bits/divideByTwo.js b/src/algorithms/math/bits/divideByTwo.js
index 359bef9..18e5cc3 100644
--- a/src/algorithms/math/bits/divideByTwo.js
+++ b/src/algorithms/math/bits/divideByTwo.js
@@ -5,3 +5,4 @@
 export default function divideByTwo(number) {
   return number >> 1;
 }
+
diff --git a/src/algorithms/math/bits/fullAdder.js b/src/algorithms/math/bits/fullAdder.js
index 37d74bb..c9e3e99 100644
--- a/src/algorithms/math/bits/fullAdder.js
+++ b/src/algorithms/math/bits/fullAdder.js
@@ -1,4 +1,4 @@
-import getBit from './getBit';
+import getBit from "./getBit";
 
 /**
  * Add two numbers using only binary operators.
@@ -68,3 +68,4 @@ export default function fullAdder(a, b) {
 
   return result;
 }
+
diff --git a/src/algorithms/math/bits/getBit.js b/src/algorithms/math/bits/getBit.js
index 5ff2132..05ce082 100644
--- a/src/algorithms/math/bits/getBit.js
+++ b/src/algorithms/math/bits/getBit.js
@@ -6,3 +6,4 @@
 export default function getBit(number, bitPosition) {
   return (number >> bitPosition) & 1;
 }
+
diff --git a/src/algorithms/math/bits/isEven.js b/src/algorithms/math/bits/isEven.js
index 843b4d2..835bcc4 100644
--- a/src/algorithms/math/bits/isEven.js
+++ b/src/algorithms/math/bits/isEven.js
@@ -5,3 +5,4 @@
 export default function isEven(number) {
   return (number & 1) === 0;
 }
+
diff --git a/src/algorithms/math/bits/isPositive.js b/src/algorithms/math/bits/isPositive.js
index 0e64e8a..6e0dc0d 100644
--- a/src/algorithms/math/bits/isPositive.js
+++ b/src/algorithms/math/bits/isPositive.js
@@ -11,3 +11,4 @@ export default function isPositive(number) {
   // The most significant 32nd bit can be used to determine whether the number is positive.
   return ((number >> 31) & 1) === 0;
 }
+
diff --git a/src/algorithms/math/bits/isPowerOfTwo.js b/src/algorithms/math/bits/isPowerOfTwo.js
index 28e3e67..0850569 100644
--- a/src/algorithms/math/bits/isPowerOfTwo.js
+++ b/src/algorithms/math/bits/isPowerOfTwo.js
@@ -5,3 +5,4 @@
 export default function isPowerOfTwo(number) {
   return (number & (number - 1)) === 0;
 }
+
diff --git a/src/algorithms/math/bits/multiply.js b/src/algorithms/math/bits/multiply.js
index da952f4..09b742e 100644
--- a/src/algorithms/math/bits/multiply.js
+++ b/src/algorithms/math/bits/multiply.js
@@ -1,7 +1,7 @@
-import multiplyByTwo from './multiplyByTwo';
-import divideByTwo from './divideByTwo';
-import isEven from './isEven';
-import isPositive from './isPositive';
+import multiplyByTwo from "./multiplyByTwo";
+import divideByTwo from "./divideByTwo";
+import isEven from "./isEven";
+import isPositive from "./isPositive";
 
 /**
  * Multiply two signed numbers using bitwise operations.
@@ -31,11 +31,15 @@ export default function multiply(a, b) {
   }
 
   // Otherwise we will have four different cases that are described above.
-  const multiplyByOddPositive = () => multiply(multiplyByTwo(a), divideByTwo(b - 1)) + a;
-  const multiplyByOddNegative = () => multiply(multiplyByTwo(a), divideByTwo(b + 1)) - a;
+  const multiplyByOddPositive = () =>
+    multiply(multiplyByTwo(a), divideByTwo(b - 1)) + a;
+  const multiplyByOddNegative = () =>
+    multiply(multiplyByTwo(a), divideByTwo(b + 1)) - a;
 
   const multiplyByEven = () => multiply(multiplyByTwo(a), divideByTwo(b));
-  const multiplyByOdd = () => (isPositive(b) ? multiplyByOddPositive() : multiplyByOddNegative());
+  const multiplyByOdd = () =>
+    isPositive(b) ? multiplyByOddPositive() : multiplyByOddNegative();
 
   return isEven(b) ? multiplyByEven() : multiplyByOdd();
 }
+
diff --git a/src/algorithms/math/bits/multiplyByTwo.js b/src/algorithms/math/bits/multiplyByTwo.js
index 3e52544..48db365 100644
--- a/src/algorithms/math/bits/multiplyByTwo.js
+++ b/src/algorithms/math/bits/multiplyByTwo.js
@@ -5,3 +5,4 @@
 export default function multiplyByTwo(number) {
   return number << 1;
 }
+
diff --git a/src/algorithms/math/bits/multiplyUnsigned.js b/src/algorithms/math/bits/multiplyUnsigned.js
index 17a2c95..99df766 100644
--- a/src/algorithms/math/bits/multiplyUnsigned.js
+++ b/src/algorithms/math/bits/multiplyUnsigned.js
@@ -32,7 +32,7 @@ export default function multiplyUnsigned(number1, number2) {
       // In case if multiplier's bit at position bitIndex is set
       // it would mean that we need to multiply number1 by the power
       // of bit with index bitIndex and then add it to the result.
-      result += (number1 << bitIndex);
+      result += number1 << bitIndex;
     }
 
     bitIndex += 1;
@@ -41,3 +41,4 @@ export default function multiplyUnsigned(number1, number2) {
 
   return result;
 }
+
diff --git a/src/algorithms/math/bits/setBit.js b/src/algorithms/math/bits/setBit.js
index c574ac6..881cd5c 100644
--- a/src/algorithms/math/bits/setBit.js
+++ b/src/algorithms/math/bits/setBit.js
@@ -6,3 +6,4 @@
 export default function setBit(number, bitPosition) {
   return number | (1 << bitPosition);
 }
+
diff --git a/src/algorithms/math/bits/switchSign.js b/src/algorithms/math/bits/switchSign.js
index e38ec48..abd2b3a 100644
--- a/src/algorithms/math/bits/switchSign.js
+++ b/src/algorithms/math/bits/switchSign.js
@@ -6,3 +6,4 @@
 export default function switchSign(number) {
   return ~number + 1;
 }
+
diff --git a/src/algorithms/math/bits/updateBit.js b/src/algorithms/math/bits/updateBit.js
index f56834a..dc529fe 100644
--- a/src/algorithms/math/bits/updateBit.js
+++ b/src/algorithms/math/bits/updateBit.js
@@ -14,3 +14,4 @@ export default function updateBit(number, bitPosition, bitValue) {
   // Clear bit value and then set it up to required value.
   return (number & clearMask) | (bitValueNormalized << bitPosition);
 }
+
diff --git a/src/algorithms/math/complex-number/ComplexNumber.js b/src/algorithms/math/complex-number/ComplexNumber.js
index 9e8ffa5..379ca53 100644
--- a/src/algorithms/math/complex-number/ComplexNumber.js
+++ b/src/algorithms/math/complex-number/ComplexNumber.js
@@ -1,4 +1,4 @@
-import radianToDegree from '../radian/radianToDegree';
+import radianToDegree from "../radian/radianToDegree";
 
 export default class ComplexNumber {
   /**
@@ -8,7 +8,13 @@ export default class ComplexNumber {
    * @param {number} [re]
    * @param {number} [im]
    */
-  constructor({ re = 0, im = 0 } = {}) {
+  constructor() {
+    let _ref =
+        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+      _ref$re = _ref.re,
+      re = _ref$re === void 0 ? 0 : _ref$re,
+      _ref$im = _ref.im,
+      im = _ref$im === void 0 ? 0 : _ref$im;
     this.re = re;
     this.im = im;
   }
@@ -70,7 +76,7 @@ export default class ComplexNumber {
     const finalDivident = this.multiply(dividerConjugate);
 
     // Calculating final divider using formula (a + bi)(a − bi) = a^2 + b^2
-    const finalDivider = (complexDivider.re ** 2) + (complexDivider.im ** 2);
+    const finalDivider = complexDivider.re ** 2 + complexDivider.im ** 2;
 
     return new ComplexNumber({
       re: finalDivident.re / finalDivider,
@@ -95,14 +101,16 @@ export default class ComplexNumber {
    * @return {number}
    */
   getRadius() {
-    return Math.sqrt((this.re ** 2) + (this.im ** 2));
+    return Math.sqrt(this.re ** 2 + this.im ** 2);
   }
 
   /**
    * @param {boolean} [inRadians]
    * @return {number}
    */
-  getPhase(inRadians = true) {
+  getPhase() {
+    let inRadians =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
     let phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));
 
     if (this.re < 0 && this.im > 0) {
@@ -136,7 +144,9 @@ export default class ComplexNumber {
    * @param {boolean} [inRadians]
    * @return {{radius: number, phase: number}}
    */
-  getPolarForm(inRadians = true) {
+  getPolarForm() {
+    let inRadians =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
     return {
       radius: this.getRadius(),
       phase: this.getPhase(inRadians),
@@ -158,3 +168,4 @@ export default class ComplexNumber {
     return new ComplexNumber({ re: number });
   }
 }
+
diff --git a/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js b/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js
index 4392103..a0f9575 100644
--- a/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js
+++ b/src/algorithms/math/complex-number/__test__/ComplexNumber.test.js
@@ -1,7 +1,7 @@
-import ComplexNumber from '../ComplexNumber';
+import ComplexNumber from "../ComplexNumber";
 
-describe('ComplexNumber', () => {
-  it('should create complex numbers', () => {
+describe("ComplexNumber", () => {
+  it("should create complex numbers", () => {
     const complexNumber = new ComplexNumber({ re: 1, im: 2 });
 
     expect(complexNumber).toBeDefined();
@@ -13,7 +13,7 @@ describe('ComplexNumber', () => {
     expect(defaultComplexNumber.im).toBe(0);
   });
 
-  it('should add complex numbers', () => {
+  it("should add complex numbers", () => {
     const complexNumber1 = new ComplexNumber({ re: 1, im: 2 });
     const complexNumber2 = new ComplexNumber({ re: 3, im: 8 });
 
@@ -27,7 +27,7 @@ describe('ComplexNumber', () => {
     expect(complexNumber4.im).toBe(2 + 8);
   });
 
-  it('should add complex and natural numbers', () => {
+  it("should add complex and natural numbers", () => {
     const complexNumber = new ComplexNumber({ re: 1, im: 2 });
     const realNumber = new ComplexNumber({ re: 3 });
 
@@ -45,7 +45,7 @@ describe('ComplexNumber', () => {
     expect(complexNumber5.im).toBe(2);
   });
 
-  it('should subtract complex numbers', () => {
+  it("should subtract complex numbers", () => {
     const complexNumber1 = new ComplexNumber({ re: 1, im: 2 });
     const complexNumber2 = new ComplexNumber({ re: 3, im: 8 });
 
@@ -59,7 +59,7 @@ describe('ComplexNumber', () => {
     expect(complexNumber4.im).toBe(8 - 2);
   });
 
-  it('should subtract complex and natural numbers', () => {
+  it("should subtract complex and natural numbers", () => {
     const complexNumber = new ComplexNumber({ re: 1, im: 2 });
     const realNumber = new ComplexNumber({ re: 3 });
 
@@ -77,7 +77,7 @@ describe('ComplexNumber', () => {
     expect(complexNumber5.im).toBe(2);
   });
 
-  it('should multiply complex numbers', () => {
+  it("should multiply complex numbers", () => {
     const complexNumber1 = new ComplexNumber({ re: 3, im: 2 });
     const complexNumber2 = new ComplexNumber({ re: 1, im: 7 });
 
@@ -95,7 +95,7 @@ describe('ComplexNumber', () => {
     expect(complexNumber5.im).toBe(10);
   });
 
-  it('should multiply complex numbers by themselves', () => {
+  it("should multiply complex numbers by themselves", () => {
     const complexNumber = new ComplexNumber({ re: 1, im: 1 });
 
     const result = complexNumber.multiply(complexNumber);
@@ -104,7 +104,7 @@ describe('ComplexNumber', () => {
     expect(result.im).toBe(2);
   });
 
-  it('should calculate i in power of two', () => {
+  it("should calculate i in power of two", () => {
     const complexNumber = new ComplexNumber({ re: 0, im: 1 });
 
     const result = complexNumber.multiply(complexNumber);
@@ -113,7 +113,7 @@ describe('ComplexNumber', () => {
     expect(result.im).toBe(0);
   });
 
-  it('should divide complex numbers', () => {
+  it("should divide complex numbers", () => {
     const complexNumber1 = new ComplexNumber({ re: 2, im: 3 });
     const complexNumber2 = new ComplexNumber({ re: 4, im: -5 });
 
@@ -127,29 +127,37 @@ describe('ComplexNumber', () => {
     expect(complexNumber4.im).toBe(1.5);
   });
 
-  it('should return complex number in polar form', () => {
+  it("should return complex number in polar form", () => {
     const complexNumber1 = new ComplexNumber({ re: 3, im: 3 });
-    expect(complexNumber1.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
+    expect(complexNumber1.getPolarForm().radius).toBe(
+      Math.sqrt(3 ** 2 + 3 ** 2)
+    );
     expect(complexNumber1.getPolarForm().phase).toBe(Math.PI / 4);
     expect(complexNumber1.getPolarForm(false).phase).toBe(45);
 
     const complexNumber2 = new ComplexNumber({ re: -3, im: 3 });
-    expect(complexNumber2.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
+    expect(complexNumber2.getPolarForm().radius).toBe(
+      Math.sqrt(3 ** 2 + 3 ** 2)
+    );
     expect(complexNumber2.getPolarForm().phase).toBe(3 * (Math.PI / 4));
     expect(complexNumber2.getPolarForm(false).phase).toBe(135);
 
     const complexNumber3 = new ComplexNumber({ re: -3, im: -3 });
-    expect(complexNumber3.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
+    expect(complexNumber3.getPolarForm().radius).toBe(
+      Math.sqrt(3 ** 2 + 3 ** 2)
+    );
     expect(complexNumber3.getPolarForm().phase).toBe(-3 * (Math.PI / 4));
     expect(complexNumber3.getPolarForm(false).phase).toBe(-135);
 
     const complexNumber4 = new ComplexNumber({ re: 3, im: -3 });
-    expect(complexNumber4.getPolarForm().radius).toBe(Math.sqrt((3 ** 2) + (3 ** 2)));
+    expect(complexNumber4.getPolarForm().radius).toBe(
+      Math.sqrt(3 ** 2 + 3 ** 2)
+    );
     expect(complexNumber4.getPolarForm().phase).toBe(-1 * (Math.PI / 4));
     expect(complexNumber4.getPolarForm(false).phase).toBe(-45);
 
     const complexNumber5 = new ComplexNumber({ re: 5, im: 7 });
-    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.60);
+    expect(complexNumber5.getPolarForm().radius).toBeCloseTo(8.6);
     expect(complexNumber5.getPolarForm().phase).toBeCloseTo(0.95);
     expect(complexNumber5.getPolarForm(false).phase).toBeCloseTo(54.46);
 
@@ -179,3 +187,4 @@ describe('ComplexNumber', () => {
     expect(complexNumber10.getPolarForm(false).phase).toBeCloseTo(0);
   });
 });
+
diff --git a/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js b/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js
index bbf92b2..843ac08 100644
--- a/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js
+++ b/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithm.test.js
@@ -1,7 +1,7 @@
-import euclideanAlgorithm from '../euclideanAlgorithm';
+import euclideanAlgorithm from "../euclideanAlgorithm";
 
-describe('euclideanAlgorithm', () => {
-  it('should calculate GCD recursively', () => {
+describe("euclideanAlgorithm", () => {
+  it("should calculate GCD recursively", () => {
     expect(euclideanAlgorithm(0, 0)).toBe(0);
     expect(euclideanAlgorithm(2, 0)).toBe(2);
     expect(euclideanAlgorithm(0, 2)).toBe(2);
@@ -24,3 +24,4 @@ describe('euclideanAlgorithm', () => {
     expect(euclideanAlgorithm(-462, -1071)).toBe(21);
   });
 });
+
diff --git a/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js b/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js
index 5fd0f84..ba7599d 100644
--- a/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js
+++ b/src/algorithms/math/euclidean-algorithm/__test__/euclideanAlgorithmIterative.test.js
@@ -1,7 +1,7 @@
-import euclideanAlgorithmIterative from '../euclideanAlgorithmIterative';
+import euclideanAlgorithmIterative from "../euclideanAlgorithmIterative";
 
-describe('euclideanAlgorithmIterative', () => {
-  it('should calculate GCD iteratively', () => {
+describe("euclideanAlgorithmIterative", () => {
+  it("should calculate GCD iteratively", () => {
     expect(euclideanAlgorithmIterative(0, 0)).toBe(0);
     expect(euclideanAlgorithmIterative(2, 0)).toBe(2);
     expect(euclideanAlgorithmIterative(0, 2)).toBe(2);
@@ -24,3 +24,4 @@ describe('euclideanAlgorithmIterative', () => {
     expect(euclideanAlgorithmIterative(-462, -1071)).toBe(21);
   });
 });
+
diff --git a/src/algorithms/math/euclidean-algorithm/euclideanAlgorithm.js b/src/algorithms/math/euclidean-algorithm/euclideanAlgorithm.js
index b9cec97..b791ddf 100644
--- a/src/algorithms/math/euclidean-algorithm/euclideanAlgorithm.js
+++ b/src/algorithms/math/euclidean-algorithm/euclideanAlgorithm.js
@@ -11,5 +11,6 @@ export default function euclideanAlgorithm(originalA, originalB) {
 
   // To make algorithm work faster instead of subtracting one number from the other
   // we may use modulo operation.
-  return (b === 0) ? a : euclideanAlgorithm(b, a % b);
+  return b === 0 ? a : euclideanAlgorithm(b, a % b);
 }
+
diff --git a/src/algorithms/math/euclidean-algorithm/euclideanAlgorithmIterative.js b/src/algorithms/math/euclidean-algorithm/euclideanAlgorithmIterative.js
index 302b5bf..d486e5f 100644
--- a/src/algorithms/math/euclidean-algorithm/euclideanAlgorithmIterative.js
+++ b/src/algorithms/math/euclidean-algorithm/euclideanAlgorithmIterative.js
@@ -1,3 +1,61 @@
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
 /**
  * Iterative version of Euclidean Algorithm of finding greatest common divisor (GCD).
  * @param {number} originalA
@@ -12,9 +70,13 @@ export default function euclideanAlgorithmIterative(originalA, originalB) {
   // Subtract one number from another until both numbers would become the same.
   // This will be out GCD. Also quit the loop if one of the numbers is zero.
   while (a && b && a !== b) {
-    [a, b] = a > b ? [a - b, b] : [a, b - a];
+    var _ref = a > b ? [a - b, b] : [a, b - a];
+    var _ref2 = _slicedToArray(_ref, 2);
+    a = _ref2[0];
+    b = _ref2[1];
   }
 
   // Return the number that is not equal to zero since the last subtraction (it will be a GCD).
   return a || b;
 }
+
diff --git a/src/algorithms/math/euclidean-distance/__tests__/euclideanDistance.test.js b/src/algorithms/math/euclidean-distance/__tests__/euclideanDistance.test.js
index 78d7d8d..64d86f3 100644
--- a/src/algorithms/math/euclidean-distance/__tests__/euclideanDistance.test.js
+++ b/src/algorithms/math/euclidean-distance/__tests__/euclideanDistance.test.js
@@ -1,23 +1,26 @@
-import euclideanDistance from '../euclideanDistance';
+import euclideanDistance from "../euclideanDistance";
 
-describe('euclideanDistance', () => {
-  it('should calculate euclidean distance between vectors', () => {
+describe("euclideanDistance", () => {
+  it("should calculate euclidean distance between vectors", () => {
     expect(euclideanDistance([[1]], [[2]])).toEqual(1);
     expect(euclideanDistance([[2]], [[1]])).toEqual(1);
     expect(euclideanDistance([[5, 8]], [[7, 3]])).toEqual(5.39);
     expect(euclideanDistance([[5], [8]], [[7], [3]])).toEqual(5.39);
     expect(euclideanDistance([[8, 2, 6]], [[3, 5, 7]])).toEqual(5.92);
     expect(euclideanDistance([[8], [2], [6]], [[3], [5], [7]])).toEqual(5.92);
-    expect(euclideanDistance([[[8]], [[2]], [[6]]], [[[3]], [[5]], [[7]]])).toEqual(5.92);
+    expect(
+      euclideanDistance([[[8]], [[2]], [[6]]], [[[3]], [[5]], [[7]]])
+    ).toEqual(5.92);
   });
 
-  it('should throw an error in case if two matrices are of different shapes', () => {
+  it("should throw an error in case if two matrices are of different shapes", () => {
     expect(() => euclideanDistance([[1]], [[[2]]])).toThrowError(
-      'Matrices have different dimensions',
+      "Matrices have different dimensions"
     );
 
     expect(() => euclideanDistance([[1]], [[2, 3]])).toThrowError(
-      'Matrices have different shapes',
+      "Matrices have different shapes"
     );
   });
 });
+
diff --git a/src/algorithms/math/euclidean-distance/euclideanDistance.js b/src/algorithms/math/euclidean-distance/euclideanDistance.js
index afa5c2f..8a4aaea 100644
--- a/src/algorithms/math/euclidean-distance/euclideanDistance.js
+++ b/src/algorithms/math/euclidean-distance/euclideanDistance.js
@@ -2,7 +2,7 @@
  * @typedef {import('../matrix/Matrix.js').Matrix} Matrix
  */
 
-import * as mtrx from '../matrix/Matrix';
+import * as mtrx from "../matrix/Matrix";
 
 /**
  * Calculates the euclidean distance between 2 matrices.
@@ -26,3 +26,4 @@ const euclideanDistance = (a, b) => {
 };
 
 export default euclideanDistance;
+
diff --git a/src/algorithms/math/factorial/__test__/factorial.test.js b/src/algorithms/math/factorial/__test__/factorial.test.js
index bf6aa0e..7256788 100644
--- a/src/algorithms/math/factorial/__test__/factorial.test.js
+++ b/src/algorithms/math/factorial/__test__/factorial.test.js
@@ -1,7 +1,7 @@
-import factorial from '../factorial';
+import factorial from "../factorial";
 
-describe('factorial', () => {
-  it('should calculate factorial', () => {
+describe("factorial", () => {
+  it("should calculate factorial", () => {
     expect(factorial(0)).toBe(1);
     expect(factorial(1)).toBe(1);
     expect(factorial(5)).toBe(120);
@@ -9,3 +9,4 @@ describe('factorial', () => {
     expect(factorial(10)).toBe(3628800);
   });
 });
+
diff --git a/src/algorithms/math/factorial/__test__/factorialRecursive.test.js b/src/algorithms/math/factorial/__test__/factorialRecursive.test.js
index 9029fae..89b5bcb 100644
--- a/src/algorithms/math/factorial/__test__/factorialRecursive.test.js
+++ b/src/algorithms/math/factorial/__test__/factorialRecursive.test.js
@@ -1,7 +1,7 @@
-import factorialRecursive from '../factorialRecursive';
+import factorialRecursive from "../factorialRecursive";
 
-describe('factorialRecursive', () => {
-  it('should calculate factorial', () => {
+describe("factorialRecursive", () => {
+  it("should calculate factorial", () => {
     expect(factorialRecursive(0)).toBe(1);
     expect(factorialRecursive(1)).toBe(1);
     expect(factorialRecursive(5)).toBe(120);
@@ -9,3 +9,4 @@ describe('factorialRecursive', () => {
     expect(factorialRecursive(10)).toBe(3628800);
   });
 });
+
diff --git a/src/algorithms/math/factorial/factorial.js b/src/algorithms/math/factorial/factorial.js
index 6c717d0..924a39f 100644
--- a/src/algorithms/math/factorial/factorial.js
+++ b/src/algorithms/math/factorial/factorial.js
@@ -11,3 +11,4 @@ export default function factorial(number) {
 
   return result;
 }
+
diff --git a/src/algorithms/math/factorial/factorialRecursive.js b/src/algorithms/math/factorial/factorialRecursive.js
index e2b4aec..a2c1b2a 100644
--- a/src/algorithms/math/factorial/factorialRecursive.js
+++ b/src/algorithms/math/factorial/factorialRecursive.js
@@ -5,3 +5,4 @@
 export default function factorialRecursive(number) {
   return number > 1 ? number * factorialRecursive(number - 1) : 1;
 }
+
diff --git a/src/algorithms/math/fast-powering/__test__/fastPowering.test.js b/src/algorithms/math/fast-powering/__test__/fastPowering.test.js
index 0a5da75..63b0b47 100644
--- a/src/algorithms/math/fast-powering/__test__/fastPowering.test.js
+++ b/src/algorithms/math/fast-powering/__test__/fastPowering.test.js
@@ -1,7 +1,7 @@
-import fastPowering from '../fastPowering';
+import fastPowering from "../fastPowering";
 
-describe('fastPowering', () => {
-  it('should compute power in log(n) time', () => {
+describe("fastPowering", () => {
+  it("should compute power in log(n) time", () => {
     expect(fastPowering(1, 1)).toBe(1);
     expect(fastPowering(2, 0)).toBe(1);
     expect(fastPowering(2, 2)).toBe(4);
@@ -21,3 +21,4 @@ describe('fastPowering', () => {
     expect(fastPowering(100, 9)).toBe(1000000000000000000);
   });
 });
+
diff --git a/src/algorithms/math/fast-powering/fastPowering.js b/src/algorithms/math/fast-powering/fastPowering.js
index 4f4a6b3..b269892 100644
--- a/src/algorithms/math/fast-powering/fastPowering.js
+++ b/src/algorithms/math/fast-powering/fastPowering.js
@@ -28,3 +28,4 @@ export default function fastPowering(base, power) {
   const multiplier = fastPowering(base, Math.floor(power / 2));
   return multiplier * multiplier * base;
 }
+
diff --git a/src/algorithms/math/fibonacci/__test__/fibonacci.test.js b/src/algorithms/math/fibonacci/__test__/fibonacci.test.js
index ffbee8d..bd52041 100644
--- a/src/algorithms/math/fibonacci/__test__/fibonacci.test.js
+++ b/src/algorithms/math/fibonacci/__test__/fibonacci.test.js
@@ -1,7 +1,7 @@
-import fibonacci from '../fibonacci';
+import fibonacci from "../fibonacci";
 
-describe('fibonacci', () => {
-  it('should calculate fibonacci correctly', () => {
+describe("fibonacci", () => {
+  it("should calculate fibonacci correctly", () => {
     expect(fibonacci(1)).toEqual([1]);
     expect(fibonacci(2)).toEqual([1, 1]);
     expect(fibonacci(3)).toEqual([1, 1, 2]);
@@ -14,3 +14,4 @@ describe('fibonacci', () => {
     expect(fibonacci(10)).toEqual([1, 1, 2, 3, 5, 8, 13, 21, 34, 55]);
   });
 });
+
diff --git a/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js b/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js
index 4a098eb..12d2066 100644
--- a/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js
+++ b/src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js
@@ -1,7 +1,7 @@
-import fibonacciNth from '../fibonacciNth';
+import fibonacciNth from "../fibonacciNth";
 
-describe('fibonacciNth', () => {
-  it('should calculate fibonacci correctly', () => {
+describe("fibonacciNth", () => {
+  it("should calculate fibonacci correctly", () => {
     expect(fibonacciNth(1)).toBe(1);
     expect(fibonacciNth(2)).toBe(1);
     expect(fibonacciNth(3)).toBe(2);
@@ -21,3 +21,4 @@ describe('fibonacciNth', () => {
     expect(fibonacciNth(75)).toBe(2111485077978050);
   });
 });
+
diff --git a/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js b/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js
index 4828ef5..ec8f714 100644
--- a/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js
+++ b/src/algorithms/math/fibonacci/__test__/fibonacciNthClosedForm.test.js
@@ -1,7 +1,7 @@
-import fibonacciNthClosedForm from '../fibonacciNthClosedForm';
+import fibonacciNthClosedForm from "../fibonacciNthClosedForm";
 
-describe('fibonacciClosedForm', () => {
-  it('should throw an error when trying to calculate fibonacci for not allowed positions', () => {
+describe("fibonacciClosedForm", () => {
+  it("should throw an error when trying to calculate fibonacci for not allowed positions", () => {
     const calculateFibonacciForNotAllowedPosition = () => {
       fibonacciNthClosedForm(76);
     };
@@ -9,7 +9,7 @@ describe('fibonacciClosedForm', () => {
     expect(calculateFibonacciForNotAllowedPosition).toThrow();
   });
 
-  it('should calculate fibonacci correctly', () => {
+  it("should calculate fibonacci correctly", () => {
     expect(fibonacciNthClosedForm(1)).toBe(1);
     expect(fibonacciNthClosedForm(2)).toBe(1);
     expect(fibonacciNthClosedForm(3)).toBe(2);
@@ -24,3 +24,4 @@ describe('fibonacciClosedForm', () => {
     expect(fibonacciNthClosedForm(70)).toBe(190392490709135);
   });
 });
+
diff --git a/src/algorithms/math/fibonacci/fibonacci.js b/src/algorithms/math/fibonacci/fibonacci.js
index 4caa1d9..dae05fc 100644
--- a/src/algorithms/math/fibonacci/fibonacci.js
+++ b/src/algorithms/math/fibonacci/fibonacci.js
@@ -27,3 +27,4 @@ export default function fibonacci(n) {
 
   return fibSequence;
 }
+
diff --git a/src/algorithms/math/fibonacci/fibonacciNth.js b/src/algorithms/math/fibonacci/fibonacciNth.js
index 7292244..a2df6cc 100644
--- a/src/algorithms/math/fibonacci/fibonacciNth.js
+++ b/src/algorithms/math/fibonacci/fibonacciNth.js
@@ -23,3 +23,4 @@ export default function fibonacciNth(n) {
 
   return currentValue;
 }
+
diff --git a/src/algorithms/math/fibonacci/fibonacciNthClosedForm.js b/src/algorithms/math/fibonacci/fibonacciNthClosedForm.js
index e2a2a36..92260f5 100644
--- a/src/algorithms/math/fibonacci/fibonacciNthClosedForm.js
+++ b/src/algorithms/math/fibonacci/fibonacciNthClosedForm.js
@@ -10,7 +10,9 @@ export default function fibonacciClosedForm(position) {
 
   // Check that position is valid.
   if (position < 1 || position > topMaxValidPosition) {
-    throw new Error(`Can't handle position smaller than 1 or greater than ${topMaxValidPosition}`);
+    throw new Error(
+      `Can't handle position smaller than 1 or greater than ${topMaxValidPosition}`
+    );
   }
 
   // Calculate √5 to re-use it in further formulas.
@@ -19,5 +21,6 @@ export default function fibonacciClosedForm(position) {
   const phi = (1 + sqrt5) / 2;
 
   // Calculate fibonacci number using Binet's formula.
-  return Math.floor((phi ** position) / sqrt5 + 0.5);
+  return Math.floor(phi ** position / sqrt5 + 0.5);
 }
+
diff --git a/src/algorithms/math/fourier-transform/__test__/FourierTester.js b/src/algorithms/math/fourier-transform/__test__/FourierTester.js
index d2a2787..c10aca5 100644
--- a/src/algorithms/math/fourier-transform/__test__/FourierTester.js
+++ b/src/algorithms/math/fourier-transform/__test__/FourierTester.js
@@ -1,62 +1,94 @@
-import ComplexNumber from '../../complex-number/ComplexNumber';
+import ComplexNumber from "../../complex-number/ComplexNumber";
 
 export const fourierTestCases = [
   {
-    input: [
-      { amplitude: 1 },
-    ],
+    input: [{ amplitude: 1 }],
+
     output: [
       {
-        frequency: 0, amplitude: 1, phase: 0, re: 1, im: 0,
+        frequency: 0,
+        amplitude: 1,
+        phase: 0,
+        re: 1,
+        im: 0,
       },
     ],
   },
+
   {
-    input: [
-      { amplitude: 1 },
-      { amplitude: 0 },
-    ],
+    input: [{ amplitude: 1 }, { amplitude: 0 }],
+
     output: [
       {
-        frequency: 0, amplitude: 0.5, phase: 0, re: 0.5, im: 0,
+        frequency: 0,
+        amplitude: 0.5,
+        phase: 0,
+        re: 0.5,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.5, phase: 0, re: 0.5, im: 0,
+        frequency: 1,
+        amplitude: 0.5,
+        phase: 0,
+        re: 0.5,
+        im: 0,
       },
     ],
   },
+
   {
-    input: [
-      { amplitude: 2 },
-      { amplitude: 0 },
-    ],
+    input: [{ amplitude: 2 }, { amplitude: 0 }],
+
     output: [
       {
-        frequency: 0, amplitude: 1, phase: 0, re: 1, im: 0,
+        frequency: 0,
+        amplitude: 1,
+        phase: 0,
+        re: 1,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 1, phase: 0, re: 1, im: 0,
+        frequency: 1,
+        amplitude: 1,
+        phase: 0,
+        re: 1,
+        im: 0,
       },
     ],
   },
+
   {
-    input: [
-      { amplitude: 1 },
-      { amplitude: 0 },
-      { amplitude: 0 },
-    ],
+    input: [{ amplitude: 1 }, { amplitude: 0 }, { amplitude: 0 }],
+
     output: [
       {
-        frequency: 0, amplitude: 0.33333, phase: 0, re: 0.33333, im: 0,
+        frequency: 0,
+        amplitude: 0.33333,
+        phase: 0,
+        re: 0.33333,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.33333, phase: 0, re: 0.33333, im: 0,
+        frequency: 1,
+        amplitude: 0.33333,
+        phase: 0,
+        re: 0.33333,
+        im: 0,
       },
+
       {
-        frequency: 2, amplitude: 0.33333, phase: 0, re: 0.33333, im: 0,
+        frequency: 2,
+        amplitude: 0.33333,
+        phase: 0,
+        re: 0.33333,
+        im: 0,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 1 },
@@ -64,21 +96,42 @@ export const fourierTestCases = [
       { amplitude: 0 },
       { amplitude: 0 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 0,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 1,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 2, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 2,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 3,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 0 },
@@ -86,21 +139,42 @@ export const fourierTestCases = [
       { amplitude: 0 },
       { amplitude: 0 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 0,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.25, phase: -90, re: 0, im: -0.25,
+        frequency: 1,
+        amplitude: 0.25,
+        phase: -90,
+        re: 0,
+        im: -0.25,
       },
+
       {
-        frequency: 2, amplitude: 0.25, phase: 180, re: -0.25, im: 0,
+        frequency: 2,
+        amplitude: 0.25,
+        phase: 180,
+        re: -0.25,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 0.25, phase: 90, re: 0, im: 0.25,
+        frequency: 3,
+        amplitude: 0.25,
+        phase: 90,
+        re: 0,
+        im: 0.25,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 0 },
@@ -108,21 +182,42 @@ export const fourierTestCases = [
       { amplitude: 1 },
       { amplitude: 0 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 0,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.25, phase: 180, re: -0.25, im: 0,
+        frequency: 1,
+        amplitude: 0.25,
+        phase: 180,
+        re: -0.25,
+        im: 0,
       },
+
       {
-        frequency: 2, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 2,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 0.25, phase: 180, re: -0.25, im: 0,
+        frequency: 3,
+        amplitude: 0.25,
+        phase: 180,
+        re: -0.25,
+        im: 0,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 0 },
@@ -130,21 +225,42 @@ export const fourierTestCases = [
       { amplitude: 0 },
       { amplitude: 2 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 0.5, phase: 0, re: 0.5, im: 0,
+        frequency: 0,
+        amplitude: 0.5,
+        phase: 0,
+        re: 0.5,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.5, phase: 90, re: 0, im: 0.5,
+        frequency: 1,
+        amplitude: 0.5,
+        phase: 90,
+        re: 0,
+        im: 0.5,
       },
+
       {
-        frequency: 2, amplitude: 0.5, phase: 180, re: -0.5, im: 0,
+        frequency: 2,
+        amplitude: 0.5,
+        phase: 180,
+        re: -0.5,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 0.5, phase: -90, re: 0, im: -0.5,
+        frequency: 3,
+        amplitude: 0.5,
+        phase: -90,
+        re: 0,
+        im: -0.5,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 0 },
@@ -152,21 +268,42 @@ export const fourierTestCases = [
       { amplitude: 0 },
       { amplitude: 2 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 0.75, phase: 0, re: 0.75, im: 0,
+        frequency: 0,
+        amplitude: 0.75,
+        phase: 0,
+        re: 0.75,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.25, phase: 90, re: 0, im: 0.25,
+        frequency: 1,
+        amplitude: 0.25,
+        phase: 90,
+        re: 0,
+        im: 0.25,
       },
+
       {
-        frequency: 2, amplitude: 0.75, phase: 180, re: -0.75, im: 0,
+        frequency: 2,
+        amplitude: 0.75,
+        phase: 180,
+        re: -0.75,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 0.25, phase: -90, re: 0, im: -0.25,
+        frequency: 3,
+        amplitude: 0.25,
+        phase: -90,
+        re: 0,
+        im: -0.25,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 4 },
@@ -174,21 +311,42 @@ export const fourierTestCases = [
       { amplitude: 0 },
       { amplitude: 2 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 1.75, phase: 0, re: 1.75, im: 0,
+        frequency: 0,
+        amplitude: 1.75,
+        phase: 0,
+        re: 1.75,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 1.03077, phase: 14.03624, re: 0.99999, im: 0.25,
+        frequency: 1,
+        amplitude: 1.03077,
+        phase: 14.03624,
+        re: 0.99999,
+        im: 0.25,
       },
+
       {
-        frequency: 2, amplitude: 0.25, phase: 0, re: 0.25, im: 0,
+        frequency: 2,
+        amplitude: 0.25,
+        phase: 0,
+        re: 0.25,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 1.03077, phase: -14.03624, re: 1, im: -0.25,
+        frequency: 3,
+        amplitude: 1.03077,
+        phase: -14.03624,
+        re: 1,
+        im: -0.25,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 4 },
@@ -196,21 +354,42 @@ export const fourierTestCases = [
       { amplitude: -3 },
       { amplitude: 2 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 1, phase: 0, re: 1, im: 0,
+        frequency: 0,
+        amplitude: 1,
+        phase: 0,
+        re: 1,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 1.76776, phase: 8.13010, re: 1.75, im: 0.25,
+        frequency: 1,
+        amplitude: 1.76776,
+        phase: 8.1301,
+        re: 1.75,
+        im: 0.25,
       },
+
       {
-        frequency: 2, amplitude: 0.5, phase: 180, re: -0.5, im: 0,
+        frequency: 2,
+        amplitude: 0.5,
+        phase: 180,
+        re: -0.5,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 1.76776, phase: -8.13010, re: 1.75, im: -0.24999,
+        frequency: 3,
+        amplitude: 1.76776,
+        phase: -8.1301,
+        re: 1.75,
+        im: -0.24999,
       },
     ],
   },
+
   {
     input: [
       { amplitude: 1 },
@@ -218,18 +397,38 @@ export const fourierTestCases = [
       { amplitude: 3 },
       { amplitude: 4 },
     ],
+
     output: [
       {
-        frequency: 0, amplitude: 2.5, phase: 0, re: 2.5, im: 0,
+        frequency: 0,
+        amplitude: 2.5,
+        phase: 0,
+        re: 2.5,
+        im: 0,
       },
+
       {
-        frequency: 1, amplitude: 0.70710, phase: 135, re: -0.5, im: 0.49999,
+        frequency: 1,
+        amplitude: 0.7071,
+        phase: 135,
+        re: -0.5,
+        im: 0.49999,
       },
+
       {
-        frequency: 2, amplitude: 0.5, phase: 180, re: -0.5, im: 0,
+        frequency: 2,
+        amplitude: 0.5,
+        phase: 180,
+        re: -0.5,
+        im: 0,
       },
+
       {
-        frequency: 3, amplitude: 0.70710, phase: -134.99999, re: -0.49999, im: -0.5,
+        frequency: 3,
+        amplitude: 0.7071,
+        phase: -134.99999,
+        re: -0.49999,
+        im: -0.5,
       },
     ],
   },
@@ -241,14 +440,17 @@ export default class FourierTester {
    */
   static testDirectFourierTransform(fourierTransform) {
     fourierTestCases.forEach((testCase) => {
-      const { input, output: expectedOutput } = testCase;
+      const input = testCase.input,
+        expectedOutput = testCase.output;
 
       // Try to split input signal into sequence of pure sinusoids.
       const formattedInput = input.map((sample) => sample.amplitude);
       const currentOutput = fourierTransform(formattedInput);
 
       // Check the signal has been split into proper amount of sub-signals.
-      expect(currentOutput.length).toBeGreaterThanOrEqual(formattedInput.length);
+      expect(currentOutput.length).toBeGreaterThanOrEqual(
+        formattedInput.length
+      );
 
       // Now go through all the signals and check their frequency, amplitude and phase.
       expectedOutput.forEach((expectedSignal, frequency) => {
@@ -261,7 +463,10 @@ export default class FourierTester {
         expect(currentSignal.re).toBeCloseTo(expectedSignal.re, 4);
         expect(currentSignal.im).toBeCloseTo(expectedSignal.im, 4);
         expect(currentPolarSignal.phase).toBeCloseTo(expectedSignal.phase, 4);
-        expect(currentPolarSignal.radius).toBeCloseTo(expectedSignal.amplitude, 4);
+        expect(currentPolarSignal.radius).toBeCloseTo(
+          expectedSignal.amplitude,
+          4
+        );
       });
     });
   }
@@ -271,7 +476,8 @@ export default class FourierTester {
    */
   static testInverseFourierTransform(inverseFourierTransform) {
     fourierTestCases.forEach((testCase) => {
-      const { input: expectedOutput, output: inputFrequencies } = testCase;
+      const expectedOutput = testCase.input,
+        inputFrequencies = testCase.output;
 
       // Try to join frequencies into time signal.
       const formattedInput = inputFrequencies.map((frequency) => {
@@ -293,3 +499,4 @@ export default class FourierTester {
     });
   }
 }
+
diff --git a/src/algorithms/math/fourier-transform/__test__/discreteFourierTransform.test.js b/src/algorithms/math/fourier-transform/__test__/discreteFourierTransform.test.js
index 47da5c0..0f1a248 100644
--- a/src/algorithms/math/fourier-transform/__test__/discreteFourierTransform.test.js
+++ b/src/algorithms/math/fourier-transform/__test__/discreteFourierTransform.test.js
@@ -1,8 +1,9 @@
-import discreteFourierTransform from '../discreteFourierTransform';
-import FourierTester from './FourierTester';
+import discreteFourierTransform from "../discreteFourierTransform";
+import FourierTester from "./FourierTester";
 
-describe('discreteFourierTransform', () => {
-  it('should split signal into frequencies', () => {
+describe("discreteFourierTransform", () => {
+  it("should split signal into frequencies", () => {
     FourierTester.testDirectFourierTransform(discreteFourierTransform);
   });
 });
+
diff --git a/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js b/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js
index 2dcdc32..dae12ad 100644
--- a/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js
+++ b/src/algorithms/math/fourier-transform/__test__/fastFourierTransform.test.js
@@ -1,5 +1,5 @@
-import fastFourierTransform from '../fastFourierTransform';
-import ComplexNumber from '../../complex-number/ComplexNumber';
+import fastFourierTransform from "../fastFourierTransform";
+import ComplexNumber from "../../complex-number/ComplexNumber";
 
 /**
  * @param {ComplexNumber[]} sequence1
@@ -13,11 +13,15 @@ function sequencesApproximatelyEqual(sequence1, sequence2, delta) {
   }
 
   for (let numberIndex = 0; numberIndex < sequence1.length; numberIndex += 1) {
-    if (Math.abs(sequence1[numberIndex].re - sequence2[numberIndex].re) > delta) {
+    if (
+      Math.abs(sequence1[numberIndex].re - sequence2[numberIndex].re) > delta
+    ) {
       return false;
     }
 
-    if (Math.abs(sequence1[numberIndex].im - sequence2[numberIndex].im) > delta) {
+    if (
+      Math.abs(sequence1[numberIndex].im - sequence2[numberIndex].im) > delta
+    ) {
       return false;
     }
   }
@@ -27,18 +31,22 @@ function sequencesApproximatelyEqual(sequence1, sequence2, delta) {
 
 const delta = 1e-6;
 
-describe('fastFourierTransform', () => {
-  it('should calculate the radix-2 discrete fourier transform #1', () => {
+describe("fastFourierTransform", () => {
+  it("should calculate the radix-2 discrete fourier transform #1", () => {
     const input = [new ComplexNumber({ re: 0, im: 0 })];
     const expectedOutput = [new ComplexNumber({ re: 0, im: 0 })];
     const output = fastFourierTransform(input);
     const invertedOutput = fastFourierTransform(output, true);
 
-    expect(sequencesApproximatelyEqual(expectedOutput, output, delta)).toBe(true);
-    expect(sequencesApproximatelyEqual(input, invertedOutput, delta)).toBe(true);
+    expect(sequencesApproximatelyEqual(expectedOutput, output, delta)).toBe(
+      true
+    );
+    expect(sequencesApproximatelyEqual(input, invertedOutput, delta)).toBe(
+      true
+    );
   });
 
-  it('should calculate the radix-2 discrete fourier transform #2', () => {
+  it("should calculate the radix-2 discrete fourier transform #2", () => {
     const input = [
       new ComplexNumber({ re: 1, im: 2 }),
       new ComplexNumber({ re: 2, im: 3 }),
@@ -55,11 +63,15 @@ describe('fastFourierTransform', () => {
     const output = fastFourierTransform(input);
     const invertedOutput = fastFourierTransform(output, true);
 
-    expect(sequencesApproximatelyEqual(expectedOutput, output, delta)).toBe(true);
-    expect(sequencesApproximatelyEqual(input, invertedOutput, delta)).toBe(true);
+    expect(sequencesApproximatelyEqual(expectedOutput, output, delta)).toBe(
+      true
+    );
+    expect(sequencesApproximatelyEqual(input, invertedOutput, delta)).toBe(
+      true
+    );
   });
 
-  it('should calculate the radix-2 discrete fourier transform #3', () => {
+  it("should calculate the radix-2 discrete fourier transform #3", () => {
     const input = [
       new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
       new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
@@ -79,13 +91,13 @@ describe('fastFourierTransform', () => {
       new ComplexNumber({ re: -305990.9040412, im: 68224.8435751 }),
       new ComplexNumber({ re: -14135.7758282, im: 199223.9878095 }),
       new ComplexNumber({ re: -306965.6350922, im: 26030.1025439 }),
-      new ComplexNumber({ re: -76477.6755206, im: 40781.9078990 }),
+      new ComplexNumber({ re: -76477.6755206, im: 40781.907899 }),
       new ComplexNumber({ re: -48409.3099088, im: 54674.7959662 }),
       new ComplexNumber({ re: -329683.0131713, im: 164287.7995937 }),
       new ComplexNumber({ re: -50485.2048527, im: -330375.0546527 }),
       new ComplexNumber({ re: 122235.7738708, im: 91091.6398019 }),
       new ComplexNumber({ re: 47625.8850387, im: 73497.3981523 }),
-      new ComplexNumber({ re: -15619.8231136, im: 80804.8685410 }),
+      new ComplexNumber({ re: -15619.8231136, im: 80804.868541 }),
       new ComplexNumber({ re: 192234.0276101, im: 160833.3072355 }),
       new ComplexNumber({ re: -96389.4195635, im: 393408.4543872 }),
       new ComplexNumber({ re: -173449.0825417, im: 146875.7724104 }),
@@ -95,7 +107,12 @@ describe('fastFourierTransform', () => {
     const output = fastFourierTransform(input);
     const invertedOutput = fastFourierTransform(output, true);
 
-    expect(sequencesApproximatelyEqual(expectedOutput, output, delta)).toBe(true);
-    expect(sequencesApproximatelyEqual(input, invertedOutput, delta)).toBe(true);
+    expect(sequencesApproximatelyEqual(expectedOutput, output, delta)).toBe(
+      true
+    );
+    expect(sequencesApproximatelyEqual(input, invertedOutput, delta)).toBe(
+      true
+    );
   });
 });
+
diff --git a/src/algorithms/math/fourier-transform/__test__/inverseDiscreteFourierTransform.test.js b/src/algorithms/math/fourier-transform/__test__/inverseDiscreteFourierTransform.test.js
index 3919b3a..7f10678 100644
--- a/src/algorithms/math/fourier-transform/__test__/inverseDiscreteFourierTransform.test.js
+++ b/src/algorithms/math/fourier-transform/__test__/inverseDiscreteFourierTransform.test.js
@@ -1,8 +1,9 @@
-import inverseDiscreteFourierTransform from '../inverseDiscreteFourierTransform';
-import FourierTester from './FourierTester';
+import inverseDiscreteFourierTransform from "../inverseDiscreteFourierTransform";
+import FourierTester from "./FourierTester";
 
-describe('inverseDiscreteFourierTransform', () => {
-  it('should calculate output signal out of input frequencies', () => {
+describe("inverseDiscreteFourierTransform", () => {
+  it("should calculate output signal out of input frequencies", () => {
     FourierTester.testInverseFourierTransform(inverseDiscreteFourierTransform);
   });
 });
+
diff --git a/src/algorithms/math/fourier-transform/discreteFourierTransform.js b/src/algorithms/math/fourier-transform/discreteFourierTransform.js
index dcb0a01..01b6ca4 100644
--- a/src/algorithms/math/fourier-transform/discreteFourierTransform.js
+++ b/src/algorithms/math/fourier-transform/discreteFourierTransform.js
@@ -1,4 +1,4 @@
-import ComplexNumber from '../complex-number/ComplexNumber';
+import ComplexNumber from "../complex-number/ComplexNumber";
 
 const CLOSE_TO_ZERO_THRESHOLD = 1e-10;
 
@@ -19,7 +19,11 @@ const CLOSE_TO_ZERO_THRESHOLD = 1e-10;
  * @see https://gist.github.com/anonymous/129d477ddb1c8025c9ac
  * @see https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/
  */
-export default function dft(inputAmplitudes, zeroThreshold = CLOSE_TO_ZERO_THRESHOLD) {
+export default function dft(inputAmplitudes) {
+  let zeroThreshold =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : CLOSE_TO_ZERO_THRESHOLD;
   const N = inputAmplitudes.length;
   const signals = [];
 
@@ -67,3 +71,4 @@ export default function dft(inputAmplitudes, zeroThreshold = CLOSE_TO_ZERO_THRES
 
   return signals;
 }
+
diff --git a/src/algorithms/math/fourier-transform/fastFourierTransform.js b/src/algorithms/math/fourier-transform/fastFourierTransform.js
index ab51cf2..6609ded 100644
--- a/src/algorithms/math/fourier-transform/fastFourierTransform.js
+++ b/src/algorithms/math/fourier-transform/fastFourierTransform.js
@@ -1,5 +1,5 @@
-import ComplexNumber from '../complex-number/ComplexNumber';
-import bitLength from '../bits/bitLength';
+import ComplexNumber from "../complex-number/ComplexNumber";
+import bitLength from "../bits/bitLength";
 
 /**
  * Returns the number which is the flipped binary representation of input.
@@ -30,7 +30,9 @@ function reverseBits(input, bitsCount) {
  * @param {boolean} [inverse]
  * @return {ComplexNumber[]}
  */
-export default function fastFourierTransform(inputData, inverse = false) {
+export default function fastFourierTransform(inputData) {
+  let inverse =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
   const bitsCount = bitLength(inputData.length - 1);
   const N = 1 << bitsCount;
 
@@ -40,7 +42,8 @@ export default function fastFourierTransform(inputData, inverse = false) {
 
   const output = [];
   for (let dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
-    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
+    output[dataSampleIndex] =
+      inputData[reverseBits(dataSampleIndex, bitsCount)];
   }
 
   for (let blockLength = 2; blockLength <= N; blockLength *= 2) {
@@ -53,7 +56,11 @@ export default function fastFourierTransform(inputData, inverse = false) {
     for (let blockStart = 0; blockStart < N; blockStart += blockLength) {
       let phase = new ComplexNumber({ re: 1, im: 0 });
 
-      for (let signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
+      for (
+        let signalId = blockStart;
+        signalId < blockStart + blockLength / 2;
+        signalId += 1
+      ) {
         const component = output[signalId + blockLength / 2].multiply(phase);
 
         const upd1 = output[signalId].add(component);
@@ -75,3 +82,4 @@ export default function fastFourierTransform(inputData, inverse = false) {
 
   return output;
 }
+
diff --git a/src/algorithms/math/fourier-transform/inverseDiscreteFourierTransform.js b/src/algorithms/math/fourier-transform/inverseDiscreteFourierTransform.js
index a9f0616..fda6f96 100644
--- a/src/algorithms/math/fourier-transform/inverseDiscreteFourierTransform.js
+++ b/src/algorithms/math/fourier-transform/inverseDiscreteFourierTransform.js
@@ -1,4 +1,4 @@
-import ComplexNumber from '../complex-number/ComplexNumber';
+import ComplexNumber from "../complex-number/ComplexNumber";
 
 const CLOSE_TO_ZERO_THRESHOLD = 1e-10;
 
@@ -13,10 +13,11 @@ const CLOSE_TO_ZERO_THRESHOLD = 1e-10;
  *
  * @return {number[]} - Discrete amplitudes distributed in time.
  */
-export default function inverseDiscreteFourierTransform(
-  frequencies,
-  zeroThreshold = CLOSE_TO_ZERO_THRESHOLD,
-) {
+export default function inverseDiscreteFourierTransform(frequencies) {
+  let zeroThreshold =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : CLOSE_TO_ZERO_THRESHOLD;
   const N = frequencies.length;
   const amplitudes = [];
 
@@ -30,7 +31,7 @@ export default function inverseDiscreteFourierTransform(
       const currentFrequency = frequencies[frequency];
 
       // Calculate rotation angle.
-      const rotationAngle = (2 * Math.PI) * frequency * (timer / N);
+      const rotationAngle = 2 * Math.PI * frequency * (timer / N);
 
       // Remember that e^ix = cos(x) + i * sin(x);
       const frequencyContribution = new ComplexNumber({
@@ -56,3 +57,4 @@ export default function inverseDiscreteFourierTransform(
 
   return amplitudes;
 }
+
diff --git a/src/algorithms/math/horner-method/__test__/classicPolynome.test.js b/src/algorithms/math/horner-method/__test__/classicPolynome.test.js
index 8cdf950..341b1f0 100644
--- a/src/algorithms/math/horner-method/__test__/classicPolynome.test.js
+++ b/src/algorithms/math/horner-method/__test__/classicPolynome.test.js
@@ -1,14 +1,23 @@
-import classicPolynome from '../classicPolynome';
+import classicPolynome from "../classicPolynome";
 
-describe('classicPolynome', () => {
-  it('should evaluate the polynomial for the specified value of x correctly', () => {
+describe("classicPolynome", () => {
+  it("should evaluate the polynomial for the specified value of x correctly", () => {
     expect(classicPolynome([8], 0.1)).toBe(8);
     expect(classicPolynome([2, 4, 2, 5], 0.555)).toBe(7.68400775);
     expect(classicPolynome([2, 4, 2, 5], 0.75)).toBe(9.59375);
     expect(classicPolynome([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
-    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.1367300651406251);
-    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
-    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
-    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
+    expect(classicPolynome([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(
+      1.1367300651406251
+    );
+    expect(classicPolynome([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(
+      7.375325000000001
+    );
+    expect(classicPolynome([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(
+      9.296425000000001
+    );
+    expect(classicPolynome([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(
+      697.2731167035034
+    );
   });
 });
+
diff --git a/src/algorithms/math/horner-method/__test__/hornerMethod.test.js b/src/algorithms/math/horner-method/__test__/hornerMethod.test.js
index 177ceb1..6ae3617 100644
--- a/src/algorithms/math/horner-method/__test__/hornerMethod.test.js
+++ b/src/algorithms/math/horner-method/__test__/hornerMethod.test.js
@@ -1,21 +1,34 @@
-import hornerMethod from '../hornerMethod';
-import classicPolynome from '../classicPolynome';
+import hornerMethod from "../hornerMethod";
+import classicPolynome from "../classicPolynome";
 
-describe('hornerMethod', () => {
-  it('should evaluate the polynomial for the specified value of x correctly', () => {
+describe("hornerMethod", () => {
+  it("should evaluate the polynomial for the specified value of x correctly", () => {
     expect(hornerMethod([8], 0.1)).toBe(8);
     expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(7.68400775);
     expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(9.59375);
     expect(hornerMethod([1, 1, 1, 1, 1], 1.75)).toBe(20.55078125);
-    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(1.136730065140625);
-    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(7.375325000000001);
-    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(9.296425000000001);
-    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(697.2731167035034);
+    expect(hornerMethod([15, 3.5, 0, 2, 1.42, 0.41], 0.315)).toBe(
+      1.136730065140625
+    );
+    expect(hornerMethod([0, 0, 2.77, 1.42, 0.41], 1.35)).toBe(
+      7.375325000000001
+    );
+    expect(hornerMethod([0, 0, 2.77, 1.42, 2.3311], 1.35)).toBe(
+      9.296425000000001
+    );
+    expect(hornerMethod([2, 0, 0, 5.757, 5.31412, 12.3213], 3.141)).toBe(
+      697.2731167035034
+    );
   });
 
-  it('should evaluate the same polynomial value as classical approach', () => {
+  it("should evaluate the same polynomial value as classical approach", () => {
     expect(hornerMethod([8], 0.1)).toBe(classicPolynome([8], 0.1));
-    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(classicPolynome([2, 4, 2, 5], 0.555));
-    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(classicPolynome([2, 4, 2, 5], 0.75));
+    expect(hornerMethod([2, 4, 2, 5], 0.555)).toBe(
+      classicPolynome([2, 4, 2, 5], 0.555)
+    );
+    expect(hornerMethod([2, 4, 2, 5], 0.75)).toBe(
+      classicPolynome([2, 4, 2, 5], 0.75)
+    );
   });
 });
+
diff --git a/src/algorithms/math/horner-method/classicPolynome.js b/src/algorithms/math/horner-method/classicPolynome.js
index 1f6aa86..b39ac19 100644
--- a/src/algorithms/math/horner-method/classicPolynome.js
+++ b/src/algorithms/math/horner-method/classicPolynome.js
@@ -7,10 +7,10 @@
  * @return {number}
  */
 export default function classicPolynome(coefficients, xVal) {
-  return coefficients.reverse().reduce(
-    (accumulator, currentCoefficient, index) => {
-      return accumulator + currentCoefficient * (xVal ** index);
-    },
-    0,
-  );
+  return coefficients
+    .reverse()
+    .reduce((accumulator, currentCoefficient, index) => {
+      return accumulator + currentCoefficient * xVal ** index;
+    }, 0);
 }
+
diff --git a/src/algorithms/math/horner-method/hornerMethod.js b/src/algorithms/math/horner-method/hornerMethod.js
index 2236170..d4f55e0 100644
--- a/src/algorithms/math/horner-method/hornerMethod.js
+++ b/src/algorithms/math/horner-method/hornerMethod.js
@@ -7,10 +7,8 @@
  * @return {number}
  */
 export default function hornerMethod(coefficients, xVal) {
-  return coefficients.reduce(
-    (accumulator, currentCoefficient) => {
-      return accumulator * xVal + currentCoefficient;
-    },
-    0,
-  );
+  return coefficients.reduce((accumulator, currentCoefficient) => {
+    return accumulator * xVal + currentCoefficient;
+  }, 0);
 }
+
diff --git a/src/algorithms/math/integer-partition/__test__/integerPartition.test.js b/src/algorithms/math/integer-partition/__test__/integerPartition.test.js
index e78b1df..060b2d2 100644
--- a/src/algorithms/math/integer-partition/__test__/integerPartition.test.js
+++ b/src/algorithms/math/integer-partition/__test__/integerPartition.test.js
@@ -1,7 +1,7 @@
-import integerPartition from '../integerPartition';
+import integerPartition from "../integerPartition";
 
-describe('integerPartition', () => {
-  it('should partition the number', () => {
+describe("integerPartition", () => {
+  it("should partition the number", () => {
     expect(integerPartition(1)).toBe(1);
     expect(integerPartition(2)).toBe(2);
     expect(integerPartition(3)).toBe(3);
@@ -12,3 +12,4 @@ describe('integerPartition', () => {
     expect(integerPartition(8)).toBe(22);
   });
 });
+
diff --git a/src/algorithms/math/integer-partition/integerPartition.js b/src/algorithms/math/integer-partition/integerPartition.js
index 02cb31f..1a3affa 100644
--- a/src/algorithms/math/integer-partition/integerPartition.js
+++ b/src/algorithms/math/integer-partition/integerPartition.js
@@ -4,9 +4,11 @@
  */
 export default function integerPartition(number) {
   // Create partition matrix for solving this task using Dynamic Programming.
-  const partitionMatrix = Array(number + 1).fill(null).map(() => {
-    return Array(number + 1).fill(null);
-  });
+  const partitionMatrix = Array(number + 1)
+    .fill(null)
+    .map(() => {
+      return Array(number + 1).fill(null);
+    });
 
   // Fill partition matrix with initial values.
 
@@ -32,7 +34,8 @@ export default function integerPartition(number) {
       if (summandIndex > numberIndex) {
         // If summand number is bigger then current number itself then just it won't add
         // any new ways of forming the number. Thus we may just copy the number from row above.
-        partitionMatrix[summandIndex][numberIndex] = partitionMatrix[summandIndex - 1][numberIndex];
+        partitionMatrix[summandIndex][numberIndex] =
+          partitionMatrix[summandIndex - 1][numberIndex];
       } else {
         /*
          * The number of combinations would equal to number of combinations of forming the same
@@ -44,14 +47,18 @@ export default function integerPartition(number) {
          * - number of ways to form 5 using summands {0, 1} (we've excluded summand 2)
          * - number of ways to form 3 (because 5 - 2 = 3) using summands {0, 1, 2}
          * (we've included summand 2)
-        */
-        const combosWithoutSummand = partitionMatrix[summandIndex - 1][numberIndex];
-        const combosWithSummand = partitionMatrix[summandIndex][numberIndex - summandIndex];
+         */
+        const combosWithoutSummand =
+          partitionMatrix[summandIndex - 1][numberIndex];
+        const combosWithSummand =
+          partitionMatrix[summandIndex][numberIndex - summandIndex];
 
-        partitionMatrix[summandIndex][numberIndex] = combosWithoutSummand + combosWithSummand;
+        partitionMatrix[summandIndex][numberIndex] =
+          combosWithoutSummand + combosWithSummand;
       }
     }
   }
 
   return partitionMatrix[number][number];
 }
+
diff --git a/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwo.test.js b/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwo.test.js
index d1271ba..cd081ea 100644
--- a/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwo.test.js
+++ b/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwo.test.js
@@ -1,7 +1,7 @@
-import isPowerOfTwo from '../isPowerOfTwo';
+import isPowerOfTwo from "../isPowerOfTwo";
 
-describe('isPowerOfTwo', () => {
-  it('should check if the number is made by multiplying twos', () => {
+describe("isPowerOfTwo", () => {
+  it("should check if the number is made by multiplying twos", () => {
     expect(isPowerOfTwo(-1)).toBe(false);
     expect(isPowerOfTwo(0)).toBe(false);
     expect(isPowerOfTwo(1)).toBe(true);
@@ -21,3 +21,4 @@ describe('isPowerOfTwo', () => {
     expect(isPowerOfTwo(1023)).toBe(false);
   });
 });
+
diff --git a/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwoBitwise.test.js b/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwoBitwise.test.js
index bcba3a6..94976a8 100644
--- a/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwoBitwise.test.js
+++ b/src/algorithms/math/is-power-of-two/__test__/isPowerOfTwoBitwise.test.js
@@ -1,7 +1,7 @@
-import isPowerOfTwoBitwise from '../isPowerOfTwoBitwise';
+import isPowerOfTwoBitwise from "../isPowerOfTwoBitwise";
 
-describe('isPowerOfTwoBitwise', () => {
-  it('should check if the number is made by multiplying twos', () => {
+describe("isPowerOfTwoBitwise", () => {
+  it("should check if the number is made by multiplying twos", () => {
     expect(isPowerOfTwoBitwise(-1)).toBe(false);
     expect(isPowerOfTwoBitwise(0)).toBe(false);
     expect(isPowerOfTwoBitwise(1)).toBe(true);
@@ -21,3 +21,4 @@ describe('isPowerOfTwoBitwise', () => {
     expect(isPowerOfTwoBitwise(1023)).toBe(false);
   });
 });
+
diff --git a/src/algorithms/math/is-power-of-two/isPowerOfTwo.js b/src/algorithms/math/is-power-of-two/isPowerOfTwo.js
index 6f7590d..d465632 100644
--- a/src/algorithms/math/is-power-of-two/isPowerOfTwo.js
+++ b/src/algorithms/math/is-power-of-two/isPowerOfTwo.js
@@ -23,3 +23,4 @@ export default function isPowerOfTwo(number) {
 
   return true;
 }
+
diff --git a/src/algorithms/math/is-power-of-two/isPowerOfTwoBitwise.js b/src/algorithms/math/is-power-of-two/isPowerOfTwoBitwise.js
index af11773..22802fb 100644
--- a/src/algorithms/math/is-power-of-two/isPowerOfTwoBitwise.js
+++ b/src/algorithms/math/is-power-of-two/isPowerOfTwoBitwise.js
@@ -24,3 +24,4 @@ export default function isPowerOfTwoBitwise(number) {
    */
   return (number & (number - 1)) === 0;
 }
+
diff --git a/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js b/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js
index 2152e11..ad4897c 100644
--- a/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js
+++ b/src/algorithms/math/least-common-multiple/__test__/leastCommonMultiple.test.js
@@ -1,7 +1,7 @@
-import leastCommonMultiple from '../leastCommonMultiple';
+import leastCommonMultiple from "../leastCommonMultiple";
 
-describe('leastCommonMultiple', () => {
-  it('should find least common multiple', () => {
+describe("leastCommonMultiple", () => {
+  it("should find least common multiple", () => {
     expect(leastCommonMultiple(0, 0)).toBe(0);
     expect(leastCommonMultiple(1, 0)).toBe(0);
     expect(leastCommonMultiple(0, 1)).toBe(0);
@@ -16,3 +16,4 @@ describe('leastCommonMultiple', () => {
     expect(leastCommonMultiple(-7, 9)).toBe(63);
   });
 });
+
diff --git a/src/algorithms/math/least-common-multiple/leastCommonMultiple.js b/src/algorithms/math/least-common-multiple/leastCommonMultiple.js
index 26a7681..f307ffe 100644
--- a/src/algorithms/math/least-common-multiple/leastCommonMultiple.js
+++ b/src/algorithms/math/least-common-multiple/leastCommonMultiple.js
@@ -1,4 +1,4 @@
-import euclideanAlgorithm from '../euclidean-algorithm/euclideanAlgorithm';
+import euclideanAlgorithm from "../euclidean-algorithm/euclideanAlgorithm";
 
 /**
  * @param {number} a
@@ -7,5 +7,6 @@ import euclideanAlgorithm from '../euclidean-algorithm/euclideanAlgorithm';
  */
 
 export default function leastCommonMultiple(a, b) {
-  return ((a === 0) || (b === 0)) ? 0 : Math.abs(a * b) / euclideanAlgorithm(a, b);
+  return a === 0 || b === 0 ? 0 : Math.abs(a * b) / euclideanAlgorithm(a, b);
 }
+
diff --git a/src/algorithms/math/liu-hui/__test__/liuHui.test.js b/src/algorithms/math/liu-hui/__test__/liuHui.test.js
index 44f7464..74c59cc 100644
--- a/src/algorithms/math/liu-hui/__test__/liuHui.test.js
+++ b/src/algorithms/math/liu-hui/__test__/liuHui.test.js
@@ -1,19 +1,20 @@
-import liuHui from '../liuHui';
+import liuHui from "../liuHui";
 
-describe('liuHui', () => {
-  it('should calculate π based on 12-gon', () => {
+describe("liuHui", () => {
+  it("should calculate π based on 12-gon", () => {
     expect(liuHui(1)).toBe(3);
   });
 
-  it('should calculate π based on 24-gon', () => {
+  it("should calculate π based on 24-gon", () => {
     expect(liuHui(2)).toBe(3.105828541230249);
   });
 
-  it('should calculate π based on 6144-gon', () => {
+  it("should calculate π based on 6144-gon", () => {
     expect(liuHui(10)).toBe(3.1415921059992717);
   });
 
-  it('should calculate π based on 201326592-gon', () => {
+  it("should calculate π based on 201326592-gon", () => {
     expect(liuHui(25)).toBe(3.141592653589793);
   });
 });
+
diff --git a/src/algorithms/math/liu-hui/liuHui.js b/src/algorithms/math/liu-hui/liuHui.js
index e289ed8..c780248 100644
--- a/src/algorithms/math/liu-hui/liuHui.js
+++ b/src/algorithms/math/liu-hui/liuHui.js
@@ -17,9 +17,9 @@ function getNGonSideLength(sideLength, splitCounter) {
   const halfSide = sideLength / 2;
 
   // Liu Hui used the Gou Gu (Pythagorean theorem) theorem repetitively.
-  const perpendicular = Math.sqrt((circleRadius ** 2) - (halfSide ** 2));
+  const perpendicular = Math.sqrt(circleRadius ** 2 - halfSide ** 2);
   const excessRadius = circleRadius - perpendicular;
-  const splitSideLength = Math.sqrt((excessRadius ** 2) + (halfSide ** 2));
+  const splitSideLength = Math.sqrt(excessRadius ** 2 + halfSide ** 2);
 
   return getNGonSideLength(splitSideLength, splitCounter - 1);
 }
@@ -43,12 +43,15 @@ function getNGonSideCount(splitCount) {
  *  On each split we will receive 12-gon, 24-gon and so on.
  * @return {number}
  */
-export default function liuHui(splitCount = 1) {
+export default function liuHui() {
+  let splitCount =
+    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
   const nGonSideLength = getNGonSideLength(circleRadius, splitCount - 1);
   const nGonSideCount = getNGonSideCount(splitCount - 1);
   const nGonPerimeter = nGonSideLength * nGonSideCount;
   const approximateCircleArea = (nGonPerimeter / 2) * circleRadius;
 
   // Return approximate value of pi.
-  return approximateCircleArea / (circleRadius ** 2);
+  return approximateCircleArea / circleRadius ** 2;
 }
+
diff --git a/src/algorithms/math/matrix/Matrix.js b/src/algorithms/math/matrix/Matrix.js
index 2aee126..ae4ad28 100644
--- a/src/algorithms/math/matrix/Matrix.js
+++ b/src/algorithms/math/matrix/Matrix.js
@@ -28,12 +28,8 @@ export const shape = (m) => {
  * @throws {Error}
  */
 const validateType = (m) => {
-  if (
-    !m
-    || !Array.isArray(m)
-    || !Array.isArray(m[0])
-  ) {
-    throw new Error('Invalid matrix format');
+  if (!m || !Array.isArray(m) || !Array.isArray(m[0])) {
+    throw new Error("Invalid matrix format");
   }
 };
 
@@ -47,7 +43,7 @@ const validate2D = (m) => {
   validateType(m);
   const aShape = shape(m);
   if (aShape.length !== 2) {
-    throw new Error('Matrix is not of 2D shape');
+    throw new Error("Matrix is not of 2D shape");
   }
 };
 
@@ -66,12 +62,12 @@ export const validateSameShape = (a, b) => {
   const bShape = shape(b);
 
   if (aShape.length !== bShape.length) {
-    throw new Error('Matrices have different dimensions');
+    throw new Error("Matrices have different dimensions");
   }
 
   while (aShape.length && bShape.length) {
     if (aShape.pop() !== bShape.pop()) {
-      throw new Error('Matrices have different shapes');
+      throw new Error("Matrices have different shapes");
     }
   }
 };
@@ -132,7 +128,7 @@ export const dot = (a, b) => {
   const aShape = shape(a);
   const bShape = shape(b);
   if (aShape[1] !== bShape[0]) {
-    throw new Error('Matrices have incompatible shape for multiplication');
+    throw new Error("Matrices have incompatible shape for multiplication");
   }
 
   // Perform matrix multiplication.
@@ -307,3 +303,4 @@ export const sub = (a, b) => {
 
   return result;
 };
+
diff --git a/src/algorithms/math/matrix/__tests__/Matrix.test.js b/src/algorithms/math/matrix/__tests__/Matrix.test.js
index 37dc892..bf14cb3 100644
--- a/src/algorithms/math/matrix/__tests__/Matrix.test.js
+++ b/src/algorithms/math/matrix/__tests__/Matrix.test.js
@@ -1,89 +1,93 @@
-import * as mtrx from '../Matrix';
-
-describe('Matrix', () => {
-  it('should throw when trying to add matrices of invalid shapes', () => {
-    expect(
-      () => mtrx.dot([0], [1]),
-    ).toThrowError('Invalid matrix format');
-    expect(
-      () => mtrx.dot([[0]], [1]),
-    ).toThrowError('Invalid matrix format');
-    expect(
-      () => mtrx.dot([[[0]]], [[1]]),
-    ).toThrowError('Matrix is not of 2D shape');
-    expect(
-      () => mtrx.dot([[0]], [[1], [2]]),
-    ).toThrowError('Matrices have incompatible shape for multiplication');
+import * as mtrx from "../Matrix";
+
+describe("Matrix", () => {
+  it("should throw when trying to add matrices of invalid shapes", () => {
+    expect(() => mtrx.dot([0], [1])).toThrowError("Invalid matrix format");
+    expect(() => mtrx.dot([[0]], [1])).toThrowError("Invalid matrix format");
+    expect(() => mtrx.dot([[[0]]], [[1]])).toThrowError(
+      "Matrix is not of 2D shape"
+    );
+    expect(() => mtrx.dot([[0]], [[1], [2]])).toThrowError(
+      "Matrices have incompatible shape for multiplication"
+    );
   });
 
-  it('should calculate matrices dimensions', () => {
+  it("should calculate matrices dimensions", () => {
     expect(mtrx.shape([])).toEqual([0]);
 
-    expect(mtrx.shape([
-      [],
-    ])).toEqual([1, 0]);
+    expect(mtrx.shape([[]])).toEqual([1, 0]);
 
-    expect(mtrx.shape([
-      [0],
-    ])).toEqual([1, 1]);
+    expect(mtrx.shape([[0]])).toEqual([1, 1]);
 
-    expect(mtrx.shape([
-      [0, 0],
-    ])).toEqual([1, 2]);
+    expect(mtrx.shape([[0, 0]])).toEqual([1, 2]);
 
-    expect(mtrx.shape([
-      [0, 0],
-      [0, 0],
-    ])).toEqual([2, 2]);
+    expect(
+      mtrx.shape([
+        [0, 0],
+        [0, 0],
+      ])
+    ).toEqual([2, 2]);
 
-    expect(mtrx.shape([
-      [0, 0, 0],
-      [0, 0, 0],
-    ])).toEqual([2, 3]);
+    expect(
+      mtrx.shape([
+        [0, 0, 0],
+        [0, 0, 0],
+      ])
+    ).toEqual([2, 3]);
 
-    expect(mtrx.shape([
-      [0, 0],
-      [0, 0],
-      [0, 0],
-    ])).toEqual([3, 2]);
+    expect(
+      mtrx.shape([
+        [0, 0],
+        [0, 0],
+        [0, 0],
+      ])
+    ).toEqual([3, 2]);
 
-    expect(mtrx.shape([
-      [0, 0, 0],
-      [0, 0, 0],
-      [0, 0, 0],
-    ])).toEqual([3, 3]);
+    expect(
+      mtrx.shape([
+        [0, 0, 0],
+        [0, 0, 0],
+        [0, 0, 0],
+      ])
+    ).toEqual([3, 3]);
 
-    expect(mtrx.shape([
-      [0],
-      [0],
-      [0],
-    ])).toEqual([3, 1]);
+    expect(mtrx.shape([[0], [0], [0]])).toEqual([3, 1]);
 
-    expect(mtrx.shape([
-      [[0], [0], [0]],
-      [[0], [0], [0]],
-      [[0], [0], [0]],
-    ])).toEqual([3, 3, 1]);
+    expect(
+      mtrx.shape([
+        [[0], [0], [0]],
+        [[0], [0], [0]],
+        [[0], [0], [0]],
+      ])
+    ).toEqual([3, 3, 1]);
 
-    expect(mtrx.shape([
-      [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
-      [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
-      [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
-    ])).toEqual([3, 3, 3]);
+    expect(
+      mtrx.shape([
+        [
+          [0, 0, 0],
+          [0, 0, 0],
+          [0, 0, 0],
+        ],
+        [
+          [0, 0, 0],
+          [0, 0, 0],
+          [0, 0, 0],
+        ],
+        [
+          [0, 0, 0],
+          [0, 0, 0],
+          [0, 0, 0],
+        ],
+      ])
+    ).toEqual([3, 3, 3]);
   });
 
-  it('should generate the matrix of zeros', () => {
-    expect(mtrx.zeros([1, 0])).toEqual([
-      [],
-    ]);
+  it("should generate the matrix of zeros", () => {
+    expect(mtrx.zeros([1, 0])).toEqual([[]]);
 
-    expect(mtrx.zeros([1, 1])).toEqual([
-      [0],
-    ]);
+    expect(mtrx.zeros([1, 1])).toEqual([[0]]);
 
-    expect(mtrx.zeros([1, 3])).toEqual([
-      [0, 0, 0],
-    ]);
+    expect(mtrx.zeros([1, 3])).toEqual([[0, 0, 0]]);
 
     expect(mtrx.zeros([3, 3])).toEqual([
       [0, 0, 0],
@@ -98,18 +102,12 @@ describe('Matrix', () => {
     ]);
   });
 
-  it('should generate the matrix with custom values', () => {
-    expect(mtrx.generate([1, 0], () => 1)).toEqual([
-      [],
-    ]);
+  it("should generate the matrix with custom values", () => {
+    expect(mtrx.generate([1, 0], () => 1)).toEqual([[]]);
 
-    expect(mtrx.generate([1, 1], () => 1)).toEqual([
-      [1],
-    ]);
+    expect(mtrx.generate([1, 1], () => 1)).toEqual([[1]]);
 
-    expect(mtrx.generate([1, 3], () => 1)).toEqual([
-      [1, 1, 1],
-    ]);
+    expect(mtrx.generate([1, 3], () => 1)).toEqual([[1, 1, 1]]);
 
     expect(mtrx.generate([3, 3], () => 1)).toEqual([
       [1, 1, 1],
@@ -124,7 +122,7 @@ describe('Matrix', () => {
     ]);
   });
 
-  it('should generate a custom matrix based on specific cell indices', () => {
+  it("should generate a custom matrix based on specific cell indices", () => {
     const indicesCallback = jest.fn((indices) => {
       return indices[0] * 10 + indices[1];
     });
@@ -147,18 +145,20 @@ describe('Matrix', () => {
     ]);
   });
 
-  it('should multiply two matrices', () => {
+  it("should multiply two matrices", () => {
     let c;
     c = mtrx.dot(
       [
         [1, 2],
         [3, 4],
       ],
+
       [
         [5, 6],
         [7, 8],
-      ],
+      ]
     );
+
     expect(mtrx.shape(c)).toEqual([2, 2]);
     expect(c).toEqual([
       [19, 22],
@@ -170,28 +170,26 @@ describe('Matrix', () => {
         [1, 2],
         [3, 4],
       ],
-      [
-        [5],
-        [6],
-      ],
+
+      [[5], [6]]
     );
+
     expect(mtrx.shape(c)).toEqual([2, 1]);
-    expect(c).toEqual([
-      [17],
-      [39],
-    ]);
+    expect(c).toEqual([[17], [39]]);
 
     c = mtrx.dot(
       [
         [1, 2, 3],
         [4, 5, 6],
       ],
+
       [
         [7, 8],
         [9, 10],
         [11, 12],
-      ],
+      ]
     );
+
     expect(mtrx.shape(c)).toEqual([2, 2]);
     expect(c).toEqual([
       [58, 64],
@@ -199,257 +197,220 @@ describe('Matrix', () => {
     ]);
 
     c = mtrx.dot(
-      [
-        [3, 4, 2],
-      ],
+      [[3, 4, 2]],
+
       [
         [13, 9, 7, 5],
         [8, 7, 4, 6],
         [6, 4, 0, 3],
-      ],
+      ]
     );
+
     expect(mtrx.shape(c)).toEqual([1, 4]);
-    expect(c).toEqual([
-      [83, 63, 37, 45],
-    ]);
+    expect(c).toEqual([[83, 63, 37, 45]]);
   });
 
-  it('should transpose matrices', () => {
-    expect(mtrx.t([[1, 2, 3]])).toEqual([
-      [1],
-      [2],
-      [3],
-    ]);
+  it("should transpose matrices", () => {
+    expect(mtrx.t([[1, 2, 3]])).toEqual([[1], [2], [3]]);
 
-    expect(mtrx.t([
-      [1],
-      [2],
-      [3],
-    ])).toEqual([
-      [1, 2, 3],
-    ]);
+    expect(mtrx.t([[1], [2], [3]])).toEqual([[1, 2, 3]]);
 
-    expect(mtrx.t([
-      [1, 2, 3],
-      [4, 5, 6],
-    ])).toEqual([
+    expect(
+      mtrx.t([
+        [1, 2, 3],
+        [4, 5, 6],
+      ])
+    ).toEqual([
       [1, 4],
       [2, 5],
       [3, 6],
     ]);
 
-    expect(mtrx.t([
-      [1, 2, 3],
-      [4, 5, 6],
-      [7, 8, 9],
-    ])).toEqual([
+    expect(
+      mtrx.t([
+        [1, 2, 3],
+        [4, 5, 6],
+        [7, 8, 9],
+      ])
+    ).toEqual([
       [1, 4, 7],
       [2, 5, 8],
       [3, 6, 9],
     ]);
   });
 
-  it('should throw when trying to transpose non 2D matrix', () => {
+  it("should throw when trying to transpose non 2D matrix", () => {
     expect(() => {
       mtrx.t([[[1]]]);
-    }).toThrowError('Matrix is not of 2D shape');
+    }).toThrowError("Matrix is not of 2D shape");
   });
 
-  it('should add two matrices', () => {
+  it("should add two matrices", () => {
     expect(mtrx.add([[1]], [[2]])).toEqual([[3]]);
 
-    expect(mtrx.add(
-      [[1, 2, 3]],
-      [[4, 5, 6]],
-    ))
-      .toEqual(
-        [[5, 7, 9]],
-      );
-
-    expect(mtrx.add(
-      [[1], [2], [3]],
-      [[4], [5], [6]],
-    ))
-      .toEqual(
-        [[5], [7], [9]],
-      );
-
-    expect(mtrx.add(
-      [
-        [1, 2, 3],
-        [4, 5, 6],
-        [7, 8, 9],
-      ],
-      [
-        [10, 11, 12],
-        [13, 14, 15],
-        [16, 17, 18],
-      ],
-    ))
-      .toEqual(
+    expect(mtrx.add([[1, 2, 3]], [[4, 5, 6]])).toEqual([[5, 7, 9]]);
+
+    expect(mtrx.add([[1], [2], [3]], [[4], [5], [6]])).toEqual([[5], [7], [9]]);
+
+    expect(
+      mtrx.add(
         [
-          [11, 13, 15],
-          [17, 19, 21],
-          [23, 25, 27],
+          [1, 2, 3],
+          [4, 5, 6],
+          [7, 8, 9],
         ],
-      );
 
-    expect(mtrx.add(
-      [
-        [[1], [2], [3]],
-        [[4], [5], [6]],
-        [[7], [8], [9]],
-      ],
-      [
-        [[10], [11], [12]],
-        [[13], [14], [15]],
-        [[16], [17], [18]],
-      ],
-    ))
-      .toEqual(
         [
-          [[11], [13], [15]],
-          [[17], [19], [21]],
-          [[23], [25], [27]],
+          [10, 11, 12],
+          [13, 14, 15],
+          [16, 17, 18],
+        ]
+      )
+    ).toEqual([
+      [11, 13, 15],
+      [17, 19, 21],
+      [23, 25, 27],
+    ]);
+
+    expect(
+      mtrx.add(
+        [
+          [[1], [2], [3]],
+          [[4], [5], [6]],
+          [[7], [8], [9]],
         ],
-      );
+
+        [
+          [[10], [11], [12]],
+          [[13], [14], [15]],
+          [[16], [17], [18]],
+        ]
+      )
+    ).toEqual([
+      [[11], [13], [15]],
+      [[17], [19], [21]],
+      [[23], [25], [27]],
+    ]);
   });
 
-  it('should throw when trying to add matrices of different shape', () => {
+  it("should throw when trying to add matrices of different shape", () => {
     expect(() => mtrx.add([[0]], [[[0]]])).toThrowError(
-      'Matrices have different dimensions',
+      "Matrices have different dimensions"
     );
 
     expect(() => mtrx.add([[0]], [[0, 0]])).toThrowError(
-      'Matrices have different shapes',
+      "Matrices have different shapes"
     );
   });
 
-  it('should do element wise multiplication two matrices', () => {
+  it("should do element wise multiplication two matrices", () => {
     expect(mtrx.mul([[2]], [[3]])).toEqual([[6]]);
 
-    expect(mtrx.mul(
-      [[1, 2, 3]],
-      [[4, 5, 6]],
-    ))
-      .toEqual(
-        [[4, 10, 18]],
-      );
-
-    expect(mtrx.mul(
-      [[1], [2], [3]],
-      [[4], [5], [6]],
-    ))
-      .toEqual(
-        [[4], [10], [18]],
-      );
-
-    expect(mtrx.mul(
-      [
-        [1, 2],
-        [3, 4],
-      ],
-      [
-        [5, 6],
-        [7, 8],
-      ],
-    ))
-      .toEqual(
+    expect(mtrx.mul([[1, 2, 3]], [[4, 5, 6]])).toEqual([[4, 10, 18]]);
+
+    expect(mtrx.mul([[1], [2], [3]], [[4], [5], [6]])).toEqual([
+      [4],
+      [10],
+      [18],
+    ]);
+
+    expect(
+      mtrx.mul(
         [
-          [5, 12],
-          [21, 32],
+          [1, 2],
+          [3, 4],
         ],
-      );
 
-    expect(mtrx.mul(
-      [
-        [[1], [2]],
-        [[3], [4]],
-      ],
-      [
-        [[5], [6]],
-        [[7], [8]],
-      ],
-    ))
-      .toEqual(
         [
-          [[5], [12]],
-          [[21], [32]],
+          [5, 6],
+          [7, 8],
+        ]
+      )
+    ).toEqual([
+      [5, 12],
+      [21, 32],
+    ]);
+
+    expect(
+      mtrx.mul(
+        [
+          [[1], [2]],
+          [[3], [4]],
         ],
-      );
+
+        [
+          [[5], [6]],
+          [[7], [8]],
+        ]
+      )
+    ).toEqual([
+      [[5], [12]],
+      [[21], [32]],
+    ]);
   });
 
-  it('should throw when trying to multiply matrices element-wise of different shape', () => {
+  it("should throw when trying to multiply matrices element-wise of different shape", () => {
     expect(() => mtrx.mul([[0]], [[[0]]])).toThrowError(
-      'Matrices have different dimensions',
+      "Matrices have different dimensions"
     );
 
     expect(() => mtrx.mul([[0]], [[0, 0]])).toThrowError(
-      'Matrices have different shapes',
+      "Matrices have different shapes"
     );
   });
 
-  it('should do element wise subtraction two matrices', () => {
+  it("should do element wise subtraction two matrices", () => {
     expect(mtrx.sub([[3]], [[2]])).toEqual([[1]]);
 
-    expect(mtrx.sub(
-      [[10, 12, 14]],
-      [[4, 5, 6]],
-    ))
-      .toEqual(
-        [[6, 7, 8]],
-      );
-
-    expect(mtrx.sub(
-      [[[10], [12], [14]]],
-      [[[4], [5], [6]]],
-    ))
-      .toEqual(
-        [[[6], [7], [8]]],
-      );
-
-    expect(mtrx.sub(
-      [
-        [10, 20],
-        [30, 40],
-      ],
-      [
-        [5, 6],
-        [7, 8],
-      ],
-    ))
-      .toEqual(
+    expect(mtrx.sub([[10, 12, 14]], [[4, 5, 6]])).toEqual([[6, 7, 8]]);
+
+    expect(mtrx.sub([[[10], [12], [14]]], [[[4], [5], [6]]])).toEqual([
+      [[6], [7], [8]],
+    ]);
+
+    expect(
+      mtrx.sub(
         [
-          [5, 14],
-          [23, 32],
+          [10, 20],
+          [30, 40],
         ],
-      );
 
-    expect(mtrx.sub(
-      [
-        [[10], [20]],
-        [[30], [40]],
-      ],
-      [
-        [[5], [6]],
-        [[7], [8]],
-      ],
-    ))
-      .toEqual(
         [
-          [[5], [14]],
-          [[23], [32]],
+          [5, 6],
+          [7, 8],
+        ]
+      )
+    ).toEqual([
+      [5, 14],
+      [23, 32],
+    ]);
+
+    expect(
+      mtrx.sub(
+        [
+          [[10], [20]],
+          [[30], [40]],
         ],
-      );
+
+        [
+          [[5], [6]],
+          [[7], [8]],
+        ]
+      )
+    ).toEqual([
+      [[5], [14]],
+      [[23], [32]],
+    ]);
   });
 
-  it('should throw when trying to subtract matrices element-wise of different shape', () => {
+  it("should throw when trying to subtract matrices element-wise of different shape", () => {
     expect(() => mtrx.sub([[0]], [[[0]]])).toThrowError(
-      'Matrices have different dimensions',
+      "Matrices have different dimensions"
     );
 
     expect(() => mtrx.sub([[0]], [[0, 0]])).toThrowError(
-      'Matrices have different shapes',
+      "Matrices have different shapes"
     );
   });
 });
+
diff --git a/src/algorithms/math/pascal-triangle/__test__/pascalTriangle.test.js b/src/algorithms/math/pascal-triangle/__test__/pascalTriangle.test.js
index 152fc8e..792fcfa 100644
--- a/src/algorithms/math/pascal-triangle/__test__/pascalTriangle.test.js
+++ b/src/algorithms/math/pascal-triangle/__test__/pascalTriangle.test.js
@@ -1,7 +1,7 @@
-import pascalTriangle from '../pascalTriangle';
+import pascalTriangle from "../pascalTriangle";
 
-describe('pascalTriangle', () => {
-  it('should calculate Pascal Triangle coefficients for specific line number', () => {
+describe("pascalTriangle", () => {
+  it("should calculate Pascal Triangle coefficients for specific line number", () => {
     expect(pascalTriangle(0)).toEqual([1]);
     expect(pascalTriangle(1)).toEqual([1, 1]);
     expect(pascalTriangle(2)).toEqual([1, 2, 1]);
@@ -12,3 +12,4 @@ describe('pascalTriangle', () => {
     expect(pascalTriangle(7)).toEqual([1, 7, 21, 35, 35, 21, 7, 1]);
   });
 });
+
diff --git a/src/algorithms/math/pascal-triangle/__test__/pascalTriangleRecursive.test.js b/src/algorithms/math/pascal-triangle/__test__/pascalTriangleRecursive.test.js
index 2dfdad6..c83f05c 100644
--- a/src/algorithms/math/pascal-triangle/__test__/pascalTriangleRecursive.test.js
+++ b/src/algorithms/math/pascal-triangle/__test__/pascalTriangleRecursive.test.js
@@ -1,7 +1,7 @@
-import pascalTriangleRecursive from '../pascalTriangleRecursive';
+import pascalTriangleRecursive from "../pascalTriangleRecursive";
 
-describe('pascalTriangleRecursive', () => {
-  it('should calculate Pascal Triangle coefficients for specific line number', () => {
+describe("pascalTriangleRecursive", () => {
+  it("should calculate Pascal Triangle coefficients for specific line number", () => {
     expect(pascalTriangleRecursive(0)).toEqual([1]);
     expect(pascalTriangleRecursive(1)).toEqual([1, 1]);
     expect(pascalTriangleRecursive(2)).toEqual([1, 2, 1]);
@@ -12,3 +12,4 @@ describe('pascalTriangleRecursive', () => {
     expect(pascalTriangleRecursive(7)).toEqual([1, 7, 21, 35, 35, 21, 7, 1]);
   });
 });
+
diff --git a/src/algorithms/math/pascal-triangle/pascalTriangle.js b/src/algorithms/math/pascal-triangle/pascalTriangle.js
index 35686fa..fb6ed76 100644
--- a/src/algorithms/math/pascal-triangle/pascalTriangle.js
+++ b/src/algorithms/math/pascal-triangle/pascalTriangle.js
@@ -9,8 +9,10 @@ export default function pascalTriangle(lineNumber) {
 
   for (let numIndex = 1; numIndex < currentLineSize; numIndex += 1) {
     // See explanation of this formula in README.
-    currentLine[numIndex] = (currentLine[numIndex - 1] * (lineNumber - numIndex + 1)) / numIndex;
+    currentLine[numIndex] =
+      (currentLine[numIndex - 1] * (lineNumber - numIndex + 1)) / numIndex;
   }
 
   return currentLine;
 }
+
diff --git a/src/algorithms/math/pascal-triangle/pascalTriangleRecursive.js b/src/algorithms/math/pascal-triangle/pascalTriangleRecursive.js
index 120fe25..d5a7897 100644
--- a/src/algorithms/math/pascal-triangle/pascalTriangleRecursive.js
+++ b/src/algorithms/math/pascal-triangle/pascalTriangleRecursive.js
@@ -20,11 +20,13 @@ export default function pascalTriangleRecursive(lineNumber) {
   // last one (since they were and will be filled with 1's) and calculate
   // current coefficient based on previous line.
   for (let numIndex = 0; numIndex < currentLineSize; numIndex += 1) {
-    const leftCoefficient = (numIndex - 1) >= 0 ? previousLine[numIndex - 1] : 0;
-    const rightCoefficient = numIndex < previousLineSize ? previousLine[numIndex] : 0;
+    const leftCoefficient = numIndex - 1 >= 0 ? previousLine[numIndex - 1] : 0;
+    const rightCoefficient =
+      numIndex < previousLineSize ? previousLine[numIndex] : 0;
 
     currentLine[numIndex] = leftCoefficient + rightCoefficient;
   }
 
   return currentLine;
 }
+
diff --git a/src/algorithms/math/primality-test/__test__/trialDivision.test.js b/src/algorithms/math/primality-test/__test__/trialDivision.test.js
index 224e840..9ff1113 100644
--- a/src/algorithms/math/primality-test/__test__/trialDivision.test.js
+++ b/src/algorithms/math/primality-test/__test__/trialDivision.test.js
@@ -1,4 +1,4 @@
-import trialDivision from '../trialDivision';
+import trialDivision from "../trialDivision";
 
 /**
  * @param {function(n: number)} testFunction
@@ -30,8 +30,9 @@ function primalityTest(testFunction) {
   expect(testFunction(10.5)).toBe(false);
 }
 
-describe('trialDivision', () => {
-  it('should detect prime numbers', () => {
+describe("trialDivision", () => {
+  it("should detect prime numbers", () => {
     primalityTest(trialDivision);
   });
 });
+
diff --git a/src/algorithms/math/primality-test/trialDivision.js b/src/algorithms/math/primality-test/trialDivision.js
index c347e05..91be3db 100644
--- a/src/algorithms/math/primality-test/trialDivision.js
+++ b/src/algorithms/math/primality-test/trialDivision.js
@@ -33,3 +33,4 @@ export default function trialDivision(number) {
 
   return true;
 }
+
diff --git a/src/algorithms/math/prime-factors/__test__/primeFactors.test.js b/src/algorithms/math/prime-factors/__test__/primeFactors.test.js
index 92c94d1..52f93ac 100644
--- a/src/algorithms/math/prime-factors/__test__/primeFactors.test.js
+++ b/src/algorithms/math/prime-factors/__test__/primeFactors.test.js
@@ -1,7 +1,4 @@
-import {
-  primeFactors,
-  hardyRamanujan,
-} from '../primeFactors';
+import { primeFactors, hardyRamanujan } from "../primeFactors";
 
 /**
  * Calculates the error between exact and approximate prime factor counts.
@@ -10,11 +7,11 @@ import {
  * @returns {number} - approximation error (percentage).
  */
 function approximationError(exactCount, approximateCount) {
-  return (Math.abs((exactCount - approximateCount) / exactCount) * 100);
+  return Math.abs((exactCount - approximateCount) / exactCount) * 100;
 }
 
-describe('primeFactors', () => {
-  it('should find prime factors', () => {
+describe("primeFactors", () => {
+  it("should find prime factors", () => {
     expect(primeFactors(1)).toEqual([]);
     expect(primeFactors(2)).toEqual([2]);
     expect(primeFactors(3)).toEqual([3]);
@@ -36,7 +33,7 @@ describe('primeFactors', () => {
     expect(primeFactors(873452453)).toEqual([149, 1637, 3581]);
   });
 
-  it('should give approximate prime factors count using Hardy-Ramanujan theorem', () => {
+  it("should give approximate prime factors count using Hardy-Ramanujan theorem", () => {
     expect(hardyRamanujan(2)).toBeCloseTo(-0.366, 2);
     expect(hardyRamanujan(4)).toBeCloseTo(0.326, 2);
     expect(hardyRamanujan(40)).toBeCloseTo(1.305, 2);
@@ -50,38 +47,53 @@ describe('primeFactors', () => {
     expect(hardyRamanujan(873452453)).toBeCloseTo(3.024, 2);
   });
 
-  it('should give correct deviation between exact and approx counts', () => {
-    expect(approximationError(primeFactors(2).length, hardyRamanujan(2)))
-      .toBeCloseTo(136.651, 2);
+  it("should give correct deviation between exact and approx counts", () => {
+    expect(
+      approximationError(primeFactors(2).length, hardyRamanujan(2))
+    ).toBeCloseTo(136.651, 2);
 
-    expect(approximationError(primeFactors(4).length, hardyRamanujan(2)))
-      .toBeCloseTo(118.325, 2);
+    expect(
+      approximationError(primeFactors(4).length, hardyRamanujan(2))
+    ).toBeCloseTo(118.325, 2);
 
-    expect(approximationError(primeFactors(40).length, hardyRamanujan(2)))
-      .toBeCloseTo(109.162, 2);
+    expect(
+      approximationError(primeFactors(40).length, hardyRamanujan(2))
+    ).toBeCloseTo(109.162, 2);
 
-    expect(approximationError(primeFactors(156).length, hardyRamanujan(2)))
-      .toBeCloseTo(109.162, 2);
+    expect(
+      approximationError(primeFactors(156).length, hardyRamanujan(2))
+    ).toBeCloseTo(109.162, 2);
 
-    expect(approximationError(primeFactors(980).length, hardyRamanujan(2)))
-      .toBeCloseTo(107.330, 2);
+    expect(
+      approximationError(primeFactors(980).length, hardyRamanujan(2))
+    ).toBeCloseTo(107.33, 2);
 
-    expect(approximationError(primeFactors(52734).length, hardyRamanujan(52734)))
-      .toBeCloseTo(52.274, 2);
+    expect(
+      approximationError(primeFactors(52734).length, hardyRamanujan(52734))
+    ).toBeCloseTo(52.274, 2);
 
-    expect(approximationError(primeFactors(343434).length, hardyRamanujan(343434)))
-      .toBeCloseTo(57.578, 2);
+    expect(
+      approximationError(primeFactors(343434).length, hardyRamanujan(343434))
+    ).toBeCloseTo(57.578, 2);
 
-    expect(approximationError(primeFactors(456745).length, hardyRamanujan(456745)))
-      .toBeCloseTo(14.420, 2);
+    expect(
+      approximationError(primeFactors(456745).length, hardyRamanujan(456745))
+    ).toBeCloseTo(14.42, 2);
 
-    expect(approximationError(primeFactors(510510).length, hardyRamanujan(510510)))
-      .toBeCloseTo(63.201, 2);
+    expect(
+      approximationError(primeFactors(510510).length, hardyRamanujan(510510))
+    ).toBeCloseTo(63.201, 2);
 
-    expect(approximationError(primeFactors(8735463).length, hardyRamanujan(8735463)))
-      .toBeCloseTo(30.712, 2);
+    expect(
+      approximationError(primeFactors(8735463).length, hardyRamanujan(8735463))
+    ).toBeCloseTo(30.712, 2);
 
-    expect(approximationError(primeFactors(873452453).length, hardyRamanujan(873452453)))
-      .toBeCloseTo(0.823, 2);
+    expect(
+      approximationError(
+        primeFactors(873452453).length,
+        hardyRamanujan(873452453)
+      )
+    ).toBeCloseTo(0.823, 2);
   });
 });
+
diff --git a/src/algorithms/math/prime-factors/primeFactors.js b/src/algorithms/math/prime-factors/primeFactors.js
index 691436c..65e8a54 100644
--- a/src/algorithms/math/prime-factors/primeFactors.js
+++ b/src/algorithms/math/prime-factors/primeFactors.js
@@ -40,3 +40,4 @@ export function primeFactors(n) {
 export function hardyRamanujan(n) {
   return Math.log(Math.log(n));
 }
+
diff --git a/src/algorithms/math/radian/__test__/degreeToRadian.test.js b/src/algorithms/math/radian/__test__/degreeToRadian.test.js
index dbf7751..b1087e3 100644
--- a/src/algorithms/math/radian/__test__/degreeToRadian.test.js
+++ b/src/algorithms/math/radian/__test__/degreeToRadian.test.js
@@ -1,7 +1,7 @@
-import degreeToRadian from '../degreeToRadian';
+import degreeToRadian from "../degreeToRadian";
 
-describe('degreeToRadian', () => {
-  it('should convert degree to radian', () => {
+describe("degreeToRadian", () => {
+  it("should convert degree to radian", () => {
     expect(degreeToRadian(0)).toBe(0);
     expect(degreeToRadian(45)).toBe(Math.PI / 4);
     expect(degreeToRadian(90)).toBe(Math.PI / 2);
@@ -10,3 +10,4 @@ describe('degreeToRadian', () => {
     expect(degreeToRadian(360)).toBe(2 * Math.PI);
   });
 });
+
diff --git a/src/algorithms/math/radian/__test__/radianToDegree.test.js b/src/algorithms/math/radian/__test__/radianToDegree.test.js
index 92f8b90..b20d10e 100644
--- a/src/algorithms/math/radian/__test__/radianToDegree.test.js
+++ b/src/algorithms/math/radian/__test__/radianToDegree.test.js
@@ -1,7 +1,7 @@
-import radianToDegree from '../radianToDegree';
+import radianToDegree from "../radianToDegree";
 
-describe('radianToDegree', () => {
-  it('should convert radian to degree', () => {
+describe("radianToDegree", () => {
+  it("should convert radian to degree", () => {
     expect(radianToDegree(0)).toBe(0);
     expect(radianToDegree(Math.PI / 4)).toBe(45);
     expect(radianToDegree(Math.PI / 2)).toBe(90);
@@ -10,3 +10,4 @@ describe('radianToDegree', () => {
     expect(radianToDegree(2 * Math.PI)).toBe(360);
   });
 });
+
diff --git a/src/algorithms/math/radian/degreeToRadian.js b/src/algorithms/math/radian/degreeToRadian.js
index fb3836c..21106df 100644
--- a/src/algorithms/math/radian/degreeToRadian.js
+++ b/src/algorithms/math/radian/degreeToRadian.js
@@ -5,3 +5,4 @@
 export default function degreeToRadian(degree) {
   return degree * (Math.PI / 180);
 }
+
diff --git a/src/algorithms/math/radian/radianToDegree.js b/src/algorithms/math/radian/radianToDegree.js
index e733f41..2195cd7 100644
--- a/src/algorithms/math/radian/radianToDegree.js
+++ b/src/algorithms/math/radian/radianToDegree.js
@@ -5,3 +5,4 @@
 export default function radianToDegree(radian) {
   return radian * (180 / Math.PI);
 }
+
diff --git a/src/algorithms/math/sieve-of-eratosthenes/__test__/sieveOfEratosthenes.test.js b/src/algorithms/math/sieve-of-eratosthenes/__test__/sieveOfEratosthenes.test.js
index f2bce60..707807c 100644
--- a/src/algorithms/math/sieve-of-eratosthenes/__test__/sieveOfEratosthenes.test.js
+++ b/src/algorithms/math/sieve-of-eratosthenes/__test__/sieveOfEratosthenes.test.js
@@ -1,12 +1,13 @@
-import sieveOfEratosthenes from '../sieveOfEratosthenes';
+import sieveOfEratosthenes from "../sieveOfEratosthenes";
 
-describe('sieveOfEratosthenes', () => {
-  it('should find all primes less than or equal to n', () => {
+describe("sieveOfEratosthenes", () => {
+  it("should find all primes less than or equal to n", () => {
     expect(sieveOfEratosthenes(5)).toEqual([2, 3, 5]);
     expect(sieveOfEratosthenes(10)).toEqual([2, 3, 5, 7]);
     expect(sieveOfEratosthenes(100)).toEqual([
-      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
-      43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
+      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
+      71, 73, 79, 83, 89, 97,
     ]);
   });
 });
+
diff --git a/src/algorithms/math/sieve-of-eratosthenes/sieveOfEratosthenes.js b/src/algorithms/math/sieve-of-eratosthenes/sieveOfEratosthenes.js
index 6b96583..3cff22c 100644
--- a/src/algorithms/math/sieve-of-eratosthenes/sieveOfEratosthenes.js
+++ b/src/algorithms/math/sieve-of-eratosthenes/sieveOfEratosthenes.js
@@ -34,3 +34,4 @@ export default function sieveOfEratosthenes(maxNumber) {
 
   return primes;
 }
+
diff --git a/src/algorithms/math/square-root/__test__/squareRoot.test.js b/src/algorithms/math/square-root/__test__/squareRoot.test.js
index 9679d1a..f9792a2 100644
--- a/src/algorithms/math/square-root/__test__/squareRoot.test.js
+++ b/src/algorithms/math/square-root/__test__/squareRoot.test.js
@@ -1,14 +1,14 @@
-import squareRoot from '../squareRoot';
+import squareRoot from "../squareRoot";
 
-describe('squareRoot', () => {
-  it('should throw for negative numbers', () => {
+describe("squareRoot", () => {
+  it("should throw for negative numbers", () => {
     function failingSquareRoot() {
       squareRoot(-5);
     }
     expect(failingSquareRoot).toThrow();
   });
 
-  it('should correctly calculate square root with default tolerance', () => {
+  it("should correctly calculate square root with default tolerance", () => {
     expect(squareRoot(0)).toBe(0);
     expect(squareRoot(1)).toBe(1);
     expect(squareRoot(2)).toBe(1);
@@ -21,7 +21,7 @@ describe('squareRoot', () => {
     expect(squareRoot(14723)).toBe(121);
   });
 
-  it('should correctly calculate square root for integers with custom tolerance', () => {
+  it("should correctly calculate square root for integers with custom tolerance", () => {
     let tolerance = 1;
 
     expect(squareRoot(0, tolerance)).toBe(0);
@@ -62,8 +62,9 @@ describe('squareRoot', () => {
     expect(squareRoot(14723, tolerance)).toBe(121.3383698588);
   });
 
-  it('should correctly calculate square root for integers with custom tolerance', () => {
+  it("should correctly calculate square root for integers with custom tolerance", () => {
     expect(squareRoot(4.5, 10)).toBe(2.1213203436);
     expect(squareRoot(217.534, 10)).toBe(14.7490338667);
   });
 });
+
diff --git a/src/algorithms/math/square-root/squareRoot.js b/src/algorithms/math/square-root/squareRoot.js
index 19779bf..9c13f73 100644
--- a/src/algorithms/math/square-root/squareRoot.js
+++ b/src/algorithms/math/square-root/squareRoot.js
@@ -6,10 +6,12 @@
  * @param [tolerance] - how many precise numbers after the floating point we want to get.
  * @return {number}
  */
-export default function squareRoot(number, tolerance = 0) {
+export default function squareRoot(number) {
+  let tolerance =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
   // For now we won't support operations that involves manipulation with complex numbers.
   if (number < 0) {
-    throw new Error('The method supports only positive integers');
+    throw new Error("The method supports only positive integers");
   }
 
   // Handle edge case with finding the square root of zero.
@@ -25,16 +27,17 @@ export default function squareRoot(number, tolerance = 0) {
   // - if tolerance=1 then delta=0.1
   // - if tolerance=2 then delta=0.01
   // - and so on...
-  const requiredDelta = 1 / (10 ** tolerance);
+  const requiredDelta = 1 / 10 ** tolerance;
 
   // Approximating the root value to the point when we get a desired precision.
-  while (Math.abs(number - (root ** 2)) > requiredDelta) {
+  while (Math.abs(number - root ** 2) > requiredDelta) {
     // Newton's method reduces in this case to the so-called Babylonian method.
     // These methods generally yield approximate results, but can be made arbitrarily
     // precise by increasing the number of calculation steps.
-    root -= ((root ** 2) - number) / (2 * root);
+    root -= (root ** 2 - number) / (2 * root);
   }
 
   // Cut off undesired floating digits and return the root value.
-  return Math.round(root * (10 ** tolerance)) / (10 ** tolerance);
+  return Math.round(root * 10 ** tolerance) / 10 ** tolerance;
 }
+
diff --git a/src/algorithms/ml/k-means/__test__/kMeans.test.js b/src/algorithms/ml/k-means/__test__/kMeans.test.js
index 44a6f53..160af1c 100644
--- a/src/algorithms/ml/k-means/__test__/kMeans.test.js
+++ b/src/algorithms/ml/k-means/__test__/kMeans.test.js
@@ -1,40 +1,64 @@
-import KMeans from '../kMeans';
+import KMeans from "../kMeans";
 
-describe('kMeans', () => {
-  it('should throw an error on invalid data', () => {
+describe("kMeans", () => {
+  it("should throw an error on invalid data", () => {
     expect(() => {
       KMeans();
-    }).toThrowError('The data is empty');
+    }).toThrowError("The data is empty");
   });
 
-  it('should throw an error on inconsistent data', () => {
+  it("should throw an error on inconsistent data", () => {
     expect(() => {
       KMeans([[1, 2], [1]], 2);
-    }).toThrowError('Matrices have different shapes');
+    }).toThrowError("Matrices have different shapes");
   });
 
-  it('should find the nearest neighbour', () => {
-    const data = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
+  it("should find the nearest neighbour", () => {
+    const data = [
+      [1, 1],
+      [6, 2],
+      [3, 3],
+      [4, 5],
+      [9, 2],
+      [2, 4],
+      [8, 7],
+    ];
     const k = 2;
     const expectedClusters = [0, 1, 0, 1, 1, 0, 1];
     expect(KMeans(data, k)).toEqual(expectedClusters);
 
-    expect(KMeans([[0, 0], [0, 1], [10, 10]], 2)).toEqual(
-      [0, 0, 1],
-    );
+    expect(
+      KMeans(
+        [
+          [0, 0],
+          [0, 1],
+          [10, 10],
+        ],
+        2
+      )
+    ).toEqual([0, 0, 1]);
   });
 
-  it('should find the clusters with equal distances', () => {
-    const dataSet = [[0, 0], [1, 1], [2, 2]];
+  it("should find the clusters with equal distances", () => {
+    const dataSet = [
+      [0, 0],
+      [1, 1],
+      [2, 2],
+    ];
     const k = 3;
     const expectedCluster = [0, 1, 2];
     expect(KMeans(dataSet, k)).toEqual(expectedCluster);
   });
 
-  it('should find the nearest neighbour in 3D space', () => {
-    const dataSet = [[0, 0, 0], [0, 1, 0], [2, 0, 2]];
+  it("should find the nearest neighbour in 3D space", () => {
+    const dataSet = [
+      [0, 0, 0],
+      [0, 1, 0],
+      [2, 0, 2],
+    ];
     const k = 2;
     const expectedCluster = [1, 1, 0];
     expect(KMeans(dataSet, k)).toEqual(expectedCluster);
   });
 });
+
diff --git a/src/algorithms/ml/k-means/kMeans.js b/src/algorithms/ml/k-means/kMeans.js
index 4361eed..1624353 100644
--- a/src/algorithms/ml/k-means/kMeans.js
+++ b/src/algorithms/ml/k-means/kMeans.js
@@ -1,5 +1,5 @@
-import * as mtrx from '../../math/matrix/Matrix';
-import euclideanDistance from '../../math/euclidean-distance/euclideanDistance';
+import * as mtrx from "../../math/matrix/Matrix";
+import euclideanDistance from "../../math/euclidean-distance/euclideanDistance";
 
 /**
  * Classifies the point in space based on k-Means algorithm.
@@ -8,12 +8,10 @@ import euclideanDistance from '../../math/euclidean-distance/euclideanDistance';
  * @param {number} k - number of clusters
  * @return {number[]} - the class of the point
  */
-export default function KMeans(
-  data,
-  k = 1,
-) {
+export default function KMeans(data) {
+  let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
   if (!data) {
-    throw new Error('The data is empty');
+    throw new Error("The data is empty");
   }
 
   // Assign k clusters locations equal to the location of initial k points.
@@ -40,12 +38,12 @@ export default function KMeans(
       for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {
         distances[dataIndex][clusterIndex] = euclideanDistance(
           [clusterCenters[clusterIndex]],
-          [data[dataIndex]],
+          [data[dataIndex]]
         );
       }
       // Assign the closest cluster number to each dataSet point.
       const closestClusterIdx = distances[dataIndex].indexOf(
-        Math.min(...distances[dataIndex]),
+        Math.min(...distances[dataIndex])
       );
 
       // Check if data point class has been changed and we still need to re-iterate.
@@ -65,17 +63,28 @@ export default function KMeans(
         if (classes[dataIndex] === clusterIndex) {
           // Register one more data point of current cluster.
           clusterSize += 1;
-          for (let dimensionIndex = 0; dimensionIndex < dataDim; dimensionIndex += 1) {
+          for (
+            let dimensionIndex = 0;
+            dimensionIndex < dataDim;
+            dimensionIndex += 1
+          ) {
             // Add data point coordinates to the cluster center coordinates.
-            clusterCenters[clusterIndex][dimensionIndex] += data[dataIndex][dimensionIndex];
+            clusterCenters[clusterIndex][dimensionIndex] +=
+              data[dataIndex][dimensionIndex];
           }
         }
       }
       // Calculate the average for each cluster center coordinate.
-      for (let dimensionIndex = 0; dimensionIndex < dataDim; dimensionIndex += 1) {
-        clusterCenters[clusterIndex][dimensionIndex] = parseFloat(Number(
-          clusterCenters[clusterIndex][dimensionIndex] / clusterSize,
-        ).toFixed(2));
+      for (
+        let dimensionIndex = 0;
+        dimensionIndex < dataDim;
+        dimensionIndex += 1
+      ) {
+        clusterCenters[clusterIndex][dimensionIndex] = parseFloat(
+          Number(
+            clusterCenters[clusterIndex][dimensionIndex] / clusterSize
+          ).toFixed(2)
+        );
       }
     }
   }
@@ -83,3 +92,4 @@ export default function KMeans(
   // Return the clusters assigned.
   return classes;
 }
+
diff --git a/src/algorithms/ml/knn/__test__/knn.test.js b/src/algorithms/ml/knn/__test__/knn.test.js
index 302bf3b..3f38114 100644
--- a/src/algorithms/ml/knn/__test__/knn.test.js
+++ b/src/algorithms/ml/knn/__test__/knn.test.js
@@ -1,71 +1,103 @@
-import kNN from '../kNN';
+import kNN from "../kNN";
 
-describe('kNN', () => {
-  it('should throw an error on invalid data', () => {
+describe("kNN", () => {
+  it("should throw an error on invalid data", () => {
     expect(() => {
       kNN();
-    }).toThrowError('Either dataSet or labels or toClassify were not set');
+    }).toThrowError("Either dataSet or labels or toClassify were not set");
   });
 
-  it('should throw an error on invalid labels', () => {
+  it("should throw an error on invalid labels", () => {
     const noLabels = () => {
       kNN([[1, 1]]);
     };
-    expect(noLabels).toThrowError('Either dataSet or labels or toClassify were not set');
+    expect(noLabels).toThrowError(
+      "Either dataSet or labels or toClassify were not set"
+    );
   });
 
-  it('should throw an error on not giving classification vector', () => {
+  it("should throw an error on not giving classification vector", () => {
     const noClassification = () => {
       kNN([[1, 1]], [1]);
     };
-    expect(noClassification).toThrowError('Either dataSet or labels or toClassify were not set');
+    expect(noClassification).toThrowError(
+      "Either dataSet or labels or toClassify were not set"
+    );
   });
 
-  it('should throw an error on not giving classification vector', () => {
+  it("should throw an error on not giving classification vector", () => {
     const inconsistent = () => {
       kNN([[1, 1]], [1], [1]);
     };
-    expect(inconsistent).toThrowError('Matrices have different shapes');
+    expect(inconsistent).toThrowError("Matrices have different shapes");
   });
 
-  it('should find the nearest neighbour', () => {
+  it("should find the nearest neighbour", () => {
     let dataSet;
     let labels;
     let toClassify;
     let expectedClass;
 
-    dataSet = [[1, 1], [2, 2]];
+    dataSet = [
+      [1, 1],
+      [2, 2],
+    ];
     labels = [1, 2];
     toClassify = [1, 1];
     expectedClass = 1;
     expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);
 
-    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
+    dataSet = [
+      [1, 1],
+      [6, 2],
+      [3, 3],
+      [4, 5],
+      [9, 2],
+      [2, 4],
+      [8, 7],
+    ];
     labels = [1, 2, 1, 2, 1, 2, 1];
     toClassify = [1.25, 1.25];
     expectedClass = 1;
     expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);
 
-    dataSet = [[1, 1], [6, 2], [3, 3], [4, 5], [9, 2], [2, 4], [8, 7]];
+    dataSet = [
+      [1, 1],
+      [6, 2],
+      [3, 3],
+      [4, 5],
+      [9, 2],
+      [2, 4],
+      [8, 7],
+    ];
     labels = [1, 2, 1, 2, 1, 2, 1];
     toClassify = [1.25, 1.25];
     expectedClass = 2;
     expect(kNN(dataSet, labels, toClassify, 5)).toBe(expectedClass);
   });
 
-  it('should find the nearest neighbour with equal distances', () => {
-    const dataSet = [[0, 0], [1, 1], [0, 2]];
+  it("should find the nearest neighbour with equal distances", () => {
+    const dataSet = [
+      [0, 0],
+      [1, 1],
+      [0, 2],
+    ];
     const labels = [1, 3, 3];
     const toClassify = [0, 1];
     const expectedClass = 3;
     expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);
   });
 
-  it('should find the nearest neighbour in 3D space', () => {
-    const dataSet = [[0, 0, 0], [0, 1, 1], [0, 0, 2]];
+  it("should find the nearest neighbour in 3D space", () => {
+    const dataSet = [
+      [0, 0, 0],
+      [0, 1, 1],
+      [0, 0, 2],
+    ];
     const labels = [1, 3, 3];
     const toClassify = [0, 0, 1];
     const expectedClass = 3;
     expect(kNN(dataSet, labels, toClassify)).toBe(expectedClass);
   });
 });
+
diff --git a/src/algorithms/ml/knn/kNN.js b/src/algorithms/ml/knn/kNN.js
index 350e7ce..e33a52f 100644
--- a/src/algorithms/ml/knn/kNN.js
+++ b/src/algorithms/ml/knn/kNN.js
@@ -8,16 +8,12 @@
  * @return {number} - the class of the point
  */
 
-import euclideanDistance from '../../math/euclidean-distance/euclideanDistance';
+import euclideanDistance from "../../math/euclidean-distance/euclideanDistance";
 
-export default function kNN(
-  dataSet,
-  labels,
-  toClassify,
-  k = 3,
-) {
+export default function kNN(dataSet, labels, toClassify) {
+  let k = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;
   if (!dataSet || !labels || !toClassify) {
-    throw new Error('Either dataSet or labels or toClassify were not set');
+    throw new Error("Either dataSet or labels or toClassify were not set");
   }
 
   // Calculate distance from toClassify to each point for all dimensions in dataSet.
@@ -32,12 +28,14 @@ export default function kNN(
 
   // Sort distances list (from closer point to further ones).
   // Take initial k values, count with class index
-  const kNearest = distances.sort((a, b) => {
-    if (a.dist === b.dist) {
-      return 0;
-    }
-    return a.dist < b.dist ? -1 : 1;
-  }).slice(0, k);
+  const kNearest = distances
+    .sort((a, b) => {
+      if (a.dist === b.dist) {
+        return 0;
+      }
+      return a.dist < b.dist ? -1 : 1;
+    })
+    .slice(0, k);
 
   // Count the number of instances of each class in top k members.
   const labelsCounter = {};
@@ -58,3 +56,4 @@ export default function kNN(
   // Return the class with highest count.
   return topClass;
 }
+
diff --git a/src/algorithms/search/binary-search/__test__/binarySearch.test.js b/src/algorithms/search/binary-search/__test__/binarySearch.test.js
index 72c2b34..6776439 100644
--- a/src/algorithms/search/binary-search/__test__/binarySearch.test.js
+++ b/src/algorithms/search/binary-search/__test__/binarySearch.test.js
@@ -1,7 +1,7 @@
-import binarySearch from '../binarySearch';
+import binarySearch from "../binarySearch";
 
-describe('binarySearch', () => {
-  it('should search number in sorted array', () => {
+describe("binarySearch", () => {
+  it("should search number in sorted array", () => {
     expect(binarySearch([], 1)).toBe(-1);
     expect(binarySearch([1], 1)).toBe(0);
     expect(binarySearch([1, 2], 1)).toBe(0);
@@ -13,11 +13,11 @@ describe('binarySearch', () => {
     expect(binarySearch([1, 5, 10, 12, 14, 17, 22, 100], 0)).toBe(-1);
   });
 
-  it('should search object in sorted array', () => {
+  it("should search object in sorted array", () => {
     const sortedArrayOfObjects = [
-      { key: 1, value: 'value1' },
-      { key: 2, value: 'value2' },
-      { key: 3, value: 'value3' },
+      { key: 1, value: "value1" },
+      { key: 2, value: "value2" },
+      { key: 3, value: "value3" },
     ];
 
     const comparator = (a, b) => {
@@ -32,3 +32,4 @@ describe('binarySearch', () => {
     expect(binarySearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
   });
 });
+
diff --git a/src/algorithms/search/binary-search/binarySearch.js b/src/algorithms/search/binary-search/binarySearch.js
index b9e18aa..9c11c17 100644
--- a/src/algorithms/search/binary-search/binarySearch.js
+++ b/src/algorithms/search/binary-search/binarySearch.js
@@ -1,4 +1,4 @@
-import Comparator from '../../../utils/comparator/Comparator';
+import Comparator from "../../../utils/comparator/Comparator";
 
 /**
  * Binary search implementation.
@@ -9,7 +9,11 @@ import Comparator from '../../../utils/comparator/Comparator';
  * @return {number}
  */
 
-export default function binarySearch(sortedArray, seekElement, comparatorCallback) {
+export default function binarySearch(
+  sortedArray,
+  seekElement,
+  comparatorCallback
+) {
   // Let's create comparator from the comparatorCallback function.
   // Comparator object will give us common comparison methods like equal() and lessThen().
   const comparator = new Comparator(comparatorCallback);
@@ -42,3 +46,4 @@ export default function binarySearch(sortedArray, seekElement, comparatorCallbac
   // Return -1 if we have not found anything.
   return -1;
 }
+
diff --git a/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js b/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js
index 7ddc548..b90631d 100644
--- a/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js
+++ b/src/algorithms/search/interpolation-search/__test__/interpolationSearch.test.js
@@ -1,7 +1,7 @@
-import interpolationSearch from '../interpolationSearch';
+import interpolationSearch from "../interpolationSearch";
 
-describe('interpolationSearch', () => {
-  it('should search elements in sorted array of numbers', () => {
+describe("interpolationSearch", () => {
+  it("should search elements in sorted array of numbers", () => {
     expect(interpolationSearch([], 1)).toBe(-1);
     expect(interpolationSearch([1], 1)).toBe(0);
     expect(interpolationSearch([1], 0)).toBe(-1);
@@ -9,16 +9,43 @@ describe('interpolationSearch', () => {
     expect(interpolationSearch([1, 2], 1)).toBe(0);
     expect(interpolationSearch([1, 2], 2)).toBe(1);
     expect(interpolationSearch([10, 20, 30, 40, 50], 40)).toBe(3);
-    expect(interpolationSearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 14)).toBe(13);
-    expect(interpolationSearch([1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300], 24)).toBe(10);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)).toBe(-1);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)).toBe(0);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)).toBe(1);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)).toBe(2);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)).toBe(3);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)).toBe(4);
-    expect(interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)).toBe(5);
-    expect(interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)).toBe(4);
+    expect(
+      interpolationSearch(
+        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
+        14
+      )
+    ).toBe(13);
+    expect(
+      interpolationSearch(
+        [1, 6, 7, 8, 12, 13, 14, 19, 21, 23, 24, 24, 24, 300],
+        24
+      )
+    ).toBe(10);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 600)
+    ).toBe(-1);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1)
+    ).toBe(0);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 2)
+    ).toBe(1);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 3)
+    ).toBe(2);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 700)
+    ).toBe(3);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 800)
+    ).toBe(4);
+    expect(
+      interpolationSearch([0, 2, 3, 700, 800, 1200, 1300, 1400, 1900], 1200)
+    ).toBe(5);
+    expect(
+      interpolationSearch([1, 2, 3, 700, 800, 1200, 1300, 1400, 19000], 800)
+    ).toBe(4);
     expect(interpolationSearch([0, 10, 11, 12, 13, 14, 15], 10)).toBe(1);
   });
 });
+
diff --git a/src/algorithms/search/interpolation-search/interpolationSearch.js b/src/algorithms/search/interpolation-search/interpolationSearch.js
index 8546c5b..cb3c900 100644
--- a/src/algorithms/search/interpolation-search/interpolationSearch.js
+++ b/src/algorithms/search/interpolation-search/interpolationSearch.js
@@ -31,7 +31,8 @@ export default function interpolationSearch(sortedArray, seekElement) {
     }
 
     // Do interpolation of the middle index.
-    const middleIndex = leftIndex + Math.floor((valueDelta * indexDelta) / rangeDelta);
+    const middleIndex =
+      leftIndex + Math.floor((valueDelta * indexDelta) / rangeDelta);
 
     // If we've found the element just return its position.
     if (sortedArray[middleIndex] === seekElement) {
@@ -50,3 +51,4 @@ export default function interpolationSearch(sortedArray, seekElement) {
 
   return -1;
 }
+
diff --git a/src/algorithms/search/jump-search/__test__/jumpSearch.test.js b/src/algorithms/search/jump-search/__test__/jumpSearch.test.js
index 32f4d3f..a1e2844 100644
--- a/src/algorithms/search/jump-search/__test__/jumpSearch.test.js
+++ b/src/algorithms/search/jump-search/__test__/jumpSearch.test.js
@@ -1,7 +1,7 @@
-import jumpSearch from '../jumpSearch';
+import jumpSearch from "../jumpSearch";
 
-describe('jumpSearch', () => {
-  it('should search for an element in sorted array', () => {
+describe("jumpSearch", () => {
+  it("should search for an element in sorted array", () => {
     expect(jumpSearch([], 1)).toBe(-1);
     expect(jumpSearch([1], 2)).toBe(-1);
     expect(jumpSearch([1], 1)).toBe(0);
@@ -18,11 +18,11 @@ describe('jumpSearch', () => {
     expect(jumpSearch([1, 2, 5, 10, 20, 21, 24, 30, 48], 48)).toBe(8);
   });
 
-  it('should search object in sorted array', () => {
+  it("should search object in sorted array", () => {
     const sortedArrayOfObjects = [
-      { key: 1, value: 'value1' },
-      { key: 2, value: 'value2' },
-      { key: 3, value: 'value3' },
+      { key: 1, value: "value1" },
+      { key: 2, value: "value2" },
+      { key: 3, value: "value3" },
     ];
 
     const comparator = (a, b) => {
@@ -37,3 +37,4 @@ describe('jumpSearch', () => {
     expect(jumpSearch(sortedArrayOfObjects, { key: 3 }, comparator)).toBe(2);
   });
 });
+
diff --git a/src/algorithms/search/jump-search/jumpSearch.js b/src/algorithms/search/jump-search/jumpSearch.js
index b8c8c24..dc5e8f1 100644
--- a/src/algorithms/search/jump-search/jumpSearch.js
+++ b/src/algorithms/search/jump-search/jumpSearch.js
@@ -1,4 +1,4 @@
-import Comparator from '../../../utils/comparator/Comparator';
+import Comparator from "../../../utils/comparator/Comparator";
 
 /**
  * Jump (block) search implementation.
@@ -8,7 +8,11 @@ import Comparator from '../../../utils/comparator/Comparator';
  * @param {function(a, b)} [comparatorCallback]
  * @return {number}
  */
-export default function jumpSearch(sortedArray, seekElement, comparatorCallback) {
+export default function jumpSearch(
+  sortedArray,
+  seekElement,
+  comparatorCallback
+) {
   const comparator = new Comparator(comparatorCallback);
   const arraySize = sortedArray.length;
 
@@ -26,7 +30,12 @@ export default function jumpSearch(sortedArray, seekElement, comparatorCallback)
   // Find the block where the seekElement belong to.
   let blockStart = 0;
   let blockEnd = jumpSize;
-  while (comparator.greaterThan(seekElement, sortedArray[Math.min(blockEnd, arraySize) - 1])) {
+  while (
+    comparator.greaterThan(
+      seekElement,
+      sortedArray[Math.min(blockEnd, arraySize) - 1]
+    )
+  ) {
     // Jump to the next block.
     blockStart = blockEnd;
     blockEnd += jumpSize;
@@ -49,3 +58,4 @@ export default function jumpSearch(sortedArray, seekElement, comparatorCallback)
 
   return -1;
 }
+
diff --git a/src/algorithms/search/linear-search/__test__/linearSearch.test.js b/src/algorithms/search/linear-search/__test__/linearSearch.test.js
index c578fd1..8973fc9 100644
--- a/src/algorithms/search/linear-search/__test__/linearSearch.test.js
+++ b/src/algorithms/search/linear-search/__test__/linearSearch.test.js
@@ -1,7 +1,7 @@
-import linearSearch from '../linearSearch';
+import linearSearch from "../linearSearch";
 
-describe('linearSearch', () => {
-  it('should search all numbers in array', () => {
+describe("linearSearch", () => {
+  it("should search all numbers in array", () => {
     const array = [1, 2, 4, 6, 2];
 
     expect(linearSearch(array, 10)).toEqual([]);
@@ -9,15 +9,15 @@ describe('linearSearch', () => {
     expect(linearSearch(array, 2)).toEqual([1, 4]);
   });
 
-  it('should search all strings in array', () => {
-    const array = ['a', 'b', 'a'];
+  it("should search all strings in array", () => {
+    const array = ["a", "b", "a"];
 
-    expect(linearSearch(array, 'c')).toEqual([]);
-    expect(linearSearch(array, 'b')).toEqual([1]);
-    expect(linearSearch(array, 'a')).toEqual([0, 2]);
+    expect(linearSearch(array, "c")).toEqual([]);
+    expect(linearSearch(array, "b")).toEqual([1]);
+    expect(linearSearch(array, "a")).toEqual([0, 2]);
   });
 
-  it('should search through objects as well', () => {
+  it("should search through objects as well", () => {
     const comparatorCallback = (a, b) => {
       if (a.key === b.key) {
         return 0;
@@ -26,15 +26,11 @@ describe('linearSearch', () => {
       return a.key <= b.key ? -1 : 1;
     };
 
-    const array = [
-      { key: 5 },
-      { key: 6 },
-      { key: 7 },
-      { key: 6 },
-    ];
+    const array = [{ key: 5 }, { key: 6 }, { key: 7 }, { key: 6 }];
 
     expect(linearSearch(array, { key: 10 }, comparatorCallback)).toEqual([]);
     expect(linearSearch(array, { key: 5 }, comparatorCallback)).toEqual([0]);
     expect(linearSearch(array, { key: 6 }, comparatorCallback)).toEqual([1, 3]);
   });
 });
+
diff --git a/src/algorithms/search/linear-search/linearSearch.js b/src/algorithms/search/linear-search/linearSearch.js
index c5fb67c..5006b2d 100644
--- a/src/algorithms/search/linear-search/linearSearch.js
+++ b/src/algorithms/search/linear-search/linearSearch.js
@@ -1,4 +1,4 @@
-import Comparator from '../../../utils/comparator/Comparator';
+import Comparator from "../../../utils/comparator/Comparator";
 
 /**
  * Linear search implementation.
@@ -20,3 +20,4 @@ export default function linearSearch(array, seekElement, comparatorCallback) {
 
   return foundIndices;
 }
+
diff --git a/src/algorithms/sets/cartesian-product/__test__/cartesianProduct.test.js b/src/algorithms/sets/cartesian-product/__test__/cartesianProduct.test.js
index f9154fa..cf70f71 100644
--- a/src/algorithms/sets/cartesian-product/__test__/cartesianProduct.test.js
+++ b/src/algorithms/sets/cartesian-product/__test__/cartesianProduct.test.js
@@ -1,7 +1,7 @@
-import cartesianProduct from '../cartesianProduct';
+import cartesianProduct from "../cartesianProduct";
 
-describe('cartesianProduct', () => {
-  it('should return null if there is not enough info for calculation', () => {
+describe("cartesianProduct", () => {
+  it("should return null if there is not enough info for calculation", () => {
     const product1 = cartesianProduct([1], null);
     const product2 = cartesianProduct([], null);
 
@@ -9,11 +9,17 @@ describe('cartesianProduct', () => {
     expect(product2).toBeNull();
   });
 
-  it('should calculate the product of two sets', () => {
+  it("should calculate the product of two sets", () => {
     const product1 = cartesianProduct([1], [1]);
     const product2 = cartesianProduct([1, 2], [3, 5]);
 
     expect(product1).toEqual([[1, 1]]);
-    expect(product2).toEqual([[1, 3], [1, 5], [2, 3], [2, 5]]);
+    expect(product2).toEqual([
+      [1, 3],
+      [1, 5],
+      [2, 3],
+      [2, 5],
+    ]);
   });
 });
+
diff --git a/src/algorithms/sets/cartesian-product/cartesianProduct.js b/src/algorithms/sets/cartesian-product/cartesianProduct.js
index 14924fa..1c4b4c2 100644
--- a/src/algorithms/sets/cartesian-product/cartesianProduct.js
+++ b/src/algorithms/sets/cartesian-product/cartesianProduct.js
@@ -25,3 +25,4 @@ export default function cartesianProduct(setA, setB) {
   // Return cartesian product set.
   return product;
 }
+
diff --git a/src/algorithms/sets/combination-sum/__test__/combinationSum.test.js b/src/algorithms/sets/combination-sum/__test__/combinationSum.test.js
index 7b196bf..cda7998 100644
--- a/src/algorithms/sets/combination-sum/__test__/combinationSum.test.js
+++ b/src/algorithms/sets/combination-sum/__test__/combinationSum.test.js
@@ -1,15 +1,10 @@
-import combinationSum from '../combinationSum';
+import combinationSum from "../combinationSum";
 
-describe('combinationSum', () => {
-  it('should find all combinations with specific sum', () => {
-    expect(combinationSum([1], 4)).toEqual([
-      [1, 1, 1, 1],
-    ]);
+describe("combinationSum", () => {
+  it("should find all combinations with specific sum", () => {
+    expect(combinationSum([1], 4)).toEqual([[1, 1, 1, 1]]);
 
-    expect(combinationSum([2, 3, 6, 7], 7)).toEqual([
-      [2, 2, 3],
-      [7],
-    ]);
+    expect(combinationSum([2, 3, 6, 7], 7)).toEqual([[2, 2, 3], [7]]);
 
     expect(combinationSum([2, 3, 5], 8)).toEqual([
       [2, 2, 2, 2],
@@ -22,3 +17,4 @@ describe('combinationSum', () => {
     expect(combinationSum([], 3)).toEqual([]);
   });
 });
+
diff --git a/src/algorithms/sets/combination-sum/combinationSum.js b/src/algorithms/sets/combination-sum/combinationSum.js
index dd396a8..9c837a6 100644
--- a/src/algorithms/sets/combination-sum/combinationSum.js
+++ b/src/algorithms/sets/combination-sum/combinationSum.js
@@ -6,13 +6,13 @@
  * @param {number} startFrom - index of the candidate to start further exploration from.
  * @return {number[][]}
  */
-function combinationSumRecursive(
-  candidates,
-  remainingSum,
-  finalCombinations = [],
-  currentCombination = [],
-  startFrom = 0,
-) {
+function combinationSumRecursive(candidates, remainingSum) {
+  let finalCombinations =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  let currentCombination =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
+  let startFrom =
+    arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
   if (remainingSum < 0) {
     // By adding another candidate we've gone below zero.
     // This would mean that the last candidate was not acceptable.
@@ -30,7 +30,11 @@ function combinationSumRecursive(
 
   // If we haven't reached zero yet let's continue to add all
   // possible candidates that are left.
-  for (let candidateIndex = startFrom; candidateIndex < candidates.length; candidateIndex += 1) {
+  for (
+    let candidateIndex = startFrom;
+    candidateIndex < candidates.length;
+    candidateIndex += 1
+  ) {
     const currentCandidate = candidates[candidateIndex];
 
     // Let's try to add another candidate.
@@ -42,7 +46,7 @@ function combinationSumRecursive(
       remainingSum - currentCandidate,
       finalCombinations,
       currentCombination,
-      candidateIndex,
+      candidateIndex
     );
 
     // BACKTRACKING.
@@ -63,3 +67,4 @@ function combinationSumRecursive(
 export default function combinationSum(candidates, target) {
   return combinationSumRecursive(candidates, target);
 }
+
diff --git a/src/algorithms/sets/combinations/__test__/combineWithRepetitions.test.js b/src/algorithms/sets/combinations/__test__/combineWithRepetitions.test.js
index 90c3895..0069fbe 100644
--- a/src/algorithms/sets/combinations/__test__/combineWithRepetitions.test.js
+++ b/src/algorithms/sets/combinations/__test__/combineWithRepetitions.test.js
@@ -1,59 +1,59 @@
-import combineWithRepetitions from '../combineWithRepetitions';
-import factorial from '../../../math/factorial/factorial';
+import combineWithRepetitions from "../combineWithRepetitions";
+import factorial from "../../../math/factorial/factorial";
 
-describe('combineWithRepetitions', () => {
-  it('should combine string with repetitions', () => {
-    expect(combineWithRepetitions(['A'], 1)).toEqual([
-      ['A'],
-    ]);
+describe("combineWithRepetitions", () => {
+  it("should combine string with repetitions", () => {
+    expect(combineWithRepetitions(["A"], 1)).toEqual([["A"]]);
 
-    expect(combineWithRepetitions(['A', 'B'], 1)).toEqual([
-      ['A'],
-      ['B'],
-    ]);
+    expect(combineWithRepetitions(["A", "B"], 1)).toEqual([["A"], ["B"]]);
 
-    expect(combineWithRepetitions(['A', 'B'], 2)).toEqual([
-      ['A', 'A'],
-      ['A', 'B'],
-      ['B', 'B'],
+    expect(combineWithRepetitions(["A", "B"], 2)).toEqual([
+      ["A", "A"],
+      ["A", "B"],
+      ["B", "B"],
     ]);
 
-    expect(combineWithRepetitions(['A', 'B'], 3)).toEqual([
-      ['A', 'A', 'A'],
-      ['A', 'A', 'B'],
-      ['A', 'B', 'B'],
-      ['B', 'B', 'B'],
+    expect(combineWithRepetitions(["A", "B"], 3)).toEqual([
+      ["A", "A", "A"],
+      ["A", "A", "B"],
+      ["A", "B", "B"],
+      ["B", "B", "B"],
     ]);
 
-    expect(combineWithRepetitions(['A', 'B', 'C'], 2)).toEqual([
-      ['A', 'A'],
-      ['A', 'B'],
-      ['A', 'C'],
-      ['B', 'B'],
-      ['B', 'C'],
-      ['C', 'C'],
+    expect(combineWithRepetitions(["A", "B", "C"], 2)).toEqual([
+      ["A", "A"],
+      ["A", "B"],
+      ["A", "C"],
+      ["B", "B"],
+      ["B", "C"],
+      ["C", "C"],
     ]);
 
-    expect(combineWithRepetitions(['A', 'B', 'C'], 3)).toEqual([
-      ['A', 'A', 'A'],
-      ['A', 'A', 'B'],
-      ['A', 'A', 'C'],
-      ['A', 'B', 'B'],
-      ['A', 'B', 'C'],
-      ['A', 'C', 'C'],
-      ['B', 'B', 'B'],
-      ['B', 'B', 'C'],
-      ['B', 'C', 'C'],
-      ['C', 'C', 'C'],
+    expect(combineWithRepetitions(["A", "B", "C"], 3)).toEqual([
+      ["A", "A", "A"],
+      ["A", "A", "B"],
+      ["A", "A", "C"],
+      ["A", "B", "B"],
+      ["A", "B", "C"],
+      ["A", "C", "C"],
+      ["B", "B", "B"],
+      ["B", "B", "C"],
+      ["B", "C", "C"],
+      ["C", "C", "C"],
     ]);
 
-    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
+    const combinationOptions = ["A", "B", "C", "D", "E", "F", "G", "H"];
     const combinationSlotsNumber = 4;
-    const combinations = combineWithRepetitions(combinationOptions, combinationSlotsNumber);
+    const combinations = combineWithRepetitions(
+      combinationOptions,
+      combinationSlotsNumber
+    );
     const n = combinationOptions.length;
     const r = combinationSlotsNumber;
-    const expectedNumberOfCombinations = factorial((r + n) - 1) / (factorial(r) * factorial(n - 1));
+    const expectedNumberOfCombinations =
+      factorial(r + n - 1) / (factorial(r) * factorial(n - 1));
 
     expect(combinations.length).toBe(expectedNumberOfCombinations);
   });
 });
+
diff --git a/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js b/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js
index d35e00f..324aaa5 100644
--- a/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js
+++ b/src/algorithms/sets/combinations/__test__/combineWithoutRepetitions.test.js
@@ -1,60 +1,57 @@
-import combineWithoutRepetitions from '../combineWithoutRepetitions';
-import factorial from '../../../math/factorial/factorial';
-import pascalTriangle from '../../../math/pascal-triangle/pascalTriangle';
+import combineWithoutRepetitions from "../combineWithoutRepetitions";
+import factorial from "../../../math/factorial/factorial";
+import pascalTriangle from "../../../math/pascal-triangle/pascalTriangle";
 
-describe('combineWithoutRepetitions', () => {
-  it('should combine string without repetitions', () => {
-    expect(combineWithoutRepetitions(['A', 'B'], 3)).toEqual([]);
+describe("combineWithoutRepetitions", () => {
+  it("should combine string without repetitions", () => {
+    expect(combineWithoutRepetitions(["A", "B"], 3)).toEqual([]);
 
-    expect(combineWithoutRepetitions(['A', 'B'], 1)).toEqual([
-      ['A'],
-      ['B'],
-    ]);
+    expect(combineWithoutRepetitions(["A", "B"], 1)).toEqual([["A"], ["B"]]);
 
-    expect(combineWithoutRepetitions(['A'], 1)).toEqual([
-      ['A'],
-    ]);
+    expect(combineWithoutRepetitions(["A"], 1)).toEqual([["A"]]);
 
-    expect(combineWithoutRepetitions(['A', 'B'], 2)).toEqual([
-      ['A', 'B'],
-    ]);
+    expect(combineWithoutRepetitions(["A", "B"], 2)).toEqual([["A", "B"]]);
 
-    expect(combineWithoutRepetitions(['A', 'B', 'C'], 2)).toEqual([
-      ['A', 'B'],
-      ['A', 'C'],
-      ['B', 'C'],
+    expect(combineWithoutRepetitions(["A", "B", "C"], 2)).toEqual([
+      ["A", "B"],
+      ["A", "C"],
+      ["B", "C"],
     ]);
 
-    expect(combineWithoutRepetitions(['A', 'B', 'C'], 3)).toEqual([
-      ['A', 'B', 'C'],
+    expect(combineWithoutRepetitions(["A", "B", "C"], 3)).toEqual([
+      ["A", "B", "C"],
     ]);
 
-    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D'], 3)).toEqual([
-      ['A', 'B', 'C'],
-      ['A', 'B', 'D'],
-      ['A', 'C', 'D'],
-      ['B', 'C', 'D'],
+    expect(combineWithoutRepetitions(["A", "B", "C", "D"], 3)).toEqual([
+      ["A", "B", "C"],
+      ["A", "B", "D"],
+      ["A", "C", "D"],
+      ["B", "C", "D"],
     ]);
 
-    expect(combineWithoutRepetitions(['A', 'B', 'C', 'D', 'E'], 3)).toEqual([
-      ['A', 'B', 'C'],
-      ['A', 'B', 'D'],
-      ['A', 'B', 'E'],
-      ['A', 'C', 'D'],
-      ['A', 'C', 'E'],
-      ['A', 'D', 'E'],
-      ['B', 'C', 'D'],
-      ['B', 'C', 'E'],
-      ['B', 'D', 'E'],
-      ['C', 'D', 'E'],
+    expect(combineWithoutRepetitions(["A", "B", "C", "D", "E"], 3)).toEqual([
+      ["A", "B", "C"],
+      ["A", "B", "D"],
+      ["A", "B", "E"],
+      ["A", "C", "D"],
+      ["A", "C", "E"],
+      ["A", "D", "E"],
+      ["B", "C", "D"],
+      ["B", "C", "E"],
+      ["B", "D", "E"],
+      ["C", "D", "E"],
     ]);
 
-    const combinationOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
+    const combinationOptions = ["A", "B", "C", "D", "E", "F", "G", "H"];
     const combinationSlotsNumber = 4;
-    const combinations = combineWithoutRepetitions(combinationOptions, combinationSlotsNumber);
+    const combinations = combineWithoutRepetitions(
+      combinationOptions,
+      combinationSlotsNumber
+    );
     const n = combinationOptions.length;
     const r = combinationSlotsNumber;
-    const expectedNumberOfCombinations = factorial(n) / (factorial(r) * factorial(n - r));
+    const expectedNumberOfCombinations =
+      factorial(n) / (factorial(r) * factorial(n - r));
 
     expect(combinations.length).toBe(expectedNumberOfCombinations);
 
@@ -62,3 +59,4 @@ describe('combineWithoutRepetitions', () => {
     expect(combinations.length).toBe(pascalTriangle(n)[r]);
   });
 });
+
diff --git a/src/algorithms/sets/combinations/combineWithRepetitions.js b/src/algorithms/sets/combinations/combineWithRepetitions.js
index 5e25635..95f08c5 100644
--- a/src/algorithms/sets/combinations/combineWithRepetitions.js
+++ b/src/algorithms/sets/combinations/combineWithRepetitions.js
@@ -19,7 +19,7 @@ export default function combineWithRepetitions(comboOptions, comboLength) {
     // Generate combinations of smaller size.
     const smallerCombos = combineWithRepetitions(
       comboOptions.slice(optionIndex),
-      comboLength - 1,
+      comboLength - 1
     );
 
     // Concatenate currentOption with all combinations of smaller size.
@@ -30,3 +30,4 @@ export default function combineWithRepetitions(comboOptions, comboLength) {
 
   return combos;
 }
+
diff --git a/src/algorithms/sets/combinations/combineWithoutRepetitions.js b/src/algorithms/sets/combinations/combineWithoutRepetitions.js
index 38fb850..885e87c 100644
--- a/src/algorithms/sets/combinations/combineWithoutRepetitions.js
+++ b/src/algorithms/sets/combinations/combineWithoutRepetitions.js
@@ -19,7 +19,7 @@ export default function combineWithoutRepetitions(comboOptions, comboLength) {
     // Generate combinations of smaller size.
     const smallerCombos = combineWithoutRepetitions(
       comboOptions.slice(optionIndex + 1),
-      comboLength - 1,
+      comboLength - 1
     );
 
     // Concatenate currentOption with all combinations of smaller size.
@@ -30,3 +30,4 @@ export default function combineWithoutRepetitions(comboOptions, comboLength) {
 
   return combos;
 }
+
diff --git a/src/algorithms/sets/fisher-yates/__test__/fisherYates.test.js b/src/algorithms/sets/fisher-yates/__test__/fisherYates.test.js
index f43a7b7..56471f8 100644
--- a/src/algorithms/sets/fisher-yates/__test__/fisherYates.test.js
+++ b/src/algorithms/sets/fisher-yates/__test__/fisherYates.test.js
@@ -1,14 +1,14 @@
-import fisherYates from '../fisherYates';
-import { sortedArr } from '../../../sorting/SortTester';
-import QuickSort from '../../../sorting/quick-sort/QuickSort';
+import fisherYates from "../fisherYates";
+import { sortedArr } from "../../../sorting/SortTester";
+import QuickSort from "../../../sorting/quick-sort/QuickSort";
 
-describe('fisherYates', () => {
-  it('should shuffle small arrays', () => {
+describe("fisherYates", () => {
+  it("should shuffle small arrays", () => {
     expect(fisherYates([])).toEqual([]);
     expect(fisherYates([1])).toEqual([1]);
   });
 
-  it('should shuffle array randomly', () => {
+  it("should shuffle array randomly", () => {
     const shuffledArray = fisherYates(sortedArr);
     const sorter = new QuickSort();
 
@@ -17,3 +17,4 @@ describe('fisherYates', () => {
     expect(sorter.sort(shuffledArray)).toEqual(sortedArr);
   });
 });
+
diff --git a/src/algorithms/sets/fisher-yates/fisherYates.js b/src/algorithms/sets/fisher-yates/fisherYates.js
index 23b710b..ee20264 100644
--- a/src/algorithms/sets/fisher-yates/fisherYates.js
+++ b/src/algorithms/sets/fisher-yates/fisherYates.js
@@ -6,10 +6,13 @@ export default function fisherYates(originalArray) {
   // Clone array from preventing original array from modification (for testing purpose).
   const array = originalArray.slice(0);
 
-  for (let i = (array.length - 1); i > 0; i -= 1) {
+  for (let i = array.length - 1; i > 0; i -= 1) {
     const randomIndex = Math.floor(Math.random() * (i + 1));
-    [array[i], array[randomIndex]] = [array[randomIndex], array[i]];
+    var _ref = [array[randomIndex], array[i]];
+    array[i] = _ref[0];
+    array[randomIndex] = _ref[1];
   }
 
   return array;
 }
+
diff --git a/src/algorithms/sets/knapsack-problem/Knapsack.js b/src/algorithms/sets/knapsack-problem/Knapsack.js
index 5d14911..e2b32c5 100644
--- a/src/algorithms/sets/knapsack-problem/Knapsack.js
+++ b/src/algorithms/sets/knapsack-problem/Knapsack.js
@@ -1,4 +1,4 @@
-import MergeSort from '../../sorting/merge-sort/MergeSort';
+import MergeSort from "../../sorting/merge-sort/MergeSort";
 
 export default class Knapsack {
   /**
@@ -72,30 +72,49 @@ export default class Knapsack {
     // Create knapsack values matrix.
     const numberOfRows = this.possibleItems.length;
     const numberOfColumns = this.weightLimit;
-    const knapsackMatrix = Array(numberOfRows).fill(null).map(() => {
-      return Array(numberOfColumns + 1).fill(null);
-    });
+    const knapsackMatrix = Array(numberOfRows)
+      .fill(null)
+      .map(() => {
+        return Array(numberOfColumns + 1).fill(null);
+      });
 
     // Fill the first column with zeros since it would mean that there is
     // no items we can add to knapsack in case if weight limitation is zero.
-    for (let itemIndex = 0; itemIndex < this.possibleItems.length; itemIndex += 1) {
+    for (
+      let itemIndex = 0;
+      itemIndex < this.possibleItems.length;
+      itemIndex += 1
+    ) {
       knapsackMatrix[itemIndex][0] = 0;
     }
 
     // Fill the first row with max possible values we would get by just adding
     // or not adding the first item to the knapsack.
-    for (let weightIndex = 1; weightIndex <= this.weightLimit; weightIndex += 1) {
+    for (
+      let weightIndex = 1;
+      weightIndex <= this.weightLimit;
+      weightIndex += 1
+    ) {
       const itemIndex = 0;
       const itemWeight = this.possibleItems[itemIndex].weight;
       const itemValue = this.possibleItems[itemIndex].value;
-      knapsackMatrix[itemIndex][weightIndex] = itemWeight <= weightIndex ? itemValue : 0;
+      knapsackMatrix[itemIndex][weightIndex] =
+        itemWeight <= weightIndex ? itemValue : 0;
     }
 
     // Go through combinations of how we may add items to knapsack and
     // define what weight/value we would receive using Dynamic Programming
     // approach.
-    for (let itemIndex = 1; itemIndex < this.possibleItems.length; itemIndex += 1) {
-      for (let weightIndex = 1; weightIndex <= this.weightLimit; weightIndex += 1) {
+    for (
+      let itemIndex = 1;
+      itemIndex < this.possibleItems.length;
+      itemIndex += 1
+    ) {
+      for (
+        let weightIndex = 1;
+        weightIndex <= this.weightLimit;
+        weightIndex += 1
+      ) {
         const currentItemWeight = this.possibleItems[itemIndex].weight;
         const currentItemValue = this.possibleItems[itemIndex].value;
 
@@ -103,13 +122,15 @@ export default class Knapsack {
           // In case if item's weight is bigger then currently allowed weight
           // then we can't add it to knapsack and the max possible value we can
           // gain at the moment is the max value we got for previous item.
-          knapsackMatrix[itemIndex][weightIndex] = knapsackMatrix[itemIndex - 1][weightIndex];
+          knapsackMatrix[itemIndex][weightIndex] =
+            knapsackMatrix[itemIndex - 1][weightIndex];
         } else {
           // Else we need to consider the max value we can gain at this point by adding
           // current value or just by keeping the previous item for current weight.
           knapsackMatrix[itemIndex][weightIndex] = Math.max(
-            currentItemValue + knapsackMatrix[itemIndex - 1][weightIndex - currentItemWeight],
-            knapsackMatrix[itemIndex - 1][weightIndex],
+            currentItemValue +
+              knapsackMatrix[itemIndex - 1][weightIndex - currentItemWeight],
+            knapsackMatrix[itemIndex - 1][weightIndex]
           );
         }
       }
@@ -128,20 +149,23 @@ export default class Knapsack {
       // In this case this would mean that we need to include previous item
       // to the list of selected items.
       if (
-        knapsackMatrix[itemIndex][weightIndex]
-        && knapsackMatrix[itemIndex][weightIndex] === knapsackMatrix[itemIndex - 1][weightIndex]
+        knapsackMatrix[itemIndex][weightIndex] &&
+        knapsackMatrix[itemIndex][weightIndex] ===
+          knapsackMatrix[itemIndex - 1][weightIndex]
       ) {
         // Check if there are several items with the same weight but with the different values.
         // We need to add highest item in the matrix that is possible to get the highest value.
         const prevSumValue = knapsackMatrix[itemIndex - 1][weightIndex];
         const prevPrevSumValue = knapsackMatrix[itemIndex - 2][weightIndex];
         if (
-          !prevSumValue
-          || (prevSumValue && prevPrevSumValue !== prevSumValue)
+          !prevSumValue ||
+          (prevSumValue && prevPrevSumValue !== prevSumValue)
         ) {
           this.selectedItems.push(prevItem);
         }
-      } else if (knapsackMatrix[itemIndex - 1][weightIndex - currentItem.weight]) {
+      } else if (
+        knapsackMatrix[itemIndex - 1][weightIndex - currentItem.weight]
+      ) {
         this.selectedItems.push(prevItem);
         weightIndex -= currentItem.weight;
       }
@@ -156,13 +180,19 @@ export default class Knapsack {
     this.sortPossibleItemsByValue();
     this.sortPossibleItemsByValuePerWeightRatio();
 
-    for (let itemIndex = 0; itemIndex < this.possibleItems.length; itemIndex += 1) {
+    for (
+      let itemIndex = 0;
+      itemIndex < this.possibleItems.length;
+      itemIndex += 1
+    ) {
       if (this.totalWeight < this.weightLimit) {
         const currentItem = this.possibleItems[itemIndex];
 
         // Detect how much of current items we can push to knapsack.
         const availableWeight = this.weightLimit - this.totalWeight;
-        const maxPossibleItemsCount = Math.floor(availableWeight / currentItem.weight);
+        const maxPossibleItemsCount = Math.floor(
+          availableWeight / currentItem.weight
+        );
 
         if (maxPossibleItemsCount > currentItem.itemsInStock) {
           // If we have more items in stock then it is allowed to add
@@ -193,3 +223,4 @@ export default class Knapsack {
     }, 0);
   }
 }
+
diff --git a/src/algorithms/sets/knapsack-problem/KnapsackItem.js b/src/algorithms/sets/knapsack-problem/KnapsackItem.js
index 4c84eee..b1ff9f7 100644
--- a/src/algorithms/sets/knapsack-problem/KnapsackItem.js
+++ b/src/algorithms/sets/knapsack-problem/KnapsackItem.js
@@ -5,7 +5,11 @@ export default class KnapsackItem {
    * @param {number} itemSettings.weight - weight of the item.
    * @param {number} itemSettings.itemsInStock - how many items are available to be added.
    */
-  constructor({ value, weight, itemsInStock = 1 }) {
+  constructor(_ref) {
+    let value = _ref.value,
+      weight = _ref.weight,
+      _ref$itemsInStock = _ref.itemsInStock,
+      itemsInStock = _ref$itemsInStock === void 0 ? 1 : _ref$itemsInStock;
     this.value = value;
     this.weight = weight;
     this.itemsInStock = itemsInStock;
@@ -31,3 +35,4 @@ export default class KnapsackItem {
     return `v${this.value} w${this.weight} x ${this.quantity}`;
   }
 }
+
diff --git a/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js b/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js
index d322445..335cfa8 100644
--- a/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js
+++ b/src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js
@@ -1,8 +1,8 @@
-import Knapsack from '../Knapsack';
-import KnapsackItem from '../KnapsackItem';
+import Knapsack from "../Knapsack";
+import KnapsackItem from "../KnapsackItem";
 
-describe('Knapsack', () => {
-  it('should solve 0/1 knapsack problem', () => {
+describe("Knapsack", () => {
+  it("should solve 0/1 knapsack problem", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 1, weight: 1 }),
       new KnapsackItem({ value: 4, weight: 3 }),
@@ -19,11 +19,11 @@ describe('Knapsack', () => {
     expect(knapsack.totalValue).toBe(9);
     expect(knapsack.totalWeight).toBe(7);
     expect(knapsack.selectedItems.length).toBe(2);
-    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
-    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
+    expect(knapsack.selectedItems[0].toString()).toBe("v5 w4 x 1");
+    expect(knapsack.selectedItems[1].toString()).toBe("v4 w3 x 1");
   });
 
-  it('should solve 0/1 knapsack problem regardless of items order', () => {
+  it("should solve 0/1 knapsack problem regardless of items order", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 5, weight: 4 }),
       new KnapsackItem({ value: 1, weight: 1 }),
@@ -40,11 +40,11 @@ describe('Knapsack', () => {
     expect(knapsack.totalValue).toBe(9);
     expect(knapsack.totalWeight).toBe(7);
     expect(knapsack.selectedItems.length).toBe(2);
-    expect(knapsack.selectedItems[0].toString()).toBe('v5 w4 x 1');
-    expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');
+    expect(knapsack.selectedItems[0].toString()).toBe("v5 w4 x 1");
+    expect(knapsack.selectedItems[1].toString()).toBe("v4 w3 x 1");
   });
 
-  it('should solve 0/1 knapsack problem with impossible items set', () => {
+  it("should solve 0/1 knapsack problem with impossible items set", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 5, weight: 40 }),
       new KnapsackItem({ value: 1, weight: 10 }),
@@ -63,7 +63,7 @@ describe('Knapsack', () => {
     expect(knapsack.selectedItems.length).toBe(0);
   });
 
-  it('should solve 0/1 knapsack problem with all equal weights', () => {
+  it("should solve 0/1 knapsack problem with all equal weights", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 5, weight: 1 }),
       new KnapsackItem({ value: 1, weight: 1 }),
@@ -82,12 +82,12 @@ describe('Knapsack', () => {
     expect(knapsack.totalValue).toBe(16);
     expect(knapsack.totalWeight).toBe(3);
     expect(knapsack.selectedItems.length).toBe(3);
-    expect(knapsack.selectedItems[0].toString()).toBe('v4 w1 x 1');
-    expect(knapsack.selectedItems[1].toString()).toBe('v5 w1 x 1');
-    expect(knapsack.selectedItems[2].toString()).toBe('v7 w1 x 1');
+    expect(knapsack.selectedItems[0].toString()).toBe("v4 w1 x 1");
+    expect(knapsack.selectedItems[1].toString()).toBe("v5 w1 x 1");
+    expect(knapsack.selectedItems[2].toString()).toBe("v7 w1 x 1");
   });
 
-  it('should solve unbound knapsack problem', () => {
+  it("should solve unbound knapsack problem", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 84, weight: 7 }), // v/w ratio is 12
       new KnapsackItem({ value: 5, weight: 2 }), // v/w ratio is 2.5
@@ -105,14 +105,14 @@ describe('Knapsack', () => {
     expect(knapsack.totalValue).toBe(84 + 20 + 12 + 10 + 5);
     expect(knapsack.totalWeight).toBe(15);
     expect(knapsack.selectedItems.length).toBe(5);
-    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 1');
-    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
-    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
-    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
-    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 1');
+    expect(knapsack.selectedItems[0].toString()).toBe("v84 w7 x 1");
+    expect(knapsack.selectedItems[1].toString()).toBe("v20 w2 x 1");
+    expect(knapsack.selectedItems[2].toString()).toBe("v10 w1 x 1");
+    expect(knapsack.selectedItems[3].toString()).toBe("v12 w3 x 1");
+    expect(knapsack.selectedItems[4].toString()).toBe("v5 w2 x 1");
   });
 
-  it('should solve unbound knapsack problem with items in stock', () => {
+  it("should solve unbound knapsack problem with items in stock", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
       new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
@@ -130,12 +130,12 @@ describe('Knapsack', () => {
     expect(knapsack.totalValue).toBe(84 + 84 + 20 + 10);
     expect(knapsack.totalWeight).toBe(17);
     expect(knapsack.selectedItems.length).toBe(3);
-    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 2');
-    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 1');
-    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 1');
+    expect(knapsack.selectedItems[0].toString()).toBe("v84 w7 x 2");
+    expect(knapsack.selectedItems[1].toString()).toBe("v20 w2 x 1");
+    expect(knapsack.selectedItems[2].toString()).toBe("v10 w1 x 1");
   });
 
-  it('should solve unbound knapsack problem with items in stock and max weight more than sum of all items', () => {
+  it("should solve unbound knapsack problem with items in stock and max weight more than sum of all items", () => {
     const possibleKnapsackItems = [
       new KnapsackItem({ value: 84, weight: 7, itemsInStock: 3 }), // v/w ratio is 12
       new KnapsackItem({ value: 5, weight: 2, itemsInStock: 2 }), // v/w ratio is 2.5
@@ -150,13 +150,14 @@ describe('Knapsack', () => {
 
     knapsack.solveUnboundedKnapsackProblem();
 
-    expect(knapsack.totalValue).toBe((3 * 84) + (2 * 5) + (1 * 12) + (6 * 10) + (8 * 20));
-    expect(knapsack.totalWeight).toBe((3 * 7) + (2 * 2) + (1 * 3) + (6 * 1) + (8 * 2));
+    expect(knapsack.totalValue).toBe(3 * 84 + 2 * 5 + 1 * 12 + 6 * 10 + 8 * 20);
+    expect(knapsack.totalWeight).toBe(3 * 7 + 2 * 2 + 1 * 3 + 6 * 1 + 8 * 2);
     expect(knapsack.selectedItems.length).toBe(5);
-    expect(knapsack.selectedItems[0].toString()).toBe('v84 w7 x 3');
-    expect(knapsack.selectedItems[1].toString()).toBe('v20 w2 x 8');
-    expect(knapsack.selectedItems[2].toString()).toBe('v10 w1 x 6');
-    expect(knapsack.selectedItems[3].toString()).toBe('v12 w3 x 1');
-    expect(knapsack.selectedItems[4].toString()).toBe('v5 w2 x 2');
+    expect(knapsack.selectedItems[0].toString()).toBe("v84 w7 x 3");
+    expect(knapsack.selectedItems[1].toString()).toBe("v20 w2 x 8");
+    expect(knapsack.selectedItems[2].toString()).toBe("v10 w1 x 6");
+    expect(knapsack.selectedItems[3].toString()).toBe("v12 w3 x 1");
+    expect(knapsack.selectedItems[4].toString()).toBe("v5 w2 x 2");
   });
 });
+
diff --git a/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js b/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js
index d8ea8b8..a692feb 100644
--- a/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js
+++ b/src/algorithms/sets/knapsack-problem/__test__/KnapsackItem.test.js
@@ -1,14 +1,14 @@
-import KnapsackItem from '../KnapsackItem';
+import KnapsackItem from "../KnapsackItem";
 
-describe('KnapsackItem', () => {
-  it('should create knapsack item and count its total weight and value', () => {
+describe("KnapsackItem", () => {
+  it("should create knapsack item and count its total weight and value", () => {
     const knapsackItem = new KnapsackItem({ value: 3, weight: 2 });
 
     expect(knapsackItem.value).toBe(3);
     expect(knapsackItem.weight).toBe(2);
     expect(knapsackItem.quantity).toBe(1);
     expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
-    expect(knapsackItem.toString()).toBe('v3 w2 x 1');
+    expect(knapsackItem.toString()).toBe("v3 w2 x 1");
     expect(knapsackItem.totalValue).toBe(3);
     expect(knapsackItem.totalWeight).toBe(2);
 
@@ -18,7 +18,7 @@ describe('KnapsackItem', () => {
     expect(knapsackItem.weight).toBe(2);
     expect(knapsackItem.quantity).toBe(0);
     expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
-    expect(knapsackItem.toString()).toBe('v3 w2 x 0');
+    expect(knapsackItem.toString()).toBe("v3 w2 x 0");
     expect(knapsackItem.totalValue).toBe(0);
     expect(knapsackItem.totalWeight).toBe(0);
 
@@ -28,8 +28,9 @@ describe('KnapsackItem', () => {
     expect(knapsackItem.weight).toBe(2);
     expect(knapsackItem.quantity).toBe(2);
     expect(knapsackItem.valuePerWeightRatio).toBe(1.5);
-    expect(knapsackItem.toString()).toBe('v3 w2 x 2');
+    expect(knapsackItem.toString()).toBe("v3 w2 x 2");
     expect(knapsackItem.totalValue).toBe(6);
     expect(knapsackItem.totalWeight).toBe(4);
   });
 });
+
diff --git a/src/algorithms/sets/longest-common-subsequence/__test__/longestCommonSubsequence.test.js b/src/algorithms/sets/longest-common-subsequence/__test__/longestCommonSubsequence.test.js
index 9cddc52..3507d5c 100644
--- a/src/algorithms/sets/longest-common-subsequence/__test__/longestCommonSubsequence.test.js
+++ b/src/algorithms/sets/longest-common-subsequence/__test__/longestCommonSubsequence.test.js
@@ -1,31 +1,37 @@
-import longestCommonSubsequence from '../longestCommonSubsequence';
+import longestCommonSubsequence from "../longestCommonSubsequence";
 
-describe('longestCommonSubsequence', () => {
-  it('should find longest common subsequence for two strings', () => {
-    expect(longestCommonSubsequence([''], [''])).toEqual(['']);
+describe("longestCommonSubsequence", () => {
+  it("should find longest common subsequence for two strings", () => {
+    expect(longestCommonSubsequence([""], [""])).toEqual([""]);
 
-    expect(longestCommonSubsequence([''], ['A', 'B', 'C'])).toEqual(['']);
+    expect(longestCommonSubsequence([""], ["A", "B", "C"])).toEqual([""]);
 
-    expect(longestCommonSubsequence(['A', 'B', 'C'], [''])).toEqual(['']);
+    expect(longestCommonSubsequence(["A", "B", "C"], [""])).toEqual([""]);
 
-    expect(longestCommonSubsequence(
-      ['A', 'B', 'C'],
-      ['D', 'E', 'F', 'G'],
-    )).toEqual(['']);
+    expect(
+      longestCommonSubsequence(["A", "B", "C"], ["D", "E", "F", "G"])
+    ).toEqual([""]);
 
-    expect(longestCommonSubsequence(
-      ['A', 'B', 'C', 'D', 'G', 'H'],
-      ['A', 'E', 'D', 'F', 'H', 'R'],
-    )).toEqual(['A', 'D', 'H']);
+    expect(
+      longestCommonSubsequence(
+        ["A", "B", "C", "D", "G", "H"],
+        ["A", "E", "D", "F", "H", "R"]
+      )
+    ).toEqual(["A", "D", "H"]);
 
-    expect(longestCommonSubsequence(
-      ['A', 'G', 'G', 'T', 'A', 'B'],
-      ['G', 'X', 'T', 'X', 'A', 'Y', 'B'],
-    )).toEqual(['G', 'T', 'A', 'B']);
+    expect(
+      longestCommonSubsequence(
+        ["A", "G", "G", "T", "A", "B"],
+        ["G", "X", "T", "X", "A", "Y", "B"]
+      )
+    ).toEqual(["G", "T", "A", "B"]);
 
-    expect(longestCommonSubsequence(
-      ['A', 'B', 'C', 'D', 'A', 'F'],
-      ['A', 'C', 'B', 'C', 'F'],
-    )).toEqual(['A', 'B', 'C', 'F']);
+    expect(
+      longestCommonSubsequence(
+        ["A", "B", "C", "D", "A", "F"],
+        ["A", "C", "B", "C", "F"]
+      )
+    ).toEqual(["A", "B", "C", "F"]);
   });
 });
+
diff --git a/src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js b/src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js
index 4124827..c6c9df6 100644
--- a/src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js
+++ b/src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js
@@ -5,7 +5,9 @@
  */
 export default function longestCommonSubsequence(set1, set2) {
   // Init LCS matrix.
-  const lcsMatrix = Array(set2.length + 1).fill(null).map(() => Array(set1.length + 1).fill(null));
+  const lcsMatrix = Array(set2.length + 1)
+    .fill(null)
+    .map(() => Array(set1.length + 1).fill(null));
 
   // Fill first row with zeros.
   for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {
@@ -21,11 +23,12 @@ export default function longestCommonSubsequence(set1, set2) {
   for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {
     for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {
       if (set1[columnIndex - 1] === set2[rowIndex - 1]) {
-        lcsMatrix[rowIndex][columnIndex] = lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;
+        lcsMatrix[rowIndex][columnIndex] =
+          lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;
       } else {
         lcsMatrix[rowIndex][columnIndex] = Math.max(
           lcsMatrix[rowIndex - 1][columnIndex],
-          lcsMatrix[rowIndex][columnIndex - 1],
+          lcsMatrix[rowIndex][columnIndex - 1]
         );
       }
     }
@@ -34,7 +37,7 @@ export default function longestCommonSubsequence(set1, set2) {
   // Calculate LCS based on LCS matrix.
   if (!lcsMatrix[set2.length][set1.length]) {
     // If the length of largest common string is zero then return empty string.
-    return [''];
+    return [""];
   }
 
   const longestSequence = [];
@@ -47,7 +50,9 @@ export default function longestCommonSubsequence(set1, set2) {
       longestSequence.unshift(set1[columnIndex - 1]);
       columnIndex -= 1;
       rowIndex -= 1;
-    } else if (lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]) {
+    } else if (
+      lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]
+    ) {
       // Move left.
       columnIndex -= 1;
     } else {
@@ -58,3 +63,4 @@ export default function longestCommonSubsequence(set1, set2) {
 
   return longestSequence;
 }
+
diff --git a/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js b/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js
index 13160b6..c4a0f18 100644
--- a/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js
+++ b/src/algorithms/sets/longest-increasing-subsequence/__test__/dpLongestIncreasingSubsequence.test.js
@@ -1,36 +1,37 @@
-import dpLongestIncreasingSubsequence from '../dpLongestIncreasingSubsequence';
+import dpLongestIncreasingSubsequence from "../dpLongestIncreasingSubsequence";
 
-describe('dpLongestIncreasingSubsequence', () => {
-  it('should find longest increasing subsequence length', () => {
+describe("dpLongestIncreasingSubsequence", () => {
+  it("should find longest increasing subsequence length", () => {
     // Should be:
     // 9 or
     // 8 or
     // 7 or
     // 6 or
     // ...
-    expect(dpLongestIncreasingSubsequence([
-      9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
-    ])).toBe(1);
+    expect(dpLongestIncreasingSubsequence([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])).toBe(
+      1
+    );
 
     // Should be:
     // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
-    expect(dpLongestIncreasingSubsequence([
-      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-    ])).toBe(10);
+    expect(dpLongestIncreasingSubsequence([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])).toBe(
+      10
+    );
 
     // Should be:
     // -1, 0, 2, 3
-    expect(dpLongestIncreasingSubsequence([
-      3, 4, -1, 0, 6, 2, 3,
-    ])).toBe(4);
+    expect(dpLongestIncreasingSubsequence([3, 4, -1, 0, 6, 2, 3])).toBe(4);
 
     // Should be:
     // 0, 2, 6, 9, 11, 15 or
     // 0, 4, 6, 9, 11, 15 or
     // 0, 2, 6, 9, 13, 15 or
     // 0, 4, 6, 9, 13, 15
-    expect(dpLongestIncreasingSubsequence([
-      0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
-    ])).toBe(6);
+    expect(
+      dpLongestIncreasingSubsequence([
+        0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,
+      ])
+    ).toBe(6);
   });
 });
+
diff --git a/src/algorithms/sets/longest-increasing-subsequence/dpLongestIncreasingSubsequence.js b/src/algorithms/sets/longest-increasing-subsequence/dpLongestIncreasingSubsequence.js
index e5f2ec6..f47251c 100644
--- a/src/algorithms/sets/longest-increasing-subsequence/dpLongestIncreasingSubsequence.js
+++ b/src/algorithms/sets/longest-increasing-subsequence/dpLongestIncreasingSubsequence.js
@@ -51,3 +51,4 @@ export default function dpLongestIncreasingSubsequence(sequence) {
 
   return longestIncreasingLength;
 }
+
diff --git a/src/algorithms/sets/maximum-subarray/__test__/bfMaximumSubarray.test.js b/src/algorithms/sets/maximum-subarray/__test__/bfMaximumSubarray.test.js
index 6bff427..d0e3495 100644
--- a/src/algorithms/sets/maximum-subarray/__test__/bfMaximumSubarray.test.js
+++ b/src/algorithms/sets/maximum-subarray/__test__/bfMaximumSubarray.test.js
@@ -1,16 +1,25 @@
-import bfMaximumSubarray from '../bfMaximumSubarray';
+import bfMaximumSubarray from "../bfMaximumSubarray";
 
-describe('bfMaximumSubarray', () => {
-  it('should find maximum subarray using the brute force algorithm', () => {
+describe("bfMaximumSubarray", () => {
+  it("should find maximum subarray using the brute force algorithm", () => {
     expect(bfMaximumSubarray([])).toEqual([]);
     expect(bfMaximumSubarray([0, 0])).toEqual([0]);
     expect(bfMaximumSubarray([0, 0, 1])).toEqual([0, 0, 1]);
     expect(bfMaximumSubarray([0, 0, 1, 2])).toEqual([0, 0, 1, 2]);
     expect(bfMaximumSubarray([0, 0, -1, 2])).toEqual([2]);
     expect(bfMaximumSubarray([-1, -2, -3, -4, -5])).toEqual([-1]);
-    expect(bfMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual([1, 2, 3, 2, 3, 4, 5]);
-    expect(bfMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual([4, -1, 2, 1]);
-    expect(bfMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual([4, -1, -2, 1, 5]);
-    expect(bfMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual([7, 6, -1, 4, 11]);
+    expect(bfMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual([
+      1, 2, 3, 2, 3, 4, 5,
+    ]);
+    expect(bfMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual([
+      4, -1, 2, 1,
+    ]);
+    expect(bfMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual([
+      4, -1, -2, 1, 5,
+    ]);
+    expect(bfMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual([
+      7, 6, -1, 4, 11,
+    ]);
   });
 });
+
diff --git a/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js b/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js
index 3b3ace0..7faf21c 100644
--- a/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js
+++ b/src/algorithms/sets/maximum-subarray/__test__/dcMaximumSubarraySum.test.js
@@ -1,7 +1,7 @@
-import dcMaximumSubarray from '../dcMaximumSubarraySum';
+import dcMaximumSubarray from "../dcMaximumSubarraySum";
 
-describe('dcMaximumSubarraySum', () => {
-  it('should find maximum subarray sum using the divide and conquer algorithm', () => {
+describe("dcMaximumSubarraySum", () => {
+  it("should find maximum subarray sum using the divide and conquer algorithm", () => {
     expect(dcMaximumSubarray([])).toEqual(-Infinity);
     expect(dcMaximumSubarray([0, 0])).toEqual(0);
     expect(dcMaximumSubarray([0, 0, 1])).toEqual(1);
@@ -14,3 +14,4 @@ describe('dcMaximumSubarraySum', () => {
     expect(dcMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual(27);
   });
 });
+
diff --git a/src/algorithms/sets/maximum-subarray/__test__/dpMaximumSubarray.test.js b/src/algorithms/sets/maximum-subarray/__test__/dpMaximumSubarray.test.js
index c00727c..9776df7 100644
--- a/src/algorithms/sets/maximum-subarray/__test__/dpMaximumSubarray.test.js
+++ b/src/algorithms/sets/maximum-subarray/__test__/dpMaximumSubarray.test.js
@@ -1,16 +1,25 @@
-import dpMaximumSubarray from '../dpMaximumSubarray';
+import dpMaximumSubarray from "../dpMaximumSubarray";
 
-describe('dpMaximumSubarray', () => {
-  it('should find maximum subarray using the dynamic programming algorithm', () => {
+describe("dpMaximumSubarray", () => {
+  it("should find maximum subarray using the dynamic programming algorithm", () => {
     expect(dpMaximumSubarray([])).toEqual([]);
     expect(dpMaximumSubarray([0, 0])).toEqual([0]);
     expect(dpMaximumSubarray([0, 0, 1])).toEqual([0, 0, 1]);
     expect(dpMaximumSubarray([0, 0, 1, 2])).toEqual([0, 0, 1, 2]);
     expect(dpMaximumSubarray([0, 0, -1, 2])).toEqual([2]);
     expect(dpMaximumSubarray([-1, -2, -3, -4, -5])).toEqual([-1]);
-    expect(dpMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual([1, 2, 3, 2, 3, 4, 5]);
-    expect(dpMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual([4, -1, 2, 1]);
-    expect(dpMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual([4, -1, -2, 1, 5]);
-    expect(dpMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual([7, 6, -1, 4, 11]);
+    expect(dpMaximumSubarray([1, 2, 3, 2, 3, 4, 5])).toEqual([
+      1, 2, 3, 2, 3, 4, 5,
+    ]);
+    expect(dpMaximumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])).toEqual([
+      4, -1, 2, 1,
+    ]);
+    expect(dpMaximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])).toEqual([
+      4, -1, -2, 1, 5,
+    ]);
+    expect(dpMaximumSubarray([1, -3, 2, -5, 7, 6, -1, 4, 11, -23])).toEqual([
+      7, 6, -1, 4, 11,
+    ]);
   });
 });
+
diff --git a/src/algorithms/sets/maximum-subarray/bfMaximumSubarray.js b/src/algorithms/sets/maximum-subarray/bfMaximumSubarray.js
index 20c0b38..085ec7b 100644
--- a/src/algorithms/sets/maximum-subarray/bfMaximumSubarray.js
+++ b/src/algorithms/sets/maximum-subarray/bfMaximumSubarray.js
@@ -12,7 +12,11 @@ export default function bfMaximumSubarray(inputArray) {
 
   for (let startIndex = 0; startIndex < inputArray.length; startIndex += 1) {
     let subarraySum = 0;
-    for (let arrLength = 1; arrLength <= (inputArray.length - startIndex); arrLength += 1) {
+    for (
+      let arrLength = 1;
+      arrLength <= inputArray.length - startIndex;
+      arrLength += 1
+    ) {
       subarraySum += inputArray[startIndex + (arrLength - 1)];
       if (maxSubarraySum === null || subarraySum > maxSubarraySum) {
         maxSubarraySum = subarraySum;
@@ -22,5 +26,9 @@ export default function bfMaximumSubarray(inputArray) {
     }
   }
 
-  return inputArray.slice(maxSubarrayStartIndex, maxSubarrayStartIndex + maxSubarrayLength);
+  return inputArray.slice(
+    maxSubarrayStartIndex,
+    maxSubarrayStartIndex + maxSubarrayLength
+  );
 }
+
diff --git a/src/algorithms/sets/maximum-subarray/dcMaximumSubarraySum.js b/src/algorithms/sets/maximum-subarray/dcMaximumSubarraySum.js
index 3ed9ab3..5412be5 100644
--- a/src/algorithms/sets/maximum-subarray/dcMaximumSubarraySum.js
+++ b/src/algorithms/sets/maximum-subarray/dcMaximumSubarraySum.js
@@ -26,8 +26,9 @@ export default function dcMaximumSubarraySum(inputArray) {
       // Option #1: Pick the current element, and continue picking next one.
       inputArray[elementIndex] + solveRecursively(elementIndex + 1, true),
       // Option #2: Don't pick the current element.
-      mustPick ? 0 : solveRecursively(elementIndex + 1, false),
+      mustPick ? 0 : solveRecursively(elementIndex + 1, false)
     );
   }
   return solveRecursively(0, false);
 }
+
diff --git a/src/algorithms/sets/maximum-subarray/dpMaximumSubarray.js b/src/algorithms/sets/maximum-subarray/dpMaximumSubarray.js
index ef1734b..08d7aa1 100644
--- a/src/algorithms/sets/maximum-subarray/dpMaximumSubarray.js
+++ b/src/algorithms/sets/maximum-subarray/dpMaximumSubarray.js
@@ -43,3 +43,4 @@ export default function dpMaximumSubarray(inputArray) {
 
   return inputArray.slice(maxStartIndex, maxEndIndex + 1);
 }
+
diff --git a/src/algorithms/sets/permutations/__test__/permutateWithRepetitions.test.js b/src/algorithms/sets/permutations/__test__/permutateWithRepetitions.test.js
index 0d53def..4084ea5 100644
--- a/src/algorithms/sets/permutations/__test__/permutateWithRepetitions.test.js
+++ b/src/algorithms/sets/permutations/__test__/permutateWithRepetitions.test.js
@@ -1,52 +1,51 @@
-import permutateWithRepetitions from '../permutateWithRepetitions';
+import permutateWithRepetitions from "../permutateWithRepetitions";
 
-describe('permutateWithRepetitions', () => {
-  it('should permutate string with repetition', () => {
-    const permutations1 = permutateWithRepetitions(['A']);
-    expect(permutations1).toEqual([
-      ['A'],
-    ]);
+describe("permutateWithRepetitions", () => {
+  it("should permutate string with repetition", () => {
+    const permutations1 = permutateWithRepetitions(["A"]);
+    expect(permutations1).toEqual([["A"]]);
 
-    const permutations2 = permutateWithRepetitions(['A', 'B']);
+    const permutations2 = permutateWithRepetitions(["A", "B"]);
     expect(permutations2).toEqual([
-      ['A', 'A'],
-      ['A', 'B'],
-      ['B', 'A'],
-      ['B', 'B'],
+      ["A", "A"],
+      ["A", "B"],
+      ["B", "A"],
+      ["B", "B"],
     ]);
 
-    const permutations3 = permutateWithRepetitions(['A', 'B', 'C']);
+    const permutations3 = permutateWithRepetitions(["A", "B", "C"]);
     expect(permutations3).toEqual([
-      ['A', 'A', 'A'],
-      ['A', 'A', 'B'],
-      ['A', 'A', 'C'],
-      ['A', 'B', 'A'],
-      ['A', 'B', 'B'],
-      ['A', 'B', 'C'],
-      ['A', 'C', 'A'],
-      ['A', 'C', 'B'],
-      ['A', 'C', 'C'],
-      ['B', 'A', 'A'],
-      ['B', 'A', 'B'],
-      ['B', 'A', 'C'],
-      ['B', 'B', 'A'],
-      ['B', 'B', 'B'],
-      ['B', 'B', 'C'],
-      ['B', 'C', 'A'],
-      ['B', 'C', 'B'],
-      ['B', 'C', 'C'],
-      ['C', 'A', 'A'],
-      ['C', 'A', 'B'],
-      ['C', 'A', 'C'],
-      ['C', 'B', 'A'],
-      ['C', 'B', 'B'],
-      ['C', 'B', 'C'],
-      ['C', 'C', 'A'],
-      ['C', 'C', 'B'],
-      ['C', 'C', 'C'],
+      ["A", "A", "A"],
+      ["A", "A", "B"],
+      ["A", "A", "C"],
+      ["A", "B", "A"],
+      ["A", "B", "B"],
+      ["A", "B", "C"],
+      ["A", "C", "A"],
+      ["A", "C", "B"],
+      ["A", "C", "C"],
+      ["B", "A", "A"],
+      ["B", "A", "B"],
+      ["B", "A", "C"],
+      ["B", "B", "A"],
+      ["B", "B", "B"],
+      ["B", "B", "C"],
+      ["B", "C", "A"],
+      ["B", "C", "B"],
+      ["B", "C", "C"],
+      ["C", "A", "A"],
+      ["C", "A", "B"],
+      ["C", "A", "C"],
+      ["C", "B", "A"],
+      ["C", "B", "B"],
+      ["C", "B", "C"],
+      ["C", "C", "A"],
+      ["C", "C", "B"],
+      ["C", "C", "C"],
     ]);
 
-    const permutations4 = permutateWithRepetitions(['A', 'B', 'C', 'D']);
+    const permutations4 = permutateWithRepetitions(["A", "B", "C", "D"]);
     expect(permutations4.length).toBe(4 * 4 * 4 * 4);
   });
 });
+
diff --git a/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js b/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js
index 6125e58..e9c507f 100644
--- a/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js
+++ b/src/algorithms/sets/permutations/__test__/permutateWithoutRepetitions.test.js
@@ -1,68 +1,74 @@
-import permutateWithoutRepetitions from '../permutateWithoutRepetitions';
-import factorial from '../../../math/factorial/factorial';
+import permutateWithoutRepetitions from "../permutateWithoutRepetitions";
+import factorial from "../../../math/factorial/factorial";
 
-describe('permutateWithoutRepetitions', () => {
-  it('should permutate string', () => {
-    const permutations1 = permutateWithoutRepetitions(['A']);
-    expect(permutations1).toEqual([
-      ['A'],
-    ]);
+describe("permutateWithoutRepetitions", () => {
+  it("should permutate string", () => {
+    const permutations1 = permutateWithoutRepetitions(["A"]);
+    expect(permutations1).toEqual([["A"]]);
 
-    const permutations2 = permutateWithoutRepetitions(['A', 'B']);
+    const permutations2 = permutateWithoutRepetitions(["A", "B"]);
     expect(permutations2.length).toBe(2);
     expect(permutations2).toEqual([
-      ['A', 'B'],
-      ['B', 'A'],
+      ["A", "B"],
+      ["B", "A"],
     ]);
 
-    const permutations6 = permutateWithoutRepetitions(['A', 'A']);
+    const permutations6 = permutateWithoutRepetitions(["A", "A"]);
     expect(permutations6.length).toBe(2);
     expect(permutations6).toEqual([
-      ['A', 'A'],
-      ['A', 'A'],
+      ["A", "A"],
+      ["A", "A"],
     ]);
 
-    const permutations3 = permutateWithoutRepetitions(['A', 'B', 'C']);
+    const permutations3 = permutateWithoutRepetitions(["A", "B", "C"]);
     expect(permutations3.length).toBe(factorial(3));
     expect(permutations3).toEqual([
-      ['A', 'B', 'C'],
-      ['B', 'A', 'C'],
-      ['B', 'C', 'A'],
-      ['A', 'C', 'B'],
-      ['C', 'A', 'B'],
-      ['C', 'B', 'A'],
+      ["A", "B", "C"],
+      ["B", "A", "C"],
+      ["B", "C", "A"],
+      ["A", "C", "B"],
+      ["C", "A", "B"],
+      ["C", "B", "A"],
     ]);
 
-    const permutations4 = permutateWithoutRepetitions(['A', 'B', 'C', 'D']);
+    const permutations4 = permutateWithoutRepetitions(["A", "B", "C", "D"]);
     expect(permutations4.length).toBe(factorial(4));
     expect(permutations4).toEqual([
-      ['A', 'B', 'C', 'D'],
-      ['B', 'A', 'C', 'D'],
-      ['B', 'C', 'A', 'D'],
-      ['B', 'C', 'D', 'A'],
-      ['A', 'C', 'B', 'D'],
-      ['C', 'A', 'B', 'D'],
-      ['C', 'B', 'A', 'D'],
-      ['C', 'B', 'D', 'A'],
-      ['A', 'C', 'D', 'B'],
-      ['C', 'A', 'D', 'B'],
-      ['C', 'D', 'A', 'B'],
-      ['C', 'D', 'B', 'A'],
-      ['A', 'B', 'D', 'C'],
-      ['B', 'A', 'D', 'C'],
-      ['B', 'D', 'A', 'C'],
-      ['B', 'D', 'C', 'A'],
-      ['A', 'D', 'B', 'C'],
-      ['D', 'A', 'B', 'C'],
-      ['D', 'B', 'A', 'C'],
-      ['D', 'B', 'C', 'A'],
-      ['A', 'D', 'C', 'B'],
-      ['D', 'A', 'C', 'B'],
-      ['D', 'C', 'A', 'B'],
-      ['D', 'C', 'B', 'A'],
+      ["A", "B", "C", "D"],
+      ["B", "A", "C", "D"],
+      ["B", "C", "A", "D"],
+      ["B", "C", "D", "A"],
+      ["A", "C", "B", "D"],
+      ["C", "A", "B", "D"],
+      ["C", "B", "A", "D"],
+      ["C", "B", "D", "A"],
+      ["A", "C", "D", "B"],
+      ["C", "A", "D", "B"],
+      ["C", "D", "A", "B"],
+      ["C", "D", "B", "A"],
+      ["A", "B", "D", "C"],
+      ["B", "A", "D", "C"],
+      ["B", "D", "A", "C"],
+      ["B", "D", "C", "A"],
+      ["A", "D", "B", "C"],
+      ["D", "A", "B", "C"],
+      ["D", "B", "A", "C"],
+      ["D", "B", "C", "A"],
+      ["A", "D", "C", "B"],
+      ["D", "A", "C", "B"],
+      ["D", "C", "A", "B"],
+      ["D", "C", "B", "A"],
     ]);
 
-    const permutations5 = permutateWithoutRepetitions(['A', 'B', 'C', 'D', 'E', 'F']);
+    const permutations5 = permutateWithoutRepetitions([
+      "A",
+      "B",
+      "C",
+      "D",
+      "E",
+      "F",
+    ]);
     expect(permutations5.length).toBe(factorial(6));
   });
 });
+
diff --git a/src/algorithms/sets/permutations/permutateWithRepetitions.js b/src/algorithms/sets/permutations/permutateWithRepetitions.js
index 08f918b..f04671f 100644
--- a/src/algorithms/sets/permutations/permutateWithRepetitions.js
+++ b/src/algorithms/sets/permutations/permutateWithRepetitions.js
@@ -3,10 +3,11 @@
  * @param {number} permutationLength
  * @return {*[]}
  */
-export default function permutateWithRepetitions(
-  permutationOptions,
-  permutationLength = permutationOptions.length,
-) {
+export default function permutateWithRepetitions(permutationOptions) {
+  let permutationLength =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : permutationOptions.length;
   if (permutationLength === 1) {
     return permutationOptions.map((permutationOption) => [permutationOption]);
   }
@@ -17,7 +18,7 @@ export default function permutateWithRepetitions(
   // Get smaller permutations.
   const smallerPermutations = permutateWithRepetitions(
     permutationOptions,
-    permutationLength - 1,
+    permutationLength - 1
   );
 
   // Go through all options and join it to the smaller permutations.
@@ -29,3 +30,4 @@ export default function permutateWithRepetitions(
 
   return permutations;
 }
+
diff --git a/src/algorithms/sets/permutations/permutateWithoutRepetitions.js b/src/algorithms/sets/permutations/permutateWithoutRepetitions.js
index 7b2f002..f54c430 100644
--- a/src/algorithms/sets/permutations/permutateWithoutRepetitions.js
+++ b/src/algorithms/sets/permutations/permutateWithoutRepetitions.js
@@ -11,21 +11,34 @@ export default function permutateWithoutRepetitions(permutationOptions) {
   const permutations = [];
 
   // Get all permutations for permutationOptions excluding the first element.
-  const smallerPermutations = permutateWithoutRepetitions(permutationOptions.slice(1));
+  const smallerPermutations = permutateWithoutRepetitions(
+    permutationOptions.slice(1)
+  );
 
   // Insert first option into every possible position of every smaller permutation.
   const firstOption = permutationOptions[0];
 
-  for (let permIndex = 0; permIndex < smallerPermutations.length; permIndex += 1) {
+  for (
+    let permIndex = 0;
+    permIndex < smallerPermutations.length;
+    permIndex += 1
+  ) {
     const smallerPermutation = smallerPermutations[permIndex];
 
     // Insert first option into every possible position of smallerPermutation.
-    for (let positionIndex = 0; positionIndex <= smallerPermutation.length; positionIndex += 1) {
+    for (
+      let positionIndex = 0;
+      positionIndex <= smallerPermutation.length;
+      positionIndex += 1
+    ) {
       const permutationPrefix = smallerPermutation.slice(0, positionIndex);
       const permutationSuffix = smallerPermutation.slice(positionIndex);
-      permutations.push(permutationPrefix.concat([firstOption], permutationSuffix));
+      permutations.push(
+        permutationPrefix.concat([firstOption], permutationSuffix)
+      );
     }
   }
 
   return permutations;
 }
+
diff --git a/src/algorithms/sets/power-set/__test__/btPowerSet.test.js b/src/algorithms/sets/power-set/__test__/btPowerSet.test.js
index acfb173..c0dc05b 100644
--- a/src/algorithms/sets/power-set/__test__/btPowerSet.test.js
+++ b/src/algorithms/sets/power-set/__test__/btPowerSet.test.js
@@ -1,11 +1,8 @@
-import btPowerSet from '../btPowerSet';
+import btPowerSet from "../btPowerSet";
 
-describe('btPowerSet', () => {
-  it('should calculate power set of given set using backtracking approach', () => {
-    expect(btPowerSet([1])).toEqual([
-      [],
-      [1],
-    ]);
+describe("btPowerSet", () => {
+  it("should calculate power set of given set using backtracking approach", () => {
+    expect(btPowerSet([1])).toEqual([[], [1]]);
 
     expect(btPowerSet([1, 2, 3])).toEqual([
       [],
@@ -19,3 +16,4 @@ describe('btPowerSet', () => {
     ]);
   });
 });
+
diff --git a/src/algorithms/sets/power-set/__test__/bwPowerSet.test.js b/src/algorithms/sets/power-set/__test__/bwPowerSet.test.js
index e2ed179..df52df4 100644
--- a/src/algorithms/sets/power-set/__test__/bwPowerSet.test.js
+++ b/src/algorithms/sets/power-set/__test__/bwPowerSet.test.js
@@ -1,11 +1,8 @@
-import bwPowerSet from '../bwPowerSet';
+import bwPowerSet from "../bwPowerSet";
 
-describe('bwPowerSet', () => {
-  it('should calculate power set of given set using bitwise approach', () => {
-    expect(bwPowerSet([1])).toEqual([
-      [],
-      [1],
-    ]);
+describe("bwPowerSet", () => {
+  it("should calculate power set of given set using bitwise approach", () => {
+    expect(bwPowerSet([1])).toEqual([[], [1]]);
 
     expect(bwPowerSet([1, 2, 3])).toEqual([
       [],
@@ -19,3 +16,4 @@ describe('bwPowerSet', () => {
     ]);
   });
 });
+
diff --git a/src/algorithms/sets/power-set/btPowerSet.js b/src/algorithms/sets/power-set/btPowerSet.js
index 2007c12..d98d57e 100644
--- a/src/algorithms/sets/power-set/btPowerSet.js
+++ b/src/algorithms/sets/power-set/btPowerSet.js
@@ -5,7 +5,13 @@
  * @param {number} startAt - The position of in original set we're starting to form current subset.
  * @return {*[][]} - All subsets of original set.
  */
-function btPowerSetRecursive(originalSet, allSubsets = [[]], currentSubSet = [], startAt = 0) {
+function btPowerSetRecursive(originalSet) {
+  let allSubsets =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [[]];
+  let currentSubSet =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  let startAt =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
   // Let's iterate over originalSet elements that may be added to the subset
   // without having duplicates. The value of startAt prevents adding the duplicates.
   for (let position = startAt; position < originalSet.length; position += 1) {
@@ -39,3 +45,4 @@ function btPowerSetRecursive(originalSet, allSubsets = [[]], currentSubSet = [],
 export default function btPowerSet(originalSet) {
   return btPowerSetRecursive(originalSet);
 }
+
diff --git a/src/algorithms/sets/power-set/bwPowerSet.js b/src/algorithms/sets/power-set/bwPowerSet.js
index b8417be..015cffd 100644
--- a/src/algorithms/sets/power-set/bwPowerSet.js
+++ b/src/algorithms/sets/power-set/bwPowerSet.js
@@ -16,10 +16,18 @@ export default function bwPowerSet(originalSet) {
   // it shows by its bits (0 or 1) whether to include related element from the set or not.
   // For example, for the set {1, 2, 3} the binary number of 0b010 would mean that we need to
   // include only "2" to the current set.
-  for (let combinationIndex = 0; combinationIndex < numberOfCombinations; combinationIndex += 1) {
+  for (
+    let combinationIndex = 0;
+    combinationIndex < numberOfCombinations;
+    combinationIndex += 1
+  ) {
     const subSet = [];
 
-    for (let setElementIndex = 0; setElementIndex < originalSet.length; setElementIndex += 1) {
+    for (
+      let setElementIndex = 0;
+      setElementIndex < originalSet.length;
+      setElementIndex += 1
+    ) {
       // Decide whether we need to include current element into the subset or not.
       if (combinationIndex & (1 << setElementIndex)) {
         subSet.push(originalSet[setElementIndex]);
@@ -32,3 +40,4 @@ export default function bwPowerSet(originalSet) {
 
   return subSets;
 }
+
diff --git a/src/algorithms/sets/shortest-common-supersequence/__test__/shortestCommonSupersequence.test.js b/src/algorithms/sets/shortest-common-supersequence/__test__/shortestCommonSupersequence.test.js
index 8adf27d..9c1d69b 100644
--- a/src/algorithms/sets/shortest-common-supersequence/__test__/shortestCommonSupersequence.test.js
+++ b/src/algorithms/sets/shortest-common-supersequence/__test__/shortestCommonSupersequence.test.js
@@ -1,35 +1,40 @@
-import shortestCommonSupersequence from '../shortestCommonSupersequence';
+import shortestCommonSupersequence from "../shortestCommonSupersequence";
 
-describe('shortestCommonSupersequence', () => {
-  it('should find shortest common supersequence of two sequences', () => {
+describe("shortestCommonSupersequence", () => {
+  it("should find shortest common supersequence of two sequences", () => {
     // LCS (longest common subsequence) is empty
-    expect(shortestCommonSupersequence(
-      ['A', 'B', 'C'],
-      ['D', 'E', 'F'],
-    )).toEqual(['A', 'B', 'C', 'D', 'E', 'F']);
+    expect(
+      shortestCommonSupersequence(["A", "B", "C"], ["D", "E", "F"])
+    ).toEqual(["A", "B", "C", "D", "E", "F"]);
 
     // LCS (longest common subsequence) is "EE"
-    expect(shortestCommonSupersequence(
-      ['G', 'E', 'E', 'K'],
-      ['E', 'K', 'E'],
-    )).toEqual(['G', 'E', 'K', 'E', 'K']);
+    expect(
+      shortestCommonSupersequence(["G", "E", "E", "K"], ["E", "K", "E"])
+    ).toEqual(["G", "E", "K", "E", "K"]);
 
     // LCS (longest common subsequence) is "GTAB"
-    expect(shortestCommonSupersequence(
-      ['A', 'G', 'G', 'T', 'A', 'B'],
-      ['G', 'X', 'T', 'X', 'A', 'Y', 'B'],
-    )).toEqual(['A', 'G', 'G', 'X', 'T', 'X', 'A', 'Y', 'B']);
+    expect(
+      shortestCommonSupersequence(
+        ["A", "G", "G", "T", "A", "B"],
+        ["G", "X", "T", "X", "A", "Y", "B"]
+      )
+    ).toEqual(["A", "G", "G", "X", "T", "X", "A", "Y", "B"]);
 
     // LCS (longest common subsequence) is "BCBA".
-    expect(shortestCommonSupersequence(
-      ['A', 'B', 'C', 'B', 'D', 'A', 'B'],
-      ['B', 'D', 'C', 'A', 'B', 'A'],
-    )).toEqual(['A', 'B', 'D', 'C', 'A', 'B', 'D', 'A', 'B']);
+    expect(
+      shortestCommonSupersequence(
+        ["A", "B", "C", "B", "D", "A", "B"],
+        ["B", "D", "C", "A", "B", "A"]
+      )
+    ).toEqual(["A", "B", "D", "C", "A", "B", "D", "A", "B"]);
 
     // LCS (longest common subsequence) is "BDABA".
-    expect(shortestCommonSupersequence(
-      ['B', 'D', 'C', 'A', 'B', 'A'],
-      ['A', 'B', 'C', 'B', 'D', 'A', 'B', 'A', 'C'],
-    )).toEqual(['A', 'B', 'C', 'B', 'D', 'C', 'A', 'B', 'A', 'C']);
+    expect(
+      shortestCommonSupersequence(
+        ["B", "D", "C", "A", "B", "A"],
+        ["A", "B", "C", "B", "D", "A", "B", "A", "C"]
+      )
+    ).toEqual(["A", "B", "C", "B", "D", "C", "A", "B", "A", "C"]);
   });
 });
+
diff --git a/src/algorithms/sets/shortest-common-supersequence/shortestCommonSupersequence.js b/src/algorithms/sets/shortest-common-supersequence/shortestCommonSupersequence.js
index 8b14b54..c7eaa42 100644
--- a/src/algorithms/sets/shortest-common-supersequence/shortestCommonSupersequence.js
+++ b/src/algorithms/sets/shortest-common-supersequence/shortestCommonSupersequence.js
@@ -1,4 +1,4 @@
-import longestCommonSubsequence from '../longest-common-subsequence/longestCommonSubsequence';
+import longestCommonSubsequence from "../longest-common-subsequence/longestCommonSubsequence";
 
 /**
  * @param {string[]} set1
@@ -12,7 +12,7 @@ export default function shortestCommonSupersequence(set1, set2) {
 
   // If LCS is empty then the shortest common supersequence would be just
   // concatenation of two sequences.
-  if (lcs.length === 1 && lcs[0] === '') {
+  if (lcs.length === 1 && lcs[0] === "") {
     return set1.concat(set2);
   }
 
@@ -69,3 +69,4 @@ export default function shortestCommonSupersequence(set1, set2) {
 
   return supersequence;
 }
+
diff --git a/src/algorithms/sorting/Sort.js b/src/algorithms/sorting/Sort.js
index e029088..6561175 100644
--- a/src/algorithms/sorting/Sort.js
+++ b/src/algorithms/sorting/Sort.js
@@ -1,4 +1,4 @@
-import Comparator from '../../utils/comparator/Comparator';
+import Comparator from "../../utils/comparator/Comparator";
 
 /**
  * @typedef {Object} SorterCallbacks
@@ -29,6 +29,7 @@ export default class Sort {
   }
 
   sort() {
-    throw new Error('sort method must be implemented');
+    throw new Error("sort method must be implemented");
   }
 }
+
diff --git a/src/algorithms/sorting/SortTester.js b/src/algorithms/sorting/SortTester.js
index e92ea39..60216de 100644
--- a/src/algorithms/sorting/SortTester.js
+++ b/src/algorithms/sorting/SortTester.js
@@ -1,7 +1,15 @@
-export const sortedArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
-export const reverseArr = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
-export const notSortedArr = [15, 8, 5, 12, 10, 1, 16, 9, 11, 7, 20, 3, 2, 6, 17, 18, 4, 13, 14, 19];
-export const equalArr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
+export const sortedArr = [
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
+];
+export const reverseArr = [
+  20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,
+];
+export const notSortedArr = [
+  15, 8, 5, 12, 10, 1, 16, 9, 11, 7, 20, 3, 2, 6, 17, 18, 4, 13, 14, 19,
+];
+export const equalArr = [
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+];
 export const negativeArr = [-1, 0, 5, -10, 20, 13, -7, 3, 2, -3];
 export const negativeArrSorted = [-10, -7, -3, -1, 0, 2, 3, 5, 13, 20];
 
@@ -13,7 +21,9 @@ export class SortTester {
     expect(sorter.sort([1])).toEqual([1]);
     expect(sorter.sort([1, 2])).toEqual([1, 2]);
     expect(sorter.sort([2, 1])).toEqual([1, 2]);
-    expect(sorter.sort([3, 4, 2, 1, 0, 0, 4, 3, 4, 2])).toEqual([0, 0, 1, 2, 2, 3, 3, 4, 4, 4]);
+    expect(sorter.sort([3, 4, 2, 1, 0, 0, 4, 3, 4, 2])).toEqual([
+      0, 0, 1, 2, 2, 3, 3, 4, 4, 4,
+    ]);
     expect(sorter.sort(sortedArr)).toEqual(sortedArr);
     expect(sorter.sort(reverseArr)).toEqual(sortedArr);
     expect(sorter.sort(notSortedArr)).toEqual(sortedArr);
@@ -37,11 +47,16 @@ export class SortTester {
 
     const sorter = new SortingClass(callbacks);
 
-    expect(sorter.sort([''])).toEqual(['']);
-    expect(sorter.sort(['a'])).toEqual(['a']);
-    expect(sorter.sort(['aa', 'a'])).toEqual(['a', 'aa']);
-    expect(sorter.sort(['aa', 'q', 'bbbb', 'ccc'])).toEqual(['q', 'aa', 'ccc', 'bbbb']);
-    expect(sorter.sort(['aa', 'aa'])).toEqual(['aa', 'aa']);
+    expect(sorter.sort([""])).toEqual([""]);
+    expect(sorter.sort(["a"])).toEqual(["a"]);
+    expect(sorter.sort(["aa", "a"])).toEqual(["a", "aa"]);
+    expect(sorter.sort(["aa", "q", "bbbb", "ccc"])).toEqual([
+      "q",
+      "aa",
+      "ccc",
+      "bbbb",
+    ]);
+    expect(sorter.sort(["aa", "aa"])).toEqual(["aa", "aa"]);
   }
 
   static testSortStability(SortingClass) {
@@ -56,11 +71,21 @@ export class SortTester {
 
     const sorter = new SortingClass(callbacks);
 
-    expect(sorter.sort(['bb', 'aa', 'c'])).toEqual(['c', 'bb', 'aa']);
-    expect(sorter.sort(['aa', 'q', 'a', 'bbbb', 'ccc'])).toEqual(['q', 'a', 'aa', 'ccc', 'bbbb']);
+    expect(sorter.sort(["bb", "aa", "c"])).toEqual(["c", "bb", "aa"]);
+    expect(sorter.sort(["aa", "q", "a", "bbbb", "ccc"])).toEqual([
+      "q",
+      "a",
+      "aa",
+      "ccc",
+      "bbbb",
+    ]);
   }
 
-  static testAlgorithmTimeComplexity(SortingClass, arrayToBeSorted, numberOfVisits) {
+  static testAlgorithmTimeComplexity(
+    SortingClass,
+    arrayToBeSorted,
+    numberOfVisits
+  ) {
     const visitingCallback = jest.fn();
     const callbacks = { visitingCallback };
     const sorter = new SortingClass(callbacks);
@@ -70,3 +95,4 @@ export class SortTester {
     expect(visitingCallback).toHaveBeenCalledTimes(numberOfVisits);
   }
 }
+
diff --git a/src/algorithms/sorting/__test__/Sort.test.js b/src/algorithms/sorting/__test__/Sort.test.js
index 989f3e7..c5efeda 100644
--- a/src/algorithms/sorting/__test__/Sort.test.js
+++ b/src/algorithms/sorting/__test__/Sort.test.js
@@ -1,7 +1,7 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
-describe('Sort', () => {
-  it('should throw an error when trying to call Sort.sort() method directly', () => {
+describe("Sort", () => {
+  it("should throw an error when trying to call Sort.sort() method directly", () => {
     function doForbiddenSort() {
       const sorter = new Sort();
       sorter.sort();
@@ -10,3 +10,4 @@ describe('Sort', () => {
     expect(doForbiddenSort).toThrow();
   });
 });
+
diff --git a/src/algorithms/sorting/bubble-sort/BubbleSort.js b/src/algorithms/sorting/bubble-sort/BubbleSort.js
index d78ebcb..193d6e8 100644
--- a/src/algorithms/sorting/bubble-sort/BubbleSort.js
+++ b/src/algorithms/sorting/bubble-sort/BubbleSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class BubbleSort extends Sort {
   sort(originalArray) {
@@ -19,7 +19,9 @@ export default class BubbleSort extends Sort {
 
         // Swap elements if they are in wrong order.
         if (this.comparator.lessThan(array[j + 1], array[j])) {
-          [array[j], array[j + 1]] = [array[j + 1], array[j]];
+          var _ref = [array[j + 1], array[j]];
+          array[j] = _ref[0];
+          array[j + 1] = _ref[1];
 
           // Register the swap.
           swapped = true;
@@ -36,3 +38,4 @@ export default class BubbleSort extends Sort {
     return array;
   }
 }
+
diff --git a/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js b/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js
index 7e71a0b..ff24c70 100644
--- a/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js
+++ b/src/algorithms/sorting/bubble-sort/__test__/BubbleSort.test.js
@@ -1,11 +1,11 @@
-import BubbleSort from '../BubbleSort';
+import BubbleSort from "../BubbleSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 20;
@@ -13,52 +13,53 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 189;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 209;
 const EQUAL_ARRAY_VISITING_COUNT = 20;
 
-describe('BubbleSort', () => {
-  it('should sort array', () => {
+describe("BubbleSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(BubbleSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(BubbleSort);
   });
 
-  it('should do stable sorting', () => {
+  it("should do stable sorting", () => {
     SortTester.testSortStability(BubbleSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(BubbleSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       BubbleSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       BubbleSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       BubbleSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       BubbleSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/counting-sort/CountingSort.js b/src/algorithms/sorting/counting-sort/CountingSort.js
index 7e810dc..d14988f 100644
--- a/src/algorithms/sorting/counting-sort/CountingSort.js
+++ b/src/algorithms/sorting/counting-sort/CountingSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class CountingSort extends Sort {
   /**
@@ -6,7 +6,15 @@ export default class CountingSort extends Sort {
    * @param {number} [smallestElement]
    * @param {number} [biggestElement]
    */
-  sort(originalArray, smallestElement = undefined, biggestElement = undefined) {
+  sort(originalArray) {
+    let smallestElement =
+      arguments.length > 1 && arguments[1] !== undefined
+        ? arguments[1]
+        : undefined;
+    let biggestElement =
+      arguments.length > 2 && arguments[2] !== undefined
+        ? arguments[2]
+        : undefined;
     // Init biggest and smallest elements in array in order to build number bucket array later.
     let detectedSmallestElement = smallestElement || 0;
     let detectedBiggestElement = biggestElement || 0;
@@ -30,7 +38,9 @@ export default class CountingSort extends Sort {
 
     // Init buckets array.
     // This array will hold frequency of each number from originalArray.
-    const buckets = Array(detectedBiggestElement - detectedSmallestElement + 1).fill(0);
+    const buckets = Array(
+      detectedBiggestElement - detectedSmallestElement + 1
+    ).fill(0);
 
     originalArray.forEach((element) => {
       // Visit element.
@@ -55,7 +65,11 @@ export default class CountingSort extends Sort {
 
     // Now let's assemble sorted array.
     const sortedArray = Array(originalArray.length).fill(null);
-    for (let elementIndex = 0; elementIndex < originalArray.length; elementIndex += 1) {
+    for (
+      let elementIndex = 0;
+      elementIndex < originalArray.length;
+      elementIndex += 1
+    ) {
       // Get the element that we want to put into correct sorted position.
       const element = originalArray[elementIndex];
 
@@ -76,3 +90,4 @@ export default class CountingSort extends Sort {
     return sortedArray;
   }
 }
+
diff --git a/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js b/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js
index 9bf5d5c..152b33a 100644
--- a/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js
+++ b/src/algorithms/sorting/counting-sort/__test__/CountingSort.test.js
@@ -1,11 +1,11 @@
-import CountingSort from '../CountingSort';
+import CountingSort from "../CountingSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 60;
@@ -13,16 +13,16 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 60;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 60;
 const EQUAL_ARRAY_VISITING_COUNT = 60;
 
-describe('CountingSort', () => {
-  it('should sort array', () => {
+describe("CountingSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(CountingSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(CountingSort);
   });
 
-  it('should allow to use specify max/min integer value in array to make sorting faster', () => {
+  it("should allow to use specify max/min integer value in array to make sorting faster", () => {
     const visitingCallback = jest.fn();
     const sorter = new CountingSort({ visitingCallback });
 
@@ -32,7 +32,11 @@ describe('CountingSort', () => {
     // Detect smallest number in array in prior.
     const smallestElement = Math.min(...notSortedArr);
 
-    const sortedArray = sorter.sort(notSortedArr, smallestElement, biggestElement);
+    const sortedArray = sorter.sort(
+      notSortedArr,
+      smallestElement,
+      biggestElement
+    );
 
     expect(sortedArray).toEqual(sortedArr);
     // Normally visitingCallback is being called 60 times but in this case
@@ -40,35 +44,36 @@ describe('CountingSort', () => {
     expect(visitingCallback).toHaveBeenCalledTimes(40);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       CountingSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       CountingSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       CountingSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       CountingSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/heap-sort/HeapSort.js b/src/algorithms/sorting/heap-sort/HeapSort.js
index 06e58e1..08e5583 100644
--- a/src/algorithms/sorting/heap-sort/HeapSort.js
+++ b/src/algorithms/sorting/heap-sort/HeapSort.js
@@ -1,5 +1,5 @@
-import Sort from '../Sort';
-import MinHeap from '../../../data-structures/heap/MinHeap';
+import Sort from "../Sort";
+import MinHeap from "../../../data-structures/heap/MinHeap";
 
 export default class HeapSort extends Sort {
   sort(originalArray) {
@@ -28,3 +28,4 @@ export default class HeapSort extends Sort {
     return sortedArray;
   }
 }
+
diff --git a/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js b/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js
index 75f690d..c5a2ac8 100644
--- a/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js
+++ b/src/algorithms/sorting/heap-sort/__test__/HeapSort.test.js
@@ -1,11 +1,11 @@
-import HeapSort from '../HeapSort';
+import HeapSort from "../HeapSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 // These numbers don't take into account up/dow heapifying of the heap.
@@ -15,48 +15,49 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 40;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 40;
 const EQUAL_ARRAY_VISITING_COUNT = 40;
 
-describe('HeapSort', () => {
-  it('should sort array', () => {
+describe("HeapSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(HeapSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(HeapSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(HeapSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       HeapSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       HeapSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       HeapSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       HeapSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/insertion-sort/InsertionSort.js b/src/algorithms/sorting/insertion-sort/InsertionSort.js
index 7a80161..26d1d81 100644
--- a/src/algorithms/sorting/insertion-sort/InsertionSort.js
+++ b/src/algorithms/sorting/insertion-sort/InsertionSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class InsertionSort extends Sort {
   sort(originalArray) {
@@ -14,20 +14,16 @@ export default class InsertionSort extends Sort {
       // Check if previous element is greater than current element.
       // If so, swap the two elements.
       while (
-        array[currentIndex - 1] !== undefined
-        && this.comparator.lessThan(array[currentIndex], array[currentIndex - 1])
+        array[currentIndex - 1] !== undefined &&
+        this.comparator.lessThan(array[currentIndex], array[currentIndex - 1])
       ) {
         // Call visiting callback.
         this.callbacks.visitingCallback(array[currentIndex - 1]);
 
         // Swap the elements.
-        [
-          array[currentIndex - 1],
-          array[currentIndex],
-        ] = [
-          array[currentIndex],
-          array[currentIndex - 1],
-        ];
+        var _ref = [array[currentIndex], array[currentIndex - 1]];
+        array[currentIndex - 1] = _ref[0];
+        array[currentIndex] = _ref[1];
 
         // Shift current index left.
         currentIndex -= 1;
@@ -37,3 +33,4 @@ export default class InsertionSort extends Sort {
     return array;
   }
 }
+
diff --git a/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js b/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js
index 8453b7d..6a8ba90 100644
--- a/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js
+++ b/src/algorithms/sorting/insertion-sort/__test__/InsertionSort.test.js
@@ -1,11 +1,11 @@
-import InsertionSort from '../InsertionSort';
+import InsertionSort from "../InsertionSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 19;
@@ -13,52 +13,53 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 100;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 209;
 const EQUAL_ARRAY_VISITING_COUNT = 19;
 
-describe('InsertionSort', () => {
-  it('should sort array', () => {
+describe("InsertionSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(InsertionSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(InsertionSort);
   });
 
-  it('should do stable sorting', () => {
+  it("should do stable sorting", () => {
     SortTester.testSortStability(InsertionSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(InsertionSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       InsertionSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       InsertionSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       InsertionSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       InsertionSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/merge-sort/MergeSort.js b/src/algorithms/sorting/merge-sort/MergeSort.js
index 23fca74..91851fe 100644
--- a/src/algorithms/sorting/merge-sort/MergeSort.js
+++ b/src/algorithms/sorting/merge-sort/MergeSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class MergeSort extends Sort {
   sort(originalArray) {
@@ -34,7 +34,12 @@ export default class MergeSort extends Sort {
       let minElement = null;
 
       // Find the minimum element between the left and right array.
-      if (this.comparator.lessThanOrEqual(leftArray[leftIndex], rightArray[rightIndex])) {
+      if (
+        this.comparator.lessThanOrEqual(
+          leftArray[leftIndex],
+          rightArray[rightIndex]
+        )
+      ) {
         minElement = leftArray[leftIndex];
         // Increment index pointer to the right
         leftIndex += 1;
@@ -58,3 +63,4 @@ export default class MergeSort extends Sort {
       .concat(rightArray.slice(rightIndex));
   }
 }
+
diff --git a/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js b/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js
index 0112003..4a19e75 100644
--- a/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js
+++ b/src/algorithms/sorting/merge-sort/__test__/MergeSort.test.js
@@ -1,11 +1,11 @@
-import MergeSort from '../MergeSort';
+import MergeSort from "../MergeSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 79;
@@ -13,52 +13,53 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 102;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 87;
 const EQUAL_ARRAY_VISITING_COUNT = 79;
 
-describe('MergeSort', () => {
-  it('should sort array', () => {
+describe("MergeSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(MergeSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(MergeSort);
   });
 
-  it('should do stable sorting', () => {
+  it("should do stable sorting", () => {
     SortTester.testSortStability(MergeSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(MergeSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       MergeSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       MergeSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       MergeSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       MergeSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/quick-sort/QuickSort.js b/src/algorithms/sorting/quick-sort/QuickSort.js
index 1c63c86..614932d 100644
--- a/src/algorithms/sorting/quick-sort/QuickSort.js
+++ b/src/algorithms/sorting/quick-sort/QuickSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class QuickSort extends Sort {
   /**
@@ -46,3 +46,4 @@ export default class QuickSort extends Sort {
     return leftArraySorted.concat(centerArray, rightArraySorted);
   }
 }
+
diff --git a/src/algorithms/sorting/quick-sort/QuickSortInPlace.js b/src/algorithms/sorting/quick-sort/QuickSortInPlace.js
index cc1f5e5..a53d68c 100644
--- a/src/algorithms/sorting/quick-sort/QuickSortInPlace.js
+++ b/src/algorithms/sorting/quick-sort/QuickSortInPlace.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class QuickSortInPlace extends Sort {
   /** Sorting in place avoids unnecessary use of additional memory, but modifies input array.
@@ -12,12 +12,15 @@ export default class QuickSortInPlace extends Sort {
    * @param {boolean} recursiveCall
    * @return {*[]} - Sorted array.
    */
-  sort(
-    originalArray,
-    inputLowIndex = 0,
-    inputHighIndex = originalArray.length - 1,
-    recursiveCall = false,
-  ) {
+  sort(originalArray) {
+    let inputLowIndex =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+    let inputHighIndex =
+      arguments.length > 2 && arguments[2] !== undefined
+        ? arguments[2]
+        : originalArray.length - 1;
+    let recursiveCall =
+      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
     // Copies array on initial call, and then sorts in place.
     const array = recursiveCall ? originalArray : [...originalArray];
 
@@ -49,7 +52,11 @@ export default class QuickSortInPlace extends Sort {
       this.callbacks.visitingCallback(pivot);
 
       let partitionIndex = lowIndex;
-      for (let currentIndex = lowIndex; currentIndex < highIndex; currentIndex += 1) {
+      for (
+        let currentIndex = lowIndex;
+        currentIndex < highIndex;
+        currentIndex += 1
+      ) {
         if (this.comparator.lessThan(array[currentIndex], pivot)) {
           swap(partitionIndex, currentIndex);
           partitionIndex += 1;
@@ -76,3 +83,4 @@ export default class QuickSortInPlace extends Sort {
     return array;
   }
 }
+
diff --git a/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js b/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js
index 71c1fe7..39d336f 100644
--- a/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js
+++ b/src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js
@@ -1,11 +1,11 @@
-import QuickSort from '../QuickSort';
+import QuickSort from "../QuickSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 190;
@@ -13,52 +13,53 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 62;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 190;
 const EQUAL_ARRAY_VISITING_COUNT = 19;
 
-describe('QuickSort', () => {
-  it('should sort array', () => {
+describe("QuickSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(QuickSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(QuickSort);
   });
 
-  it('should do stable sorting', () => {
+  it("should do stable sorting", () => {
     SortTester.testSortStability(QuickSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(QuickSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js b/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js
index 0e103f2..1e9e1c9 100644
--- a/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js
+++ b/src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js
@@ -1,11 +1,11 @@
-import QuickSortInPlace from '../QuickSortInPlace';
+import QuickSortInPlace from "../QuickSortInPlace";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 19;
@@ -13,48 +13,49 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 12;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 19;
 const EQUAL_ARRAY_VISITING_COUNT = 19;
 
-describe('QuickSortInPlace', () => {
-  it('should sort array', () => {
+describe("QuickSortInPlace", () => {
+  it("should sort array", () => {
     SortTester.testSort(QuickSortInPlace);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(QuickSortInPlace);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(QuickSortInPlace);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSortInPlace,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSortInPlace,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSortInPlace,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       QuickSortInPlace,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/radix-sort/RadixSort.js b/src/algorithms/sorting/radix-sort/RadixSort.js
index 8e8dccf..35d165d 100644
--- a/src/algorithms/sorting/radix-sort/RadixSort.js
+++ b/src/algorithms/sorting/radix-sort/RadixSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 // Using charCode (a = 97, b = 98, etc), we can map characters to buckets from 0 - 25
 const BASE_CHAR_CODE = 97;
@@ -20,7 +20,11 @@ export default class RadixSort extends Sort {
     for (let currentIndex = 0; currentIndex < numPasses; currentIndex += 1) {
       const buckets = isArrayOfNumbers
         ? this.placeElementsInNumberBuckets(sortedArray, currentIndex)
-        : this.placeElementsInCharacterBuckets(sortedArray, currentIndex, numPasses);
+        : this.placeElementsInCharacterBuckets(
+            sortedArray,
+            currentIndex,
+            numPasses
+          );
 
       // Flatten buckets into sortedArray, and repeat at next index
       sortedArray = buckets.reduce((acc, val) => {
@@ -71,7 +75,11 @@ export default class RadixSort extends Sort {
 
     array.forEach((element) => {
       this.callbacks.visitingCallback(element);
-      const currentBucket = this.getCharCodeOfElementAtIndex(element, index, numPasses);
+      const currentBucket = this.getCharCodeOfElementAtIndex(
+        element,
+        index,
+        numPasses
+      );
       buckets[currentBucket].push(element);
     });
 
@@ -86,7 +94,7 @@ export default class RadixSort extends Sort {
    */
   getCharCodeOfElementAtIndex(element, index, numPasses) {
     // Place element in last bucket if not ready to organize
-    if ((numPasses - index) > element.length) {
+    if (numPasses - index > element.length) {
       return ENGLISH_ALPHABET_LENGTH - 1;
     }
 
@@ -150,3 +158,4 @@ export default class RadixSort extends Sort {
     return Number.isInteger(element);
   }
 }
+
diff --git a/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js b/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js
index ece7136..ac1c058 100644
--- a/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js
+++ b/src/algorithms/sorting/radix-sort/__test__/RadixSort.test.js
@@ -1,27 +1,28 @@
-import RadixSort from '../RadixSort';
-import { SortTester } from '../../SortTester';
+import RadixSort from "../RadixSort";
+import { SortTester } from "../../SortTester";
 
 // Complexity constants.
 const ARRAY_OF_STRINGS_VISIT_COUNT = 24;
 const ARRAY_OF_INTEGERS_VISIT_COUNT = 77;
-describe('RadixSort', () => {
-  it('should sort array', () => {
+describe("RadixSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(RadixSort);
   });
 
-  it('should visit array of strings n (number of strings) x m (length of longest element) times', () => {
+  it("should visit array of strings n (number of strings) x m (length of longest element) times", () => {
     SortTester.testAlgorithmTimeComplexity(
       RadixSort,
-      ['zzz', 'bb', 'a', 'rr', 'rrb', 'rrba'],
-      ARRAY_OF_STRINGS_VISIT_COUNT,
+      ["zzz", "bb", "a", "rr", "rrb", "rrba"],
+      ARRAY_OF_STRINGS_VISIT_COUNT
     );
   });
 
-  it('should visit array of integers n (number of elements) x m (length of longest integer) times', () => {
+  it("should visit array of integers n (number of elements) x m (length of longest integer) times", () => {
     SortTester.testAlgorithmTimeComplexity(
       RadixSort,
       [3, 1, 75, 32, 884, 523, 4343456, 232, 123, 656, 343],
-      ARRAY_OF_INTEGERS_VISIT_COUNT,
+      ARRAY_OF_INTEGERS_VISIT_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/selection-sort/SelectionSort.js b/src/algorithms/sorting/selection-sort/SelectionSort.js
index fa4a720..30d954f 100644
--- a/src/algorithms/sorting/selection-sort/SelectionSort.js
+++ b/src/algorithms/sorting/selection-sort/SelectionSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class SelectionSort extends Sort {
   sort(originalArray) {
@@ -23,10 +23,13 @@ export default class SelectionSort extends Sort {
 
       // If new minimum element has been found then swap it with current i-th element.
       if (minIndex !== i) {
-        [array[i], array[minIndex]] = [array[minIndex], array[i]];
+        var _ref = [array[minIndex], array[i]];
+        array[i] = _ref[0];
+        array[minIndex] = _ref[1];
       }
     }
 
     return array;
   }
 }
+
diff --git a/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js b/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js
index d52385d..17ef8a8 100644
--- a/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js
+++ b/src/algorithms/sorting/selection-sort/__test__/SelectionSort.test.js
@@ -1,11 +1,11 @@
-import SelectionSort from '../SelectionSort';
+import SelectionSort from "../SelectionSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 209;
@@ -13,48 +13,49 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 209;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 209;
 const EQUAL_ARRAY_VISITING_COUNT = 209;
 
-describe('SelectionSort', () => {
-  it('should sort array', () => {
+describe("SelectionSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(SelectionSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(SelectionSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(SelectionSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       SelectionSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       SelectionSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       SelectionSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       SelectionSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/sorting/shell-sort/ShellSort.js b/src/algorithms/sorting/shell-sort/ShellSort.js
index cdbba99..a33d368 100644
--- a/src/algorithms/sorting/shell-sort/ShellSort.js
+++ b/src/algorithms/sorting/shell-sort/ShellSort.js
@@ -1,4 +1,4 @@
-import Sort from '../Sort';
+import Sort from "../Sort";
 
 export default class ShellSort extends Sort {
   sort(originalArray) {
@@ -11,7 +11,7 @@ export default class ShellSort extends Sort {
     // Until gap is bigger then zero do elements comparisons and swaps.
     while (gap > 0) {
       // Go and compare all distant element pairs.
-      for (let i = 0; i < (array.length - gap); i += 1) {
+      for (let i = 0; i < array.length - gap; i += 1) {
         let currentIndex = i;
         let gapShiftedIndex = i + gap;
 
@@ -20,7 +20,12 @@ export default class ShellSort extends Sort {
           this.callbacks.visitingCallback(array[currentIndex]);
 
           // Compare and swap array elements if needed.
-          if (this.comparator.lessThan(array[gapShiftedIndex], array[currentIndex])) {
+          if (
+            this.comparator.lessThan(
+              array[gapShiftedIndex],
+              array[currentIndex]
+            )
+          ) {
             const tmp = array[currentIndex];
             array[currentIndex] = array[gapShiftedIndex];
             array[gapShiftedIndex] = tmp;
@@ -39,3 +44,4 @@ export default class ShellSort extends Sort {
     return array;
   }
 }
+
diff --git a/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js b/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js
index 454845f..4bdb919 100644
--- a/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js
+++ b/src/algorithms/sorting/shell-sort/__test__/ShellSort.test.js
@@ -1,11 +1,11 @@
-import ShellSort from '../ShellSort';
+import ShellSort from "../ShellSort";
 import {
   equalArr,
   notSortedArr,
   reverseArr,
   sortedArr,
   SortTester,
-} from '../../SortTester';
+} from "../../SortTester";
 
 // Complexity constants.
 const SORTED_ARRAY_VISITING_COUNT = 320;
@@ -13,48 +13,49 @@ const NOT_SORTED_ARRAY_VISITING_COUNT = 320;
 const REVERSE_SORTED_ARRAY_VISITING_COUNT = 320;
 const EQUAL_ARRAY_VISITING_COUNT = 320;
 
-describe('ShellSort', () => {
-  it('should sort array', () => {
+describe("ShellSort", () => {
+  it("should sort array", () => {
     SortTester.testSort(ShellSort);
   });
 
-  it('should sort array with custom comparator', () => {
+  it("should sort array with custom comparator", () => {
     SortTester.testSortWithCustomComparator(ShellSort);
   });
 
-  it('should sort negative numbers', () => {
+  it("should sort negative numbers", () => {
     SortTester.testNegativeNumbersSort(ShellSort);
   });
 
-  it('should visit EQUAL array element specified number of times', () => {
+  it("should visit EQUAL array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       ShellSort,
       equalArr,
-      EQUAL_ARRAY_VISITING_COUNT,
+      EQUAL_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit SORTED array element specified number of times', () => {
+  it("should visit SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       ShellSort,
       sortedArr,
-      SORTED_ARRAY_VISITING_COUNT,
+      SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit NOT SORTED array element specified number of times', () => {
+  it("should visit NOT SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       ShellSort,
       notSortedArr,
-      NOT_SORTED_ARRAY_VISITING_COUNT,
+      NOT_SORTED_ARRAY_VISITING_COUNT
     );
   });
 
-  it('should visit REVERSE SORTED array element specified number of times', () => {
+  it("should visit REVERSE SORTED array element specified number of times", () => {
     SortTester.testAlgorithmTimeComplexity(
       ShellSort,
       reverseArr,
-      REVERSE_SORTED_ARRAY_VISITING_COUNT,
+      REVERSE_SORTED_ARRAY_VISITING_COUNT
     );
   });
 });
+
diff --git a/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js b/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js
index 1b0b267..12d64cc 100644
--- a/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js
+++ b/src/algorithms/statistics/weighted-random/__test__/weightedRandom.test.js
@@ -1,30 +1,52 @@
-import weightedRandom from '../weightedRandom';
+import weightedRandom from "../weightedRandom";
 
-describe('weightedRandom', () => {
-  it('should throw an error when the number of weights does not match the number of items', () => {
+describe("weightedRandom", () => {
+  it("should throw an error when the number of weights does not match the number of items", () => {
     const getWeightedRandomWithInvalidInputs = () => {
-      weightedRandom(['a', 'b', 'c'], [10, 0]);
+      weightedRandom(["a", "b", "c"], [10, 0]);
     };
-    expect(getWeightedRandomWithInvalidInputs).toThrow('Items and weights must be of the same size');
+    expect(getWeightedRandomWithInvalidInputs).toThrow(
+      "Items and weights must be of the same size"
+    );
   });
 
-  it('should throw an error when the number of weights or items are empty', () => {
+  it("should throw an error when the number of weights or items are empty", () => {
     const getWeightedRandomWithInvalidInputs = () => {
       weightedRandom([], []);
     };
-    expect(getWeightedRandomWithInvalidInputs).toThrow('Items must not be empty');
+    expect(getWeightedRandomWithInvalidInputs).toThrow(
+      "Items must not be empty"
+    );
   });
 
-  it('should correctly do random selection based on wights in straightforward cases', () => {
-    expect(weightedRandom(['a', 'b', 'c'], [1, 0, 0])).toEqual({ index: 0, item: 'a' });
-    expect(weightedRandom(['a', 'b', 'c'], [0, 1, 0])).toEqual({ index: 1, item: 'b' });
-    expect(weightedRandom(['a', 'b', 'c'], [0, 0, 1])).toEqual({ index: 2, item: 'c' });
-    expect(weightedRandom(['a', 'b', 'c'], [0, 1, 1])).not.toEqual({ index: 0, item: 'a' });
-    expect(weightedRandom(['a', 'b', 'c'], [1, 0, 1])).not.toEqual({ index: 1, item: 'b' });
-    expect(weightedRandom(['a', 'b', 'c'], [1, 1, 0])).not.toEqual({ index: 2, item: 'c' });
+  it("should correctly do random selection based on wights in straightforward cases", () => {
+    expect(weightedRandom(["a", "b", "c"], [1, 0, 0])).toEqual({
+      index: 0,
+      item: "a",
+    });
+    expect(weightedRandom(["a", "b", "c"], [0, 1, 0])).toEqual({
+      index: 1,
+      item: "b",
+    });
+    expect(weightedRandom(["a", "b", "c"], [0, 0, 1])).toEqual({
+      index: 2,
+      item: "c",
+    });
+    expect(weightedRandom(["a", "b", "c"], [0, 1, 1])).not.toEqual({
+      index: 0,
+      item: "a",
+    });
+    expect(weightedRandom(["a", "b", "c"], [1, 0, 1])).not.toEqual({
+      index: 1,
+      item: "b",
+    });
+    expect(weightedRandom(["a", "b", "c"], [1, 1, 0])).not.toEqual({
+      index: 2,
+      item: "c",
+    });
   });
 
-  it('should correctly do random selection based on wights', () => {
+  it("should correctly do random selection based on wights", () => {
     // Number of times we're going to select the random items based on their weights.
     const ATTEMPTS_NUM = 1000;
     // The +/- delta in the number of times each item has been actually selected.
@@ -33,7 +55,7 @@ describe('weightedRandom', () => {
     // ans smaller than 350 (which is 300 + 50)
     const THRESHOLD = 50;
 
-    const items = ['a', 'b', 'c']; // The actual items values don't matter.
+    const items = ["a", "b", "c"]; // The actual items values don't matter.
     const weights = [0.1, 0.3, 0.6];
 
     const counter = [];
@@ -50,15 +72,19 @@ describe('weightedRandom', () => {
       /*
         i.e. item with the index of 0 must be selected 100 times (ideally)
         or with the threshold of [100 - 50, 100 + 50] times.
-
-        i.e. item with the index of 1 must be selected 300 times (ideally)
+          i.e. item with the index of 1 must be selected 300 times (ideally)
         or with the threshold of [300 - 50, 300 + 50] times.
-
-        i.e. item with the index of 2 must be selected 600 times (ideally)
+          i.e. item with the index of 2 must be selected 600 times (ideally)
         or with the threshold of [600 - 50, 600 + 50] times.
        */
-      expect(counter[itemIndex]).toBeGreaterThan(ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD);
-      expect(counter[itemIndex]).toBeLessThan(ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD);
+
+      expect(counter[itemIndex]).toBeGreaterThan(
+        ATTEMPTS_NUM * weights[itemIndex] - THRESHOLD
+      );
+      expect(counter[itemIndex]).toBeLessThan(
+        ATTEMPTS_NUM * weights[itemIndex] + THRESHOLD
+      );
     }
   });
 });
+
diff --git a/src/algorithms/statistics/weighted-random/weightedRandom.js b/src/algorithms/statistics/weighted-random/weightedRandom.js
index 0d58a50..e91ad93 100644
--- a/src/algorithms/statistics/weighted-random/weightedRandom.js
+++ b/src/algorithms/statistics/weighted-random/weightedRandom.js
@@ -15,11 +15,11 @@
 /* eslint-disable consistent-return */
 export default function weightedRandom(items, weights) {
   if (items.length !== weights.length) {
-    throw new Error('Items and weights must be of the same size');
+    throw new Error("Items and weights must be of the same size");
   }
 
   if (!items.length) {
-    throw new Error('Items must not be empty');
+    throw new Error("Items must not be empty");
   }
 
   // Preparing the cumulative weights array.
@@ -50,3 +50,4 @@ export default function weightedRandom(items, weights) {
     }
   }
 }
+
diff --git a/src/algorithms/string/hamming-distance/__test__/hammingDistance.test.js b/src/algorithms/string/hamming-distance/__test__/hammingDistance.test.js
index e8e8fd7..a12eb3d 100644
--- a/src/algorithms/string/hamming-distance/__test__/hammingDistance.test.js
+++ b/src/algorithms/string/hamming-distance/__test__/hammingDistance.test.js
@@ -1,21 +1,22 @@
-import hammingDistance from '../hammingDistance';
+import hammingDistance from "../hammingDistance";
 
-describe('hammingDistance', () => {
-  it('should throw an error when trying to compare the strings of different lengths', () => {
+describe("hammingDistance", () => {
+  it("should throw an error when trying to compare the strings of different lengths", () => {
     const compareStringsOfDifferentLength = () => {
-      hammingDistance('a', 'aa');
+      hammingDistance("a", "aa");
     };
 
     expect(compareStringsOfDifferentLength).toThrowError();
   });
 
-  it('should calculate difference between two strings', () => {
-    expect(hammingDistance('a', 'a')).toBe(0);
-    expect(hammingDistance('a', 'b')).toBe(1);
-    expect(hammingDistance('abc', 'add')).toBe(2);
-    expect(hammingDistance('karolin', 'kathrin')).toBe(3);
-    expect(hammingDistance('karolin', 'kerstin')).toBe(3);
-    expect(hammingDistance('1011101', '1001001')).toBe(2);
-    expect(hammingDistance('2173896', '2233796')).toBe(3);
+  it("should calculate difference between two strings", () => {
+    expect(hammingDistance("a", "a")).toBe(0);
+    expect(hammingDistance("a", "b")).toBe(1);
+    expect(hammingDistance("abc", "add")).toBe(2);
+    expect(hammingDistance("karolin", "kathrin")).toBe(3);
+    expect(hammingDistance("karolin", "kerstin")).toBe(3);
+    expect(hammingDistance("1011101", "1001001")).toBe(2);
+    expect(hammingDistance("2173896", "2233796")).toBe(3);
   });
 });
+
diff --git a/src/algorithms/string/hamming-distance/hammingDistance.js b/src/algorithms/string/hamming-distance/hammingDistance.js
index 3749e78..2277777 100644
--- a/src/algorithms/string/hamming-distance/hammingDistance.js
+++ b/src/algorithms/string/hamming-distance/hammingDistance.js
@@ -5,7 +5,7 @@
  */
 export default function hammingDistance(a, b) {
   if (a.length !== b.length) {
-    throw new Error('Strings must be of the same length');
+    throw new Error("Strings must be of the same length");
   }
 
   let distance = 0;
@@ -18,3 +18,4 @@ export default function hammingDistance(a, b) {
 
   return distance;
 }
+
diff --git a/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js b/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js
index 17f6a69..23b0d4b 100644
--- a/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js
+++ b/src/algorithms/string/knuth-morris-pratt/__test__/knuthMorrisPratt.test.js
@@ -1,15 +1,20 @@
-import knuthMorrisPratt from '../knuthMorrisPratt';
+import knuthMorrisPratt from "../knuthMorrisPratt";
 
-describe('knuthMorrisPratt', () => {
-  it('should find word position in given text', () => {
-    expect(knuthMorrisPratt('', '')).toBe(0);
-    expect(knuthMorrisPratt('a', '')).toBe(0);
-    expect(knuthMorrisPratt('a', 'a')).toBe(0);
-    expect(knuthMorrisPratt('abcbcglx', 'abca')).toBe(-1);
-    expect(knuthMorrisPratt('abcbcglx', 'bcgl')).toBe(3);
-    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
-    expect(knuthMorrisPratt('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
-    expect(knuthMorrisPratt('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
-    expect(knuthMorrisPratt('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
+describe("knuthMorrisPratt", () => {
+  it("should find word position in given text", () => {
+    expect(knuthMorrisPratt("", "")).toBe(0);
+    expect(knuthMorrisPratt("a", "")).toBe(0);
+    expect(knuthMorrisPratt("a", "a")).toBe(0);
+    expect(knuthMorrisPratt("abcbcglx", "abca")).toBe(-1);
+    expect(knuthMorrisPratt("abcbcglx", "bcgl")).toBe(3);
+    expect(knuthMorrisPratt("abcxabcdabxabcdabcdabcy", "abcdabcy")).toBe(15);
+    expect(knuthMorrisPratt("abcxabcdabxabcdabcdabcy", "abcdabca")).toBe(-1);
+    expect(
+      knuthMorrisPratt("abcxabcdabxaabcdabcabcdabcdabcy", "abcdabca")
+    ).toBe(12);
+    expect(
+      knuthMorrisPratt("abcxabcdabxaabaabaaaabcdabcdabcy", "aabaabaaa")
+    ).toBe(11);
   });
 });
+
diff --git a/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js b/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js
index a3a3990..3836a02 100644
--- a/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js
+++ b/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js
@@ -43,7 +43,7 @@ export default function knuthMorrisPratt(text, word) {
     if (text[textIndex] === word[wordIndex]) {
       // We've found a match.
       if (wordIndex === word.length - 1) {
-        return (textIndex - word.length) + 1;
+        return textIndex - word.length + 1;
       }
       wordIndex += 1;
       textIndex += 1;
@@ -57,3 +57,4 @@ export default function knuthMorrisPratt(text, word) {
 
   return -1;
 }
+
diff --git a/src/algorithms/string/levenshtein-distance/__test__/levenshteinDistance.test.js b/src/algorithms/string/levenshtein-distance/__test__/levenshteinDistance.test.js
index e4e46d5..69c204d 100644
--- a/src/algorithms/string/levenshtein-distance/__test__/levenshteinDistance.test.js
+++ b/src/algorithms/string/levenshtein-distance/__test__/levenshteinDistance.test.js
@@ -1,29 +1,30 @@
-import levenshteinDistance from '../levenshteinDistance';
+import levenshteinDistance from "../levenshteinDistance";
 
-describe('levenshteinDistance', () => {
-  it('should calculate edit distance between two strings', () => {
-    expect(levenshteinDistance('', '')).toBe(0);
-    expect(levenshteinDistance('a', '')).toBe(1);
-    expect(levenshteinDistance('', 'a')).toBe(1);
-    expect(levenshteinDistance('abc', '')).toBe(3);
-    expect(levenshteinDistance('', 'abc')).toBe(3);
+describe("levenshteinDistance", () => {
+  it("should calculate edit distance between two strings", () => {
+    expect(levenshteinDistance("", "")).toBe(0);
+    expect(levenshteinDistance("a", "")).toBe(1);
+    expect(levenshteinDistance("", "a")).toBe(1);
+    expect(levenshteinDistance("abc", "")).toBe(3);
+    expect(levenshteinDistance("", "abc")).toBe(3);
 
     // Should just add I to the beginning.
-    expect(levenshteinDistance('islander', 'slander')).toBe(1);
+    expect(levenshteinDistance("islander", "slander")).toBe(1);
 
     // Needs to substitute M by K, T by M and add an A to the end
-    expect(levenshteinDistance('mart', 'karma')).toBe(3);
+    expect(levenshteinDistance("mart", "karma")).toBe(3);
 
     // Substitute K by S, E by I and insert G at the end.
-    expect(levenshteinDistance('kitten', 'sitting')).toBe(3);
+    expect(levenshteinDistance("kitten", "sitting")).toBe(3);
 
     // Should add 4 letters FOOT at the beginning.
-    expect(levenshteinDistance('ball', 'football')).toBe(4);
+    expect(levenshteinDistance("ball", "football")).toBe(4);
 
     // Should delete 4 letters FOOT at the beginning.
-    expect(levenshteinDistance('football', 'foot')).toBe(4);
+    expect(levenshteinDistance("football", "foot")).toBe(4);
 
     // Needs to substitute the first 5 chars: INTEN by EXECU
-    expect(levenshteinDistance('intention', 'execution')).toBe(5);
+    expect(levenshteinDistance("intention", "execution")).toBe(5);
   });
 });
+
diff --git a/src/algorithms/string/levenshtein-distance/levenshteinDistance.js b/src/algorithms/string/levenshtein-distance/levenshteinDistance.js
index f082f42..716dd51 100644
--- a/src/algorithms/string/levenshtein-distance/levenshteinDistance.js
+++ b/src/algorithms/string/levenshtein-distance/levenshteinDistance.js
@@ -6,7 +6,9 @@
 export default function levenshteinDistance(a, b) {
   // Create empty edit distance matrix for all possible modifications of
   // substrings of a to substrings of b.
-  const distanceMatrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
+  const distanceMatrix = Array(b.length + 1)
+    .fill(null)
+    .map(() => Array(a.length + 1).fill(null));
 
   // Fill the first row of the matrix.
   // If this is first row then we're transforming empty string to a.
@@ -28,10 +30,11 @@ export default function levenshteinDistance(a, b) {
       distanceMatrix[j][i] = Math.min(
         distanceMatrix[j][i - 1] + 1, // deletion
         distanceMatrix[j - 1][i] + 1, // insertion
-        distanceMatrix[j - 1][i - 1] + indicator, // substitution
+        distanceMatrix[j - 1][i - 1] + indicator // substitution
       );
     }
   }
 
   return distanceMatrix[b.length][a.length];
 }
+
diff --git a/src/algorithms/string/longest-common-substring/__test__/longestCommonSubstring.test.js b/src/algorithms/string/longest-common-substring/__test__/longestCommonSubstring.test.js
index a24c0df..5977e81 100644
--- a/src/algorithms/string/longest-common-substring/__test__/longestCommonSubstring.test.js
+++ b/src/algorithms/string/longest-common-substring/__test__/longestCommonSubstring.test.js
@@ -1,22 +1,27 @@
-import longestCommonSubstring from '../longestCommonSubstring';
+import longestCommonSubstring from "../longestCommonSubstring";
 
-describe('longestCommonSubstring', () => {
-  it('should find longest common substring between two strings', () => {
-    expect(longestCommonSubstring('', '')).toBe('');
-    expect(longestCommonSubstring('ABC', '')).toBe('');
-    expect(longestCommonSubstring('', 'ABC')).toBe('');
-    expect(longestCommonSubstring('ABABC', 'BABCA')).toBe('BABC');
-    expect(longestCommonSubstring('BABCA', 'ABCBA')).toBe('ABC');
-    expect(longestCommonSubstring(
-      'Algorithms and data structures implemented in JavaScript',
-      'Here you may find Algorithms and data structures that are implemented in JavaScript',
-    )).toBe('Algorithms and data structures ');
+describe("longestCommonSubstring", () => {
+  it("should find longest common substring between two strings", () => {
+    expect(longestCommonSubstring("", "")).toBe("");
+    expect(longestCommonSubstring("ABC", "")).toBe("");
+    expect(longestCommonSubstring("", "ABC")).toBe("");
+    expect(longestCommonSubstring("ABABC", "BABCA")).toBe("BABC");
+    expect(longestCommonSubstring("BABCA", "ABCBA")).toBe("ABC");
+    expect(
+      longestCommonSubstring(
+        "Algorithms and data structures implemented in JavaScript",
+        "Here you may find Algorithms and data structures that are implemented in JavaScript"
+      )
+    ).toBe("Algorithms and data structures ");
   });
 
-  it('should handle unicode correctly', () => {
-    expect(longestCommonSubstring('𐌵𐌵**ABC', '𐌵𐌵--ABC')).toBe('ABC');
-    expect(longestCommonSubstring('𐌵𐌵**A', '𐌵𐌵--A')).toBe('𐌵𐌵');
-    expect(longestCommonSubstring('A买B时', '买B时GD')).toBe('买B时');
-    expect(longestCommonSubstring('After test买时 case', 'another_test买时')).toBe('test买时');
+  it("should handle unicode correctly", () => {
+    expect(longestCommonSubstring("𐌵𐌵**ABC", "𐌵𐌵--ABC")).toBe("ABC");
+    expect(longestCommonSubstring("𐌵𐌵**A", "𐌵𐌵--A")).toBe("𐌵𐌵");
+    expect(longestCommonSubstring("A买B时", "买B时GD")).toBe("买B时");
+    expect(
+      longestCommonSubstring("After test买时 case", "another_test买时")
+    ).toBe("test买时");
   });
 });
+
diff --git a/src/algorithms/string/longest-common-substring/longestCommonSubstring.js b/src/algorithms/string/longest-common-substring/longestCommonSubstring.js
index 1d68ede..e7b6186 100644
--- a/src/algorithms/string/longest-common-substring/longestCommonSubstring.js
+++ b/src/algorithms/string/longest-common-substring/longestCommonSubstring.js
@@ -12,9 +12,11 @@ export default function longestCommonSubstring(string1, string2) {
   const s2 = [...string2];
 
   // Init the matrix of all substring lengths to use Dynamic Programming approach.
-  const substringMatrix = Array(s2.length + 1).fill(null).map(() => {
-    return Array(s1.length + 1).fill(null);
-  });
+  const substringMatrix = Array(s2.length + 1)
+    .fill(null)
+    .map(() => {
+      return Array(s1.length + 1).fill(null);
+    });
 
   // Fill the first row and first column with zeros to provide initial values.
   for (let columnIndex = 0; columnIndex <= s1.length; columnIndex += 1) {
@@ -33,7 +35,8 @@ export default function longestCommonSubstring(string1, string2) {
   for (let rowIndex = 1; rowIndex <= s2.length; rowIndex += 1) {
     for (let columnIndex = 1; columnIndex <= s1.length; columnIndex += 1) {
       if (s1[columnIndex - 1] === s2[rowIndex - 1]) {
-        substringMatrix[rowIndex][columnIndex] = substringMatrix[rowIndex - 1][columnIndex - 1] + 1;
+        substringMatrix[rowIndex][columnIndex] =
+          substringMatrix[rowIndex - 1][columnIndex - 1] + 1;
       } else {
         substringMatrix[rowIndex][columnIndex] = 0;
       }
@@ -50,11 +53,11 @@ export default function longestCommonSubstring(string1, string2) {
 
   if (longestSubstringLength === 0) {
     // Longest common substring has not been found.
-    return '';
+    return "";
   }
 
   // Detect the longest substring from the matrix.
-  let longestSubstring = '';
+  let longestSubstring = "";
 
   while (substringMatrix[longestSubstringRow][longestSubstringColumn] > 0) {
     longestSubstring = s1[longestSubstringColumn - 1] + longestSubstring;
@@ -64,3 +67,4 @@ export default function longestCommonSubstring(string1, string2) {
 
   return longestSubstring;
 }
+
diff --git a/src/algorithms/string/palindrome/__test__/isPalindrome.test.js b/src/algorithms/string/palindrome/__test__/isPalindrome.test.js
index 0a49d5b..03db9d2 100644
--- a/src/algorithms/string/palindrome/__test__/isPalindrome.test.js
+++ b/src/algorithms/string/palindrome/__test__/isPalindrome.test.js
@@ -1,15 +1,16 @@
-import isPalindrome from '../isPalindrome';
+import isPalindrome from "../isPalindrome";
 
-describe('palindromeCheck', () => {
-  it('should return whether or not the string is a palindrome', () => {
-    expect(isPalindrome('a')).toBe(true);
-    expect(isPalindrome('pop')).toBe(true);
-    expect(isPalindrome('deed')).toBe(true);
-    expect(isPalindrome('kayak')).toBe(true);
-    expect(isPalindrome('racecar')).toBe(true);
+describe("palindromeCheck", () => {
+  it("should return whether or not the string is a palindrome", () => {
+    expect(isPalindrome("a")).toBe(true);
+    expect(isPalindrome("pop")).toBe(true);
+    expect(isPalindrome("deed")).toBe(true);
+    expect(isPalindrome("kayak")).toBe(true);
+    expect(isPalindrome("racecar")).toBe(true);
 
-    expect(isPalindrome('rad')).toBe(false);
-    expect(isPalindrome('dodo')).toBe(false);
-    expect(isPalindrome('polo')).toBe(false);
+    expect(isPalindrome("rad")).toBe(false);
+    expect(isPalindrome("dodo")).toBe(false);
+    expect(isPalindrome("polo")).toBe(false);
   });
 });
+
diff --git a/src/algorithms/string/palindrome/isPalindrome.js b/src/algorithms/string/palindrome/isPalindrome.js
index 327fd6b..6e830b6 100644
--- a/src/algorithms/string/palindrome/isPalindrome.js
+++ b/src/algorithms/string/palindrome/isPalindrome.js
@@ -17,3 +17,4 @@ export default function isPalindrome(string) {
 
   return true;
 }
+
diff --git a/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js b/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js
index 343b5b4..ebde085 100644
--- a/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js
+++ b/src/algorithms/string/rabin-karp/__test__/rabinKarp.test.js
@@ -1,43 +1,47 @@
-import rabinKarp from '../rabinKarp';
+import rabinKarp from "../rabinKarp";
 
-describe('rabinKarp', () => {
-  it('should find substring in a string', () => {
-    expect(rabinKarp('', '')).toBe(0);
-    expect(rabinKarp('a', '')).toBe(0);
-    expect(rabinKarp('a', 'a')).toBe(0);
-    expect(rabinKarp('ab', 'b')).toBe(1);
-    expect(rabinKarp('abcbcglx', 'abca')).toBe(-1);
-    expect(rabinKarp('abcbcglx', 'bcgl')).toBe(3);
-    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toBe(15);
-    expect(rabinKarp('abcxabcdabxabcdabcdabcy', 'abcdabca')).toBe(-1);
-    expect(rabinKarp('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toBe(12);
-    expect(rabinKarp('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toBe(11);
-    expect(rabinKarp('^ !/\'#\'pp', ' !/\'#\'pp')).toBe(1);
+describe("rabinKarp", () => {
+  it("should find substring in a string", () => {
+    expect(rabinKarp("", "")).toBe(0);
+    expect(rabinKarp("a", "")).toBe(0);
+    expect(rabinKarp("a", "a")).toBe(0);
+    expect(rabinKarp("ab", "b")).toBe(1);
+    expect(rabinKarp("abcbcglx", "abca")).toBe(-1);
+    expect(rabinKarp("abcbcglx", "bcgl")).toBe(3);
+    expect(rabinKarp("abcxabcdabxabcdabcdabcy", "abcdabcy")).toBe(15);
+    expect(rabinKarp("abcxabcdabxabcdabcdabcy", "abcdabca")).toBe(-1);
+    expect(rabinKarp("abcxabcdabxaabcdabcabcdabcdabcy", "abcdabca")).toBe(12);
+    expect(rabinKarp("abcxabcdabxaabaabaaaabcdabcdabcy", "aabaabaaa")).toBe(11);
+    expect(rabinKarp("^ !/'#'pp", " !/'#'pp")).toBe(1);
   });
 
-  it('should work with bigger texts', () => {
-    const text = 'Lorem Ipsum is simply dummy text of the printing and '
-    + 'typesetting industry. Lorem Ipsum has been the industry\'s standard '
-    + 'dummy text ever since the 1500s, when an unknown printer took a '
-    + 'galley of type and scrambled it to make a type specimen book. It '
-    + 'has survived not only five centuries, but also the leap into '
-    + 'electronic typesetting, remaining essentially unchanged. It was '
-    + 'popularised in the 1960s with the release of Letraset sheets '
-    + 'containing Lorem Ipsum passages, and more recently with desktop'
-    + 'publishing software like Aldus PageMaker including versions of Lorem '
-    + 'Ipsum.';
+  it("should work with bigger texts", () => {
+    const text =
+      "Lorem Ipsum is simply dummy text of the printing and " +
+      "typesetting industry. Lorem Ipsum has been the industry's standard " +
+      "dummy text ever since the 1500s, when an unknown printer took a " +
+      "galley of type and scrambled it to make a type specimen book. It " +
+      "has survived not only five centuries, but also the leap into " +
+      "electronic typesetting, remaining essentially unchanged. It was " +
+      "popularised in the 1960s with the release of Letraset sheets " +
+      "containing Lorem Ipsum passages, and more recently with desktop" +
+      "publishing software like Aldus PageMaker including versions of Lorem " +
+      "Ipsum.";
 
-    expect(rabinKarp(text, 'Lorem')).toBe(0);
-    expect(rabinKarp(text, 'versions')).toBe(549);
-    expect(rabinKarp(text, 'versions of Lorem Ipsum.')).toBe(549);
-    expect(rabinKarp(text, 'versions of Lorem Ipsum:')).toBe(-1);
-    expect(rabinKarp(text, 'Lorem Ipsum passages, and more recently with')).toBe(446);
+    expect(rabinKarp(text, "Lorem")).toBe(0);
+    expect(rabinKarp(text, "versions")).toBe(549);
+    expect(rabinKarp(text, "versions of Lorem Ipsum.")).toBe(549);
+    expect(rabinKarp(text, "versions of Lorem Ipsum:")).toBe(-1);
+    expect(
+      rabinKarp(text, "Lorem Ipsum passages, and more recently with")
+    ).toBe(446);
   });
 
-  it('should work with UTF symbols', () => {
-    expect(rabinKarp('a\u{ffff}', '\u{ffff}')).toBe(1);
-    expect(rabinKarp('\u0000耀\u0000', '耀\u0000')).toBe(1);
+  it("should work with UTF symbols", () => {
+    expect(rabinKarp("a\u{ffff}", "\u{ffff}")).toBe(1);
+    expect(rabinKarp("\u0000耀\u0000", "耀\u0000")).toBe(1);
     // @TODO: Provide Unicode support.
     // expect(rabinKarp('a\u{20000}', '\u{20000}')).toBe(1);
   });
 });
+
diff --git a/src/algorithms/string/rabin-karp/rabinKarp.js b/src/algorithms/string/rabin-karp/rabinKarp.js
index 9084eb4..9abfda3 100644
--- a/src/algorithms/string/rabin-karp/rabinKarp.js
+++ b/src/algorithms/string/rabin-karp/rabinKarp.js
@@ -1,4 +1,4 @@
-import PolynomialHash from '../../cryptography/polynomial-hash/PolynomialHash';
+import PolynomialHash from "../../cryptography/polynomial-hash/PolynomialHash";
 
 /**
  * @param {string} text - Text that may contain the searchable word.
@@ -15,7 +15,11 @@ export default function rabinKarp(text, word) {
   let currentFrameHash = null;
 
   // Go through all substring of the text that may match.
-  for (let charIndex = 0; charIndex <= (text.length - word.length); charIndex += 1) {
+  for (
+    let charIndex = 0;
+    charIndex <= text.length - word.length;
+    charIndex += 1
+  ) {
     const currentFrame = text.substring(charIndex, charIndex + word.length);
 
     // Calculate the hash of current substring.
@@ -31,8 +35,8 @@ export default function rabinKarp(text, word) {
     // In case if hashes match let's make sure that substrings are equal.
     // In case of hash collision the strings may not be equal.
     if (
-      wordHash === currentFrameHash
-      && text.substr(charIndex, word.length) === word
+      wordHash === currentFrameHash &&
+      text.substr(charIndex, word.length) === word
     ) {
       return charIndex;
     }
@@ -40,3 +44,4 @@ export default function rabinKarp(text, word) {
 
   return -1;
 }
+
diff --git a/src/algorithms/string/regular-expression-matching/__test__/regularExpressionMatching.test.js b/src/algorithms/string/regular-expression-matching/__test__/regularExpressionMatching.test.js
index 882750f..733fa1c 100644
--- a/src/algorithms/string/regular-expression-matching/__test__/regularExpressionMatching.test.js
+++ b/src/algorithms/string/regular-expression-matching/__test__/regularExpressionMatching.test.js
@@ -1,34 +1,35 @@
-import regularExpressionMatching from '../regularExpressionMatching';
+import regularExpressionMatching from "../regularExpressionMatching";
 
-describe('regularExpressionMatching', () => {
-  it('should match regular expressions in a string', () => {
-    expect(regularExpressionMatching('', '')).toBe(true);
-    expect(regularExpressionMatching('a', 'a')).toBe(true);
-    expect(regularExpressionMatching('aa', 'aa')).toBe(true);
-    expect(regularExpressionMatching('aab', 'aab')).toBe(true);
-    expect(regularExpressionMatching('aab', 'aa.')).toBe(true);
-    expect(regularExpressionMatching('aab', '.a.')).toBe(true);
-    expect(regularExpressionMatching('aab', '...')).toBe(true);
-    expect(regularExpressionMatching('a', 'a*')).toBe(true);
-    expect(regularExpressionMatching('aaa', 'a*')).toBe(true);
-    expect(regularExpressionMatching('aaab', 'a*b')).toBe(true);
-    expect(regularExpressionMatching('aaabb', 'a*b*')).toBe(true);
-    expect(regularExpressionMatching('aaabb', 'a*b*c*')).toBe(true);
-    expect(regularExpressionMatching('', 'a*')).toBe(true);
-    expect(regularExpressionMatching('xaabyc', 'xa*b.c')).toBe(true);
-    expect(regularExpressionMatching('aab', 'c*a*b*')).toBe(true);
-    expect(regularExpressionMatching('mississippi', 'mis*is*.p*.')).toBe(true);
-    expect(regularExpressionMatching('ab', '.*')).toBe(true);
+describe("regularExpressionMatching", () => {
+  it("should match regular expressions in a string", () => {
+    expect(regularExpressionMatching("", "")).toBe(true);
+    expect(regularExpressionMatching("a", "a")).toBe(true);
+    expect(regularExpressionMatching("aa", "aa")).toBe(true);
+    expect(regularExpressionMatching("aab", "aab")).toBe(true);
+    expect(regularExpressionMatching("aab", "aa.")).toBe(true);
+    expect(regularExpressionMatching("aab", ".a.")).toBe(true);
+    expect(regularExpressionMatching("aab", "...")).toBe(true);
+    expect(regularExpressionMatching("a", "a*")).toBe(true);
+    expect(regularExpressionMatching("aaa", "a*")).toBe(true);
+    expect(regularExpressionMatching("aaab", "a*b")).toBe(true);
+    expect(regularExpressionMatching("aaabb", "a*b*")).toBe(true);
+    expect(regularExpressionMatching("aaabb", "a*b*c*")).toBe(true);
+    expect(regularExpressionMatching("", "a*")).toBe(true);
+    expect(regularExpressionMatching("xaabyc", "xa*b.c")).toBe(true);
+    expect(regularExpressionMatching("aab", "c*a*b*")).toBe(true);
+    expect(regularExpressionMatching("mississippi", "mis*is*.p*.")).toBe(true);
+    expect(regularExpressionMatching("ab", ".*")).toBe(true);
 
-    expect(regularExpressionMatching('', 'a')).toBe(false);
-    expect(regularExpressionMatching('a', '')).toBe(false);
-    expect(regularExpressionMatching('aab', 'aa')).toBe(false);
-    expect(regularExpressionMatching('aab', 'baa')).toBe(false);
-    expect(regularExpressionMatching('aabc', '...')).toBe(false);
-    expect(regularExpressionMatching('aaabbdd', 'a*b*c*')).toBe(false);
-    expect(regularExpressionMatching('mississippi', 'mis*is*p*.')).toBe(false);
-    expect(regularExpressionMatching('ab', 'a*')).toBe(false);
-    expect(regularExpressionMatching('abba', 'a*b*.c')).toBe(false);
-    expect(regularExpressionMatching('abba', '.*c')).toBe(false);
+    expect(regularExpressionMatching("", "a")).toBe(false);
+    expect(regularExpressionMatching("a", "")).toBe(false);
+    expect(regularExpressionMatching("aab", "aa")).toBe(false);
+    expect(regularExpressionMatching("aab", "baa")).toBe(false);
+    expect(regularExpressionMatching("aabc", "...")).toBe(false);
+    expect(regularExpressionMatching("aaabbdd", "a*b*c*")).toBe(false);
+    expect(regularExpressionMatching("mississippi", "mis*is*p*.")).toBe(false);
+    expect(regularExpressionMatching("ab", "a*")).toBe(false);
+    expect(regularExpressionMatching("abba", "a*b*.c")).toBe(false);
+    expect(regularExpressionMatching("abba", ".*c")).toBe(false);
   });
 });
+
diff --git a/src/algorithms/string/regular-expression-matching/regularExpressionMatching.js b/src/algorithms/string/regular-expression-matching/regularExpressionMatching.js
index 1935ba6..657b502 100644
--- a/src/algorithms/string/regular-expression-matching/regularExpressionMatching.js
+++ b/src/algorithms/string/regular-expression-matching/regularExpressionMatching.js
@@ -1,5 +1,5 @@
-const ZERO_OR_MORE_CHARS = '*';
-const ANY_CHAR = '.';
+const ZERO_OR_MORE_CHARS = "*";
+const ANY_CHAR = ".";
 
 /**
  * Dynamic programming approach.
@@ -10,23 +10,25 @@ const ANY_CHAR = '.';
  */
 export default function regularExpressionMatching(string, pattern) {
   /*
-    * Let's initiate dynamic programming matrix for this string and pattern.
-    * We will have pattern characters on top (as columns) and string characters
-    * will be placed to the left of the table (as rows).
-    *
-    * Example:
-    *
-    *     a * b . b
-    *   - - - - - -
-    * a - - - - - -
-    * a - - - - - -
-    * b - - - - - -
-    * y - - - - - -
-    * b - - - - - -
+   * Let's initiate dynamic programming matrix for this string and pattern.
+   * We will have pattern characters on top (as columns) and string characters
+   * will be placed to the left of the table (as rows).
+   *
+   * Example:
+   *
+   *     a * b . b
+   *   - - - - - -
+   * a - - - - - -
+   * a - - - - - -
+   * b - - - - - -
+   * y - - - - - -
+   * b - - - - - -
    */
-  const matchMatrix = Array(string.length + 1).fill(null).map(() => {
-    return Array(pattern.length + 1).fill(null);
-  });
+  const matchMatrix = Array(string.length + 1)
+    .fill(null)
+    .map(() => {
+      return Array(pattern.length + 1).fill(null);
+    });
 
   // Let's fill the top-left cell with true. This would mean that empty
   // string '' matches to empty pattern ''.
@@ -87,19 +89,17 @@ export default function regularExpressionMatching(string, pattern) {
         if (matchMatrix[rowIndex][columnIndex - 2] === true) {
           matchMatrix[rowIndex][columnIndex] = true;
         } else if (
-          (
-            pattern[patternIndex - 1] === string[stringIndex]
-            || pattern[patternIndex - 1] === ANY_CHAR
-          )
-          && matchMatrix[rowIndex - 1][columnIndex] === true
+          (pattern[patternIndex - 1] === string[stringIndex] ||
+            pattern[patternIndex - 1] === ANY_CHAR) &&
+          matchMatrix[rowIndex - 1][columnIndex] === true
         ) {
           matchMatrix[rowIndex][columnIndex] = true;
         } else {
           matchMatrix[rowIndex][columnIndex] = false;
         }
       } else if (
-        pattern[patternIndex] === string[stringIndex]
-        || pattern[patternIndex] === ANY_CHAR
+        pattern[patternIndex] === string[stringIndex] ||
+        pattern[patternIndex] === ANY_CHAR
       ) {
         /*
          * In case if current pattern char is the same as current string char
@@ -114,7 +114,8 @@ export default function regularExpressionMatching(string, pattern) {
          * a 1 -
          * b - 1
          */
-        matchMatrix[rowIndex][columnIndex] = matchMatrix[rowIndex - 1][columnIndex - 1];
+        matchMatrix[rowIndex][columnIndex] =
+          matchMatrix[rowIndex - 1][columnIndex - 1];
       } else {
         /*
          * In case if pattern char and string char are different we may
@@ -133,3 +134,4 @@ export default function regularExpressionMatching(string, pattern) {
 
   return matchMatrix[string.length][pattern.length];
 }
+
diff --git a/src/algorithms/string/z-algorithm/__test__/zAlgorithm.test.js b/src/algorithms/string/z-algorithm/__test__/zAlgorithm.test.js
index 9ef1e3f..f46ee6b 100644
--- a/src/algorithms/string/z-algorithm/__test__/zAlgorithm.test.js
+++ b/src/algorithms/string/z-algorithm/__test__/zAlgorithm.test.js
@@ -1,16 +1,21 @@
-import zAlgorithm from '../zAlgorithm';
+import zAlgorithm from "../zAlgorithm";
 
-describe('zAlgorithm', () => {
-  it('should find word positions in given text', () => {
-    expect(zAlgorithm('abcbcglx', 'abca')).toEqual([]);
-    expect(zAlgorithm('abca', 'abca')).toEqual([0]);
-    expect(zAlgorithm('abca', 'abcadfd')).toEqual([]);
-    expect(zAlgorithm('abcbcglabcx', 'abc')).toEqual([0, 7]);
-    expect(zAlgorithm('abcbcglx', 'bcgl')).toEqual([3]);
-    expect(zAlgorithm('abcbcglx', 'cglx')).toEqual([4]);
-    expect(zAlgorithm('abcxabcdabxabcdabcdabcy', 'abcdabcy')).toEqual([15]);
-    expect(zAlgorithm('abcxabcdabxabcdabcdabcy', 'abcdabca')).toEqual([]);
-    expect(zAlgorithm('abcxabcdabxaabcdabcabcdabcdabcy', 'abcdabca')).toEqual([12]);
-    expect(zAlgorithm('abcxabcdabxaabaabaaaabcdabcdabcy', 'aabaabaaa')).toEqual([11]);
+describe("zAlgorithm", () => {
+  it("should find word positions in given text", () => {
+    expect(zAlgorithm("abcbcglx", "abca")).toEqual([]);
+    expect(zAlgorithm("abca", "abca")).toEqual([0]);
+    expect(zAlgorithm("abca", "abcadfd")).toEqual([]);
+    expect(zAlgorithm("abcbcglabcx", "abc")).toEqual([0, 7]);
+    expect(zAlgorithm("abcbcglx", "bcgl")).toEqual([3]);
+    expect(zAlgorithm("abcbcglx", "cglx")).toEqual([4]);
+    expect(zAlgorithm("abcxabcdabxabcdabcdabcy", "abcdabcy")).toEqual([15]);
+    expect(zAlgorithm("abcxabcdabxabcdabcdabcy", "abcdabca")).toEqual([]);
+    expect(zAlgorithm("abcxabcdabxaabcdabcabcdabcdabcy", "abcdabca")).toEqual([
+      12,
+    ]);
+    expect(zAlgorithm("abcxabcdabxaabaabaaaabcdabcdabcy", "aabaabaaa")).toEqual(
+      [11]
+    );
   });
 });
+
diff --git a/src/algorithms/string/z-algorithm/zAlgorithm.js b/src/algorithms/string/z-algorithm/zAlgorithm.js
index 4b96a4f..df6e1ee 100644
--- a/src/algorithms/string/z-algorithm/zAlgorithm.js
+++ b/src/algorithms/string/z-algorithm/zAlgorithm.js
@@ -1,5 +1,5 @@
 // The string separator that is being used for "word" and "text" concatenation.
-const SEPARATOR = '$';
+const SEPARATOR = "$";
 
 /**
  * @param {string} zString
@@ -40,8 +40,8 @@ function buildZArray(zString) {
       // more characters that are equal to the ones in the prefix we will expand
       // right Z box boundary by 3.
       while (
-        zBoxRightIndex < zString.length
-        && zString[zBoxRightIndex - zBoxLeftIndex] === zString[zBoxRightIndex]
+        zBoxRightIndex < zString.length &&
+        zString[zBoxRightIndex - zBoxLeftIndex] === zString[zBoxRightIndex]
       ) {
         // Expanding Z box right boundary.
         zBoxRightIndex += 1;
@@ -65,7 +65,7 @@ function buildZArray(zString) {
       // Check if the value that has been already calculated before
       // leaves us inside of Z box or it goes beyond the checkbox
       // right boundary.
-      if (zArray[zBoxShift] < (zBoxRightIndex - charIndex) + 1) {
+      if (zArray[zBoxShift] < zBoxRightIndex - charIndex + 1) {
         // If calculated value don't force us to go outside Z box
         // then we're safe and we may simply use previously calculated value.
         zArray[charIndex] = zArray[zBoxShift];
@@ -81,8 +81,8 @@ function buildZArray(zString) {
         // And start comparing characters one by one as we normally do for the case
         // when we are outside of checkbox.
         while (
-          zBoxRightIndex < zString.length
-          && zString[zBoxRightIndex - zBoxLeftIndex] === zString[zBoxRightIndex]
+          zBoxRightIndex < zString.length &&
+          zString[zBoxRightIndex - zBoxLeftIndex] === zString[zBoxRightIndex]
         ) {
           zBoxRightIndex += 1;
         }
@@ -130,3 +130,4 @@ export default function zAlgorithm(text, word) {
   // Return the list of word positions.
   return wordPositions;
 }
+
diff --git a/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js b/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js
index 2bf653a..185fdcc 100644
--- a/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js
+++ b/src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js
@@ -1,22 +1,22 @@
-import BinaryTreeNode from '../../../../data-structures/tree/BinaryTreeNode';
-import breadthFirstSearch from '../breadthFirstSearch';
-
-describe('breadthFirstSearch', () => {
-  it('should perform BFS operation on tree', () => {
-    const nodeA = new BinaryTreeNode('A');
-    const nodeB = new BinaryTreeNode('B');
-    const nodeC = new BinaryTreeNode('C');
-    const nodeD = new BinaryTreeNode('D');
-    const nodeE = new BinaryTreeNode('E');
-    const nodeF = new BinaryTreeNode('F');
-    const nodeG = new BinaryTreeNode('G');
+import BinaryTreeNode from "../../../../data-structures/tree/BinaryTreeNode";
+import breadthFirstSearch from "../breadthFirstSearch";
+
+describe("breadthFirstSearch", () => {
+  it("should perform BFS operation on tree", () => {
+    const nodeA = new BinaryTreeNode("A");
+    const nodeB = new BinaryTreeNode("B");
+    const nodeC = new BinaryTreeNode("C");
+    const nodeD = new BinaryTreeNode("D");
+    const nodeE = new BinaryTreeNode("E");
+    const nodeF = new BinaryTreeNode("F");
+    const nodeG = new BinaryTreeNode("G");
 
     nodeA.setLeft(nodeB).setRight(nodeC);
     nodeB.setLeft(nodeD).setRight(nodeE);
     nodeC.setLeft(nodeF).setRight(nodeG);
 
     // In-order traversing.
-    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');
+    expect(nodeA.toString()).toBe("D,B,E,A,F,C,G");
 
     const enterNodeCallback = jest.fn();
     const leaveNodeCallback = jest.fn();
@@ -34,39 +34,39 @@ describe('breadthFirstSearch', () => {
     expect(leaveNodeCallback).toHaveBeenCalledTimes(7);
 
     // Check node entering.
-    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
-    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('B');
-    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('C');
-    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('D');
-    expect(enterNodeCallback.mock.calls[4][0].value).toEqual('E');
-    expect(enterNodeCallback.mock.calls[5][0].value).toEqual('F');
-    expect(enterNodeCallback.mock.calls[6][0].value).toEqual('G');
+    expect(enterNodeCallback.mock.calls[0][0].value).toEqual("A");
+    expect(enterNodeCallback.mock.calls[1][0].value).toEqual("B");
+    expect(enterNodeCallback.mock.calls[2][0].value).toEqual("C");
+    expect(enterNodeCallback.mock.calls[3][0].value).toEqual("D");
+    expect(enterNodeCallback.mock.calls[4][0].value).toEqual("E");
+    expect(enterNodeCallback.mock.calls[5][0].value).toEqual("F");
+    expect(enterNodeCallback.mock.calls[6][0].value).toEqual("G");
 
     // Check node leaving.
-    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('A');
-    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('B');
-    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('C');
-    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('D');
-    expect(leaveNodeCallback.mock.calls[4][0].value).toEqual('E');
-    expect(leaveNodeCallback.mock.calls[5][0].value).toEqual('F');
-    expect(leaveNodeCallback.mock.calls[6][0].value).toEqual('G');
+    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual("A");
+    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual("B");
+    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual("C");
+    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual("D");
+    expect(leaveNodeCallback.mock.calls[4][0].value).toEqual("E");
+    expect(leaveNodeCallback.mock.calls[5][0].value).toEqual("F");
+    expect(leaveNodeCallback.mock.calls[6][0].value).toEqual("G");
   });
 
-  it('allow users to redefine node visiting logic', () => {
-    const nodeA = new BinaryTreeNode('A');
-    const nodeB = new BinaryTreeNode('B');
-    const nodeC = new BinaryTreeNode('C');
-    const nodeD = new BinaryTreeNode('D');
-    const nodeE = new BinaryTreeNode('E');
-    const nodeF = new BinaryTreeNode('F');
-    const nodeG = new BinaryTreeNode('G');
+  it("allow users to redefine node visiting logic", () => {
+    const nodeA = new BinaryTreeNode("A");
+    const nodeB = new BinaryTreeNode("B");
+    const nodeC = new BinaryTreeNode("C");
+    const nodeD = new BinaryTreeNode("D");
+    const nodeE = new BinaryTreeNode("E");
+    const nodeF = new BinaryTreeNode("F");
+    const nodeG = new BinaryTreeNode("G");
 
     nodeA.setLeft(nodeB).setRight(nodeC);
     nodeB.setLeft(nodeD).setRight(nodeE);
     nodeC.setLeft(nodeF).setRight(nodeG);
 
     // In-order traversing.
-    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');
+    expect(nodeA.toString()).toBe("D,B,E,A,F,C,G");
 
     const enterNodeCallback = jest.fn();
     const leaveNodeCallback = jest.fn();
@@ -78,7 +78,7 @@ describe('breadthFirstSearch', () => {
     breadthFirstSearch(nodeA, {
       allowTraversal: (node, child) => {
         // Forbid traversing left half of the tree.
-        return child.value !== 'B';
+        return child.value !== "B";
       },
       enterNode: enterNodeCallback,
       leaveNode: leaveNodeCallback,
@@ -88,15 +88,16 @@ describe('breadthFirstSearch', () => {
     expect(leaveNodeCallback).toHaveBeenCalledTimes(4);
 
     // Check node entering.
-    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
-    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('C');
-    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('F');
-    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('G');
+    expect(enterNodeCallback.mock.calls[0][0].value).toEqual("A");
+    expect(enterNodeCallback.mock.calls[1][0].value).toEqual("C");
+    expect(enterNodeCallback.mock.calls[2][0].value).toEqual("F");
+    expect(enterNodeCallback.mock.calls[3][0].value).toEqual("G");
 
     // Check node leaving.
-    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('A');
-    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('C');
-    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('F');
-    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('G');
+    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual("A");
+    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual("C");
+    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual("F");
+    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual("G");
   });
 });
+
diff --git a/src/algorithms/tree/breadth-first-search/breadthFirstSearch.js b/src/algorithms/tree/breadth-first-search/breadthFirstSearch.js
index e1c7b70..d61c48e 100644
--- a/src/algorithms/tree/breadth-first-search/breadthFirstSearch.js
+++ b/src/algorithms/tree/breadth-first-search/breadthFirstSearch.js
@@ -1,4 +1,4 @@
-import Queue from '../../../data-structures/queue/Queue';
+import Queue from "../../../data-structures/queue/Queue";
 
 /**
  * @typedef {Object} Callbacks
@@ -12,13 +12,16 @@ import Queue from '../../../data-structures/queue/Queue';
  * @param {Callbacks} [callbacks]
  * @returns {Callbacks}
  */
-function initCallbacks(callbacks = {}) {
+function initCallbacks() {
+  let callbacks =
+    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
   const initiatedCallback = callbacks;
 
   const stubCallback = () => {};
   const defaultAllowTraversal = () => true;
 
-  initiatedCallback.allowTraversal = callbacks.allowTraversal || defaultAllowTraversal;
+  initiatedCallback.allowTraversal =
+    callbacks.allowTraversal || defaultAllowTraversal;
   initiatedCallback.enterNode = callbacks.enterNode || stubCallback;
   initiatedCallback.leaveNode = callbacks.leaveNode || stubCallback;
 
@@ -44,15 +47,22 @@ export default function breadthFirstSearch(rootNode, originalCallbacks) {
     // Add all children to the queue for future traversals.
 
     // Traverse left branch.
-    if (currentNode.left && callbacks.allowTraversal(currentNode, currentNode.left)) {
+    if (
+      currentNode.left &&
+      callbacks.allowTraversal(currentNode, currentNode.left)
+    ) {
       nodeQueue.enqueue(currentNode.left);
     }
 
     // Traverse right branch.
-    if (currentNode.right && callbacks.allowTraversal(currentNode, currentNode.right)) {
+    if (
+      currentNode.right &&
+      callbacks.allowTraversal(currentNode, currentNode.right)
+    ) {
       nodeQueue.enqueue(currentNode.right);
     }
 
     callbacks.leaveNode(currentNode);
   }
 }
+
diff --git a/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js b/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js
index 732b7d5..1412227 100644
--- a/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js
+++ b/src/algorithms/tree/depth-first-search/__test__/depthFirstSearch.test.js
@@ -1,22 +1,22 @@
-import BinaryTreeNode from '../../../../data-structures/tree/BinaryTreeNode';
-import depthFirstSearch from '../depthFirstSearch';
-
-describe('depthFirstSearch', () => {
-  it('should perform DFS operation on tree', () => {
-    const nodeA = new BinaryTreeNode('A');
-    const nodeB = new BinaryTreeNode('B');
-    const nodeC = new BinaryTreeNode('C');
-    const nodeD = new BinaryTreeNode('D');
-    const nodeE = new BinaryTreeNode('E');
-    const nodeF = new BinaryTreeNode('F');
-    const nodeG = new BinaryTreeNode('G');
+import BinaryTreeNode from "../../../../data-structures/tree/BinaryTreeNode";
+import depthFirstSearch from "../depthFirstSearch";
+
+describe("depthFirstSearch", () => {
+  it("should perform DFS operation on tree", () => {
+    const nodeA = new BinaryTreeNode("A");
+    const nodeB = new BinaryTreeNode("B");
+    const nodeC = new BinaryTreeNode("C");
+    const nodeD = new BinaryTreeNode("D");
+    const nodeE = new BinaryTreeNode("E");
+    const nodeF = new BinaryTreeNode("F");
+    const nodeG = new BinaryTreeNode("G");
 
     nodeA.setLeft(nodeB).setRight(nodeC);
     nodeB.setLeft(nodeD).setRight(nodeE);
     nodeC.setLeft(nodeF).setRight(nodeG);
 
     // In-order traversing.
-    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');
+    expect(nodeA.toString()).toBe("D,B,E,A,F,C,G");
 
     const enterNodeCallback = jest.fn();
     const leaveNodeCallback = jest.fn();
@@ -34,39 +34,39 @@ describe('depthFirstSearch', () => {
     expect(leaveNodeCallback).toHaveBeenCalledTimes(7);
 
     // Check node entering.
-    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
-    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('B');
-    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('D');
-    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('E');
-    expect(enterNodeCallback.mock.calls[4][0].value).toEqual('C');
-    expect(enterNodeCallback.mock.calls[5][0].value).toEqual('F');
-    expect(enterNodeCallback.mock.calls[6][0].value).toEqual('G');
+    expect(enterNodeCallback.mock.calls[0][0].value).toEqual("A");
+    expect(enterNodeCallback.mock.calls[1][0].value).toEqual("B");
+    expect(enterNodeCallback.mock.calls[2][0].value).toEqual("D");
+    expect(enterNodeCallback.mock.calls[3][0].value).toEqual("E");
+    expect(enterNodeCallback.mock.calls[4][0].value).toEqual("C");
+    expect(enterNodeCallback.mock.calls[5][0].value).toEqual("F");
+    expect(enterNodeCallback.mock.calls[6][0].value).toEqual("G");
 
     // Check node leaving.
-    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('D');
-    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('E');
-    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('B');
-    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('F');
-    expect(leaveNodeCallback.mock.calls[4][0].value).toEqual('G');
-    expect(leaveNodeCallback.mock.calls[5][0].value).toEqual('C');
-    expect(leaveNodeCallback.mock.calls[6][0].value).toEqual('A');
+    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual("D");
+    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual("E");
+    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual("B");
+    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual("F");
+    expect(leaveNodeCallback.mock.calls[4][0].value).toEqual("G");
+    expect(leaveNodeCallback.mock.calls[5][0].value).toEqual("C");
+    expect(leaveNodeCallback.mock.calls[6][0].value).toEqual("A");
   });
 
-  it('allow users to redefine node visiting logic', () => {
-    const nodeA = new BinaryTreeNode('A');
-    const nodeB = new BinaryTreeNode('B');
-    const nodeC = new BinaryTreeNode('C');
-    const nodeD = new BinaryTreeNode('D');
-    const nodeE = new BinaryTreeNode('E');
-    const nodeF = new BinaryTreeNode('F');
-    const nodeG = new BinaryTreeNode('G');
+  it("allow users to redefine node visiting logic", () => {
+    const nodeA = new BinaryTreeNode("A");
+    const nodeB = new BinaryTreeNode("B");
+    const nodeC = new BinaryTreeNode("C");
+    const nodeD = new BinaryTreeNode("D");
+    const nodeE = new BinaryTreeNode("E");
+    const nodeF = new BinaryTreeNode("F");
+    const nodeG = new BinaryTreeNode("G");
 
     nodeA.setLeft(nodeB).setRight(nodeC);
     nodeB.setLeft(nodeD).setRight(nodeE);
     nodeC.setLeft(nodeF).setRight(nodeG);
 
     // In-order traversing.
-    expect(nodeA.toString()).toBe('D,B,E,A,F,C,G');
+    expect(nodeA.toString()).toBe("D,B,E,A,F,C,G");
 
     const enterNodeCallback = jest.fn();
     const leaveNodeCallback = jest.fn();
@@ -78,7 +78,7 @@ describe('depthFirstSearch', () => {
     depthFirstSearch(nodeA, {
       allowTraversal: (node, child) => {
         // Forbid traversing left part of the tree.
-        return child.value !== 'B';
+        return child.value !== "B";
       },
       enterNode: enterNodeCallback,
       leaveNode: leaveNodeCallback,
@@ -88,15 +88,16 @@ describe('depthFirstSearch', () => {
     expect(leaveNodeCallback).toHaveBeenCalledTimes(4);
 
     // Check node entering.
-    expect(enterNodeCallback.mock.calls[0][0].value).toEqual('A');
-    expect(enterNodeCallback.mock.calls[1][0].value).toEqual('C');
-    expect(enterNodeCallback.mock.calls[2][0].value).toEqual('F');
-    expect(enterNodeCallback.mock.calls[3][0].value).toEqual('G');
+    expect(enterNodeCallback.mock.calls[0][0].value).toEqual("A");
+    expect(enterNodeCallback.mock.calls[1][0].value).toEqual("C");
+    expect(enterNodeCallback.mock.calls[2][0].value).toEqual("F");
+    expect(enterNodeCallback.mock.calls[3][0].value).toEqual("G");
 
     // Check node leaving.
-    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual('F');
-    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual('G');
-    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual('C');
-    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual('A');
+    expect(leaveNodeCallback.mock.calls[0][0].value).toEqual("F");
+    expect(leaveNodeCallback.mock.calls[1][0].value).toEqual("G");
+    expect(leaveNodeCallback.mock.calls[2][0].value).toEqual("C");
+    expect(leaveNodeCallback.mock.calls[3][0].value).toEqual("A");
   });
 });
+
diff --git a/src/algorithms/tree/depth-first-search/depthFirstSearch.js b/src/algorithms/tree/depth-first-search/depthFirstSearch.js
index fade444..9eef503 100644
--- a/src/algorithms/tree/depth-first-search/depthFirstSearch.js
+++ b/src/algorithms/tree/depth-first-search/depthFirstSearch.js
@@ -15,7 +15,9 @@
  * @param {TraversalCallbacks} [callbacks] - The object that contains traversal callbacks.
  * @returns {TraversalCallbacks} - Traversal callbacks extended with defaults callbacks.
  */
-function initCallbacks(callbacks = {}) {
+function initCallbacks() {
+  let callbacks =
+    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
   // Init empty callbacks object.
   const initiatedCallbacks = {};
 
@@ -26,7 +28,8 @@ function initCallbacks(callbacks = {}) {
   const defaultAllowTraversalCallback = () => true;
 
   // Copy original callbacks to our initiatedCallbacks object or use default callbacks instead.
-  initiatedCallbacks.allowTraversal = callbacks.allowTraversal || defaultAllowTraversalCallback;
+  initiatedCallbacks.allowTraversal =
+    callbacks.allowTraversal || defaultAllowTraversalCallback;
   initiatedCallbacks.enterNode = callbacks.enterNode || stubCallback;
   initiatedCallbacks.leaveNode = callbacks.leaveNode || stubCallback;
 
@@ -74,3 +77,4 @@ export default function depthFirstSearch(rootNode, callbacks) {
   // Now, when we have all necessary callbacks we may proceed to recursive traversal.
   depthFirstSearchRecursive(rootNode, processedCallbacks);
 }
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js
index 40c1557..d05bb77 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/accumulatorBestTimeToBuySellStocks.test.js
@@ -1,7 +1,7 @@
-import accumulatorBestTimeToBuySellStocks from '../accumulatorBestTimeToBuySellStocks';
+import accumulatorBestTimeToBuySellStocks from "../accumulatorBestTimeToBuySellStocks";
 
-describe('accumulatorBestTimeToBuySellStocks', () => {
-  it('should find the best time to buy and sell stocks', () => {
+describe("accumulatorBestTimeToBuySellStocks", () => {
+  it("should find the best time to buy and sell stocks", () => {
     let visit;
 
     expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);
@@ -23,26 +23,37 @@ describe('accumulatorBestTimeToBuySellStocks', () => {
     expect(visit).toHaveBeenCalledTimes(3);
 
     visit = jest.fn();
-    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
+    expect(
+      accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)
+    ).toEqual(25);
     expect(visit).toHaveBeenCalledTimes(6);
 
     visit = jest.fn();
-    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
+    expect(
+      accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)
+    ).toEqual(7);
     expect(visit).toHaveBeenCalledTimes(6);
 
     visit = jest.fn();
-    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
+    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(
+      4
+    );
     expect(visit).toHaveBeenCalledTimes(5);
 
     visit = jest.fn();
-    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
+    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(
+      0
+    );
     expect(visit).toHaveBeenCalledTimes(5);
 
     visit = jest.fn();
-    expect(accumulatorBestTimeToBuySellStocks(
-      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
-      visit,
-    )).toEqual(19);
+    expect(
+      accumulatorBestTimeToBuySellStocks(
+        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
+        visit
+      )
+    ).toEqual(19);
     expect(visit).toHaveBeenCalledTimes(20);
   });
 });
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js
index 5904ee5..9dbc432 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dpBestTimeToBuySellStocks.test.js
@@ -1,7 +1,7 @@
-import dpBestTimeToBuySellStocks from '../dpBestTimeToBuySellStocks';
+import dpBestTimeToBuySellStocks from "../dpBestTimeToBuySellStocks";
 
-describe('dpBestTimeToBuySellStocks', () => {
-  it('should find the best time to buy and sell stocks', () => {
+describe("dpBestTimeToBuySellStocks", () => {
+  it("should find the best time to buy and sell stocks", () => {
     let visit;
 
     expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);
@@ -23,7 +23,9 @@ describe('dpBestTimeToBuySellStocks', () => {
     expect(visit).toHaveBeenCalledTimes(3);
 
     visit = jest.fn();
-    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
+    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(
+      25
+    );
     expect(visit).toHaveBeenCalledTimes(6);
 
     visit = jest.fn();
@@ -39,10 +41,13 @@ describe('dpBestTimeToBuySellStocks', () => {
     expect(visit).toHaveBeenCalledTimes(5);
 
     visit = jest.fn();
-    expect(dpBestTimeToBuySellStocks(
-      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
-      visit,
-    )).toEqual(19);
+    expect(
+      dpBestTimeToBuySellStocks(
+        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
+        visit
+      )
+    ).toEqual(19);
     expect(visit).toHaveBeenCalledTimes(20);
   });
 });
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js
index f4fe9ad..01a4205 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/dqBestTimeToBuySellStocks.test.js
@@ -1,7 +1,7 @@
-import dqBestTimeToBuySellStocks from '../dqBestTimeToBuySellStocks';
+import dqBestTimeToBuySellStocks from "../dqBestTimeToBuySellStocks";
 
-describe('dqBestTimeToBuySellStocks', () => {
-  it('should find the best time to buy and sell stocks', () => {
+describe("dqBestTimeToBuySellStocks", () => {
+  it("should find the best time to buy and sell stocks", () => {
     let visit;
 
     expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);
@@ -23,7 +23,9 @@ describe('dqBestTimeToBuySellStocks', () => {
     expect(visit).toHaveBeenCalledTimes(15);
 
     visit = jest.fn();
-    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
+    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(
+      25
+    );
     expect(visit).toHaveBeenCalledTimes(127);
 
     visit = jest.fn();
@@ -39,10 +41,13 @@ describe('dqBestTimeToBuySellStocks', () => {
     expect(visit).toHaveBeenCalledTimes(63);
 
     visit = jest.fn();
-    expect(dqBestTimeToBuySellStocks(
-      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
-      visit,
-    )).toEqual(19);
+    expect(
+      dqBestTimeToBuySellStocks(
+        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
+        visit
+      )
+    ).toEqual(19);
     expect(visit).toHaveBeenCalledTimes(2097151);
   });
 });
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js
index 4eeadf6..5cbba2f 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/__tests__/peakvalleyBestTimeToBuySellStocks.test.js
@@ -1,7 +1,7 @@
-import peakvalleyBestTimeToBuySellStocks from '../peakvalleyBestTimeToBuySellStocks';
+import peakvalleyBestTimeToBuySellStocks from "../peakvalleyBestTimeToBuySellStocks";
 
-describe('peakvalleyBestTimeToBuySellStocks', () => {
-  it('should find the best time to buy and sell stocks', () => {
+describe("peakvalleyBestTimeToBuySellStocks", () => {
+  it("should find the best time to buy and sell stocks", () => {
     let visit;
 
     expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);
@@ -23,26 +23,37 @@ describe('peakvalleyBestTimeToBuySellStocks', () => {
     expect(visit).toHaveBeenCalledTimes(3);
 
     visit = jest.fn();
-    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);
+    expect(
+      peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)
+    ).toEqual(25);
     expect(visit).toHaveBeenCalledTimes(6);
 
     visit = jest.fn();
-    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);
+    expect(
+      peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)
+    ).toEqual(7);
     expect(visit).toHaveBeenCalledTimes(6);
 
     visit = jest.fn();
-    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);
+    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(
+      4
+    );
     expect(visit).toHaveBeenCalledTimes(5);
 
     visit = jest.fn();
-    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);
+    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(
+      0
+    );
     expect(visit).toHaveBeenCalledTimes(5);
 
     visit = jest.fn();
-    expect(peakvalleyBestTimeToBuySellStocks(
-      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
-      visit,
-    )).toEqual(19);
+    expect(
+      peakvalleyBestTimeToBuySellStocks(
+        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
+        visit
+      )
+    ).toEqual(19);
     expect(visit).toHaveBeenCalledTimes(20);
   });
 });
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/accumulatorBestTimeToBuySellStocks.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/accumulatorBestTimeToBuySellStocks.js
index 9e244c8..bbc150a 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/accumulatorBestTimeToBuySellStocks.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/accumulatorBestTimeToBuySellStocks.js
@@ -6,7 +6,11 @@
  * @param {function(): void} visit - Visiting callback to calculate the number of iterations.
  * @return {number} - The maximum profit
  */
-const accumulatorBestTimeToBuySellStocks = (prices, visit = () => {}) => {
+const accumulatorBestTimeToBuySellStocks = function (prices) {
+  let visit =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : () => {};
   visit();
   let profit = 0;
   for (let day = 1; day < prices.length; day += 1) {
@@ -18,3 +22,4 @@ const accumulatorBestTimeToBuySellStocks = (prices, visit = () => {}) => {
 };
 
 export default accumulatorBestTimeToBuySellStocks;
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dpBestTimeToBuySellStocks.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dpBestTimeToBuySellStocks.js
index 8bf1645..ab1e273 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dpBestTimeToBuySellStocks.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dpBestTimeToBuySellStocks.js
@@ -6,7 +6,11 @@
  * @param {function(): void} visit - Visiting callback to calculate the number of iterations.
  * @return {number} - The maximum profit
  */
-const dpBestTimeToBuySellStocks = (prices, visit = () => {}) => {
+const dpBestTimeToBuySellStocks = function (prices) {
+  let visit =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : () => {};
   visit();
   let lastBuy = -prices[0];
   let lastSold = 0;
@@ -23,3 +27,4 @@ const dpBestTimeToBuySellStocks = (prices, visit = () => {}) => {
 };
 
 export default dpBestTimeToBuySellStocks;
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dqBestTimeToBuySellStocks.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dqBestTimeToBuySellStocks.js
index 188ad9f..1e71b02 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dqBestTimeToBuySellStocks.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/dqBestTimeToBuySellStocks.js
@@ -6,7 +6,11 @@
  * @param {function(): void} visit - Visiting callback to calculate the number of iterations.
  * @return {number} - The maximum profit
  */
-const dqBestTimeToBuySellStocks = (prices, visit = () => {}) => {
+const dqBestTimeToBuySellStocks = function (prices) {
+  let visit =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : () => {};
   /**
    * Recursive implementation of the main function. It is hidden from the users.
    *
@@ -29,7 +33,7 @@ const dqBestTimeToBuySellStocks = (prices, visit = () => {}) => {
       // Option 1: Don't do anything.
       recursiveBuyerSeller(buy, day + 1),
       // Option 2: Sell or Buy at the current price.
-      operationSign * prices[day] + recursiveBuyerSeller(!buy, day + 1),
+      operationSign * prices[day] + recursiveBuyerSeller(!buy, day + 1)
     );
   };
 
@@ -40,3 +44,4 @@ const dqBestTimeToBuySellStocks = (prices, visit = () => {}) => {
 };
 
 export default dqBestTimeToBuySellStocks;
+
diff --git a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/peakvalleyBestTimeToBuySellStocks.js b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/peakvalleyBestTimeToBuySellStocks.js
index 44e8bcb..89c2d11 100644
--- a/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/peakvalleyBestTimeToBuySellStocks.js
+++ b/src/algorithms/uncategorized/best-time-to-buy-sell-stocks/peakvalleyBestTimeToBuySellStocks.js
@@ -6,7 +6,11 @@
  * @param {function(): void} visit - Visiting callback to calculate the number of iterations.
  * @return {number} - The maximum profit
  */
-const peakvalleyBestTimeToBuySellStocks = (prices, visit = () => {}) => {
+const peakvalleyBestTimeToBuySellStocks = function (prices) {
+  let visit =
+    arguments.length > 1 && arguments[1] !== undefined
+      ? arguments[1]
+      : () => {};
   visit();
   let profit = 0;
   let low = prices[0];
@@ -33,3 +37,4 @@ const peakvalleyBestTimeToBuySellStocks = (prices, visit = () => {}) => {
 };
 
 export default peakvalleyBestTimeToBuySellStocks;
+
diff --git a/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js b/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js
index d720d18..b081651 100644
--- a/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js
+++ b/src/algorithms/uncategorized/hanoi-tower/__test__/hanoiTower.test.js
@@ -1,8 +1,8 @@
-import hanoiTower from '../hanoiTower';
-import Stack from '../../../../data-structures/stack/Stack';
+import hanoiTower from "../hanoiTower";
+import Stack from "../../../../data-structures/stack/Stack";
 
-describe('hanoiTower', () => {
-  it('should solve tower of hanoi puzzle with 2 discs', () => {
+describe("hanoiTower", () => {
+  it("should solve tower of hanoi puzzle with 2 discs", () => {
     const moveCallback = jest.fn();
     const numberOfDiscs = 2;
 
@@ -18,7 +18,7 @@ describe('hanoiTower', () => {
       toPole,
     });
 
-    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);
+    expect(moveCallback).toHaveBeenCalledTimes(2 ** numberOfDiscs - 1);
 
     expect(fromPole.toArray()).toEqual([]);
     expect(toPole.toArray()).toEqual([1, 2]);
@@ -36,7 +36,7 @@ describe('hanoiTower', () => {
     expect(moveCallback.mock.calls[2][2]).toEqual([2]);
   });
 
-  it('should solve tower of hanoi puzzle with 3 discs', () => {
+  it("should solve tower of hanoi puzzle with 3 discs", () => {
     const moveCallback = jest.fn();
     const numberOfDiscs = 3;
 
@@ -45,10 +45,10 @@ describe('hanoiTower', () => {
       moveCallback,
     });
 
-    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);
+    expect(moveCallback).toHaveBeenCalledTimes(2 ** numberOfDiscs - 1);
   });
 
-  it('should solve tower of hanoi puzzle with 6 discs', () => {
+  it("should solve tower of hanoi puzzle with 6 discs", () => {
     const moveCallback = jest.fn();
     const numberOfDiscs = 6;
 
@@ -57,6 +57,7 @@ describe('hanoiTower', () => {
       moveCallback,
     });
 
-    expect(moveCallback).toHaveBeenCalledTimes((2 ** numberOfDiscs) - 1);
+    expect(moveCallback).toHaveBeenCalledTimes(2 ** numberOfDiscs - 1);
   });
 });
+
diff --git a/src/algorithms/uncategorized/hanoi-tower/hanoiTower.js b/src/algorithms/uncategorized/hanoi-tower/hanoiTower.js
index 86d7888..e7aca15 100644
--- a/src/algorithms/uncategorized/hanoi-tower/hanoiTower.js
+++ b/src/algorithms/uncategorized/hanoi-tower/hanoiTower.js
@@ -1,4 +1,4 @@
-import Stack from '../../../data-structures/stack/Stack';
+import Stack from "../../../data-structures/stack/Stack";
 
 /**
  * @param {number} numberOfDiscs
@@ -7,13 +7,12 @@ import Stack from '../../../data-structures/stack/Stack';
  * @param {Stack} toPole
  * @param {function(disc: number, fromPole: number[], toPole: number[])} moveCallback
  */
-function hanoiTowerRecursive({
-  numberOfDiscs,
-  fromPole,
-  withPole,
-  toPole,
-  moveCallback,
-}) {
+function hanoiTowerRecursive(_ref) {
+  let numberOfDiscs = _ref.numberOfDiscs,
+    fromPole = _ref.fromPole,
+    withPole = _ref.withPole,
+    toPole = _ref.toPole,
+    moveCallback = _ref.moveCallback;
   if (numberOfDiscs === 1) {
     // Base case with just one disc.
     moveCallback(fromPole.peek(), fromPole.toArray(), toPole.toArray());
@@ -58,13 +57,15 @@ function hanoiTowerRecursive({
  * @param {Stack} [withPole]
  * @param {Stack} [toPole]
  */
-export default function hanoiTower({
-  numberOfDiscs,
-  moveCallback,
-  fromPole = new Stack(),
-  withPole = new Stack(),
-  toPole = new Stack(),
-}) {
+export default function hanoiTower(_ref2) {
+  let numberOfDiscs = _ref2.numberOfDiscs,
+    moveCallback = _ref2.moveCallback,
+    _ref2$fromPole = _ref2.fromPole,
+    fromPole = _ref2$fromPole === void 0 ? new Stack() : _ref2$fromPole,
+    _ref2$withPole = _ref2.withPole,
+    withPole = _ref2$withPole === void 0 ? new Stack() : _ref2$withPole,
+    _ref2$toPole = _ref2.toPole,
+    toPole = _ref2$toPole === void 0 ? new Stack() : _ref2$toPole;
   // Each of three poles of Tower of Hanoi puzzle is represented as a stack
   // that might contain elements (discs). Each disc is represented as a number.
   // Larger discs have bigger number equivalent.
@@ -81,4 +82,7 @@ export default function hanoiTower({
     toPole,
     moveCallback,
   });
+
+  return toPole;
 }
+
diff --git a/src/algorithms/uncategorized/jump-game/__test__/backtrackingJumpGame.test.js b/src/algorithms/uncategorized/jump-game/__test__/backtrackingJumpGame.test.js
index 0609279..d25b038 100644
--- a/src/algorithms/uncategorized/jump-game/__test__/backtrackingJumpGame.test.js
+++ b/src/algorithms/uncategorized/jump-game/__test__/backtrackingJumpGame.test.js
@@ -1,7 +1,7 @@
-import backtrackingJumpGame from '../backtrackingJumpGame';
+import backtrackingJumpGame from "../backtrackingJumpGame";
 
-describe('backtrackingJumpGame', () => {
-  it('should solve Jump Game problem in backtracking manner', () => {
+describe("backtrackingJumpGame", () => {
+  it("should solve Jump Game problem in backtracking manner", () => {
     expect(backtrackingJumpGame([1, 0])).toBe(true);
     expect(backtrackingJumpGame([100, 0])).toBe(true);
     expect(backtrackingJumpGame([2, 3, 1, 1, 4])).toBe(true);
@@ -15,3 +15,4 @@ describe('backtrackingJumpGame', () => {
     expect(backtrackingJumpGame([5, 4, 3, 2, 1, 0, 0])).toBe(false);
   });
 });
+
diff --git a/src/algorithms/uncategorized/jump-game/__test__/dpBottomUpJumpGame.test.js b/src/algorithms/uncategorized/jump-game/__test__/dpBottomUpJumpGame.test.js
index 1cdac33..c7fe71c 100644
--- a/src/algorithms/uncategorized/jump-game/__test__/dpBottomUpJumpGame.test.js
+++ b/src/algorithms/uncategorized/jump-game/__test__/dpBottomUpJumpGame.test.js
@@ -1,7 +1,7 @@
-import dpBottomUpJumpGame from '../dpBottomUpJumpGame';
+import dpBottomUpJumpGame from "../dpBottomUpJumpGame";
 
-describe('dpBottomUpJumpGame', () => {
-  it('should solve Jump Game problem in bottom-up dynamic programming manner', () => {
+describe("dpBottomUpJumpGame", () => {
+  it("should solve Jump Game problem in bottom-up dynamic programming manner", () => {
     expect(dpBottomUpJumpGame([1, 0])).toBe(true);
     expect(dpBottomUpJumpGame([100, 0])).toBe(true);
     expect(dpBottomUpJumpGame([2, 3, 1, 1, 4])).toBe(true);
@@ -15,3 +15,4 @@ describe('dpBottomUpJumpGame', () => {
     expect(dpBottomUpJumpGame([5, 4, 3, 2, 1, 0, 0])).toBe(false);
   });
 });
+
diff --git a/src/algorithms/uncategorized/jump-game/__test__/dpTopDownJumpGame.test.js b/src/algorithms/uncategorized/jump-game/__test__/dpTopDownJumpGame.test.js
index accf6b6..91854c6 100644
--- a/src/algorithms/uncategorized/jump-game/__test__/dpTopDownJumpGame.test.js
+++ b/src/algorithms/uncategorized/jump-game/__test__/dpTopDownJumpGame.test.js
@@ -1,7 +1,7 @@
-import dpTopDownJumpGame from '../dpTopDownJumpGame';
+import dpTopDownJumpGame from "../dpTopDownJumpGame";
 
-describe('dpTopDownJumpGame', () => {
-  it('should solve Jump Game problem in top-down dynamic programming manner', () => {
+describe("dpTopDownJumpGame", () => {
+  it("should solve Jump Game problem in top-down dynamic programming manner", () => {
     expect(dpTopDownJumpGame([1, 0])).toBe(true);
     expect(dpTopDownJumpGame([100, 0])).toBe(true);
     expect(dpTopDownJumpGame([2, 3, 1, 1, 4])).toBe(true);
@@ -15,3 +15,4 @@ describe('dpTopDownJumpGame', () => {
     expect(dpTopDownJumpGame([5, 4, 3, 2, 1, 0, 0])).toBe(false);
   });
 });
+
diff --git a/src/algorithms/uncategorized/jump-game/__test__/greedyJumpGame.test.js b/src/algorithms/uncategorized/jump-game/__test__/greedyJumpGame.test.js
index 61efb6b..55b818a 100644
--- a/src/algorithms/uncategorized/jump-game/__test__/greedyJumpGame.test.js
+++ b/src/algorithms/uncategorized/jump-game/__test__/greedyJumpGame.test.js
@@ -1,7 +1,7 @@
-import greedyJumpGame from '../greedyJumpGame';
+import greedyJumpGame from "../greedyJumpGame";
 
-describe('greedyJumpGame', () => {
-  it('should solve Jump Game problem in greedy manner', () => {
+describe("greedyJumpGame", () => {
+  it("should solve Jump Game problem in greedy manner", () => {
     expect(greedyJumpGame([1, 0])).toBe(true);
     expect(greedyJumpGame([100, 0])).toBe(true);
     expect(greedyJumpGame([2, 3, 1, 1, 4])).toBe(true);
@@ -15,3 +15,4 @@ describe('greedyJumpGame', () => {
     expect(greedyJumpGame([5, 4, 3, 2, 1, 0, 0])).toBe(false);
   });
 });
+
diff --git a/src/algorithms/uncategorized/jump-game/backtrackingJumpGame.js b/src/algorithms/uncategorized/jump-game/backtrackingJumpGame.js
index 272c4b2..6025269 100644
--- a/src/algorithms/uncategorized/jump-game/backtrackingJumpGame.js
+++ b/src/algorithms/uncategorized/jump-game/backtrackingJumpGame.js
@@ -12,7 +12,11 @@
  * @param {number[]} currentJumps - current jumps path.
  * @return {boolean}
  */
-export default function backtrackingJumpGame(numbers, startIndex = 0, currentJumps = []) {
+export default function backtrackingJumpGame(numbers) {
+  let startIndex =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+  let currentJumps =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
   if (startIndex === numbers.length - 1) {
     // We've jumped directly to last cell. This situation is a solution.
     return true;
@@ -22,7 +26,7 @@ export default function backtrackingJumpGame(numbers, startIndex = 0, currentJum
   // We don't need to jump beyond the array.
   const maxJumpLength = Math.min(
     numbers[startIndex], // Jump is within array.
-    numbers.length - 1 - startIndex, // Jump goes beyond array.
+    numbers.length - 1 - startIndex // Jump goes beyond array.
   );
 
   // Let's start jumping from startIndex and see whether any
@@ -32,7 +36,11 @@ export default function backtrackingJumpGame(numbers, startIndex = 0, currentJum
     const nextIndex = startIndex + jumpLength;
     currentJumps.push(nextIndex);
 
-    const isJumpSuccessful = backtrackingJumpGame(numbers, nextIndex, currentJumps);
+    const isJumpSuccessful = backtrackingJumpGame(
+      numbers,
+      nextIndex,
+      currentJumps
+    );
 
     // Check if current jump was successful.
     if (isJumpSuccessful) {
@@ -46,3 +54,4 @@ export default function backtrackingJumpGame(numbers, startIndex = 0, currentJum
 
   return false;
 }
+
diff --git a/src/algorithms/uncategorized/jump-game/dpBottomUpJumpGame.js b/src/algorithms/uncategorized/jump-game/dpBottomUpJumpGame.js
index cfd67fe..837c5b8 100644
--- a/src/algorithms/uncategorized/jump-game/dpBottomUpJumpGame.js
+++ b/src/algorithms/uncategorized/jump-game/dpBottomUpJumpGame.js
@@ -27,7 +27,7 @@ export default function dpBottomUpJumpGame(numbers) {
   for (let cellIndex = numbers.length - 2; cellIndex >= 0; cellIndex -= 1) {
     const maxJumpLength = Math.min(
       numbers[cellIndex],
-      numbers.length - 1 - cellIndex,
+      numbers.length - 1 - cellIndex
     );
 
     for (let jumpLength = maxJumpLength; jumpLength > 0; jumpLength -= 1) {
@@ -44,3 +44,4 @@ export default function dpBottomUpJumpGame(numbers) {
   // Now, if the zero's cell is good one then we can jump from it to the end of the array.
   return cellsGoodness[0] === true;
 }
+
diff --git a/src/algorithms/uncategorized/jump-game/dpTopDownJumpGame.js b/src/algorithms/uncategorized/jump-game/dpTopDownJumpGame.js
index 0e23736..28cf74d 100644
--- a/src/algorithms/uncategorized/jump-game/dpTopDownJumpGame.js
+++ b/src/algorithms/uncategorized/jump-game/dpTopDownJumpGame.js
@@ -17,12 +17,13 @@
  * @param {boolean[]} cellsGoodness - holds information about whether cell is "good" or "bad"
  * @return {boolean}
  */
-export default function dpTopDownJumpGame(
-  numbers,
-  startIndex = 0,
-  currentJumps = [],
-  cellsGoodness = [],
-) {
+export default function dpTopDownJumpGame(numbers) {
+  let startIndex =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+  let currentJumps =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  let cellsGoodness =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
   if (startIndex === numbers.length - 1) {
     // We've jumped directly to last cell. This situation is a solution.
     return true;
@@ -41,7 +42,7 @@ export default function dpTopDownJumpGame(
   // We don't need to jump beyond the array.
   const maxJumpLength = Math.min(
     numbers[startIndex], // Jump is within array.
-    numbers.length - 1 - startIndex, // Jump goes beyond array.
+    numbers.length - 1 - startIndex // Jump goes beyond array.
   );
 
   // Let's start jumping from startIndex and see whether any
@@ -59,7 +60,7 @@ export default function dpTopDownJumpGame(
         numbers,
         nextIndex,
         currentJumps,
-        currentCellsGoodness,
+        currentCellsGoodness
       );
 
       // Check if current jump was successful.
@@ -78,3 +79,4 @@ export default function dpTopDownJumpGame(
 
   return false;
 }
+
diff --git a/src/algorithms/uncategorized/jump-game/greedyJumpGame.js b/src/algorithms/uncategorized/jump-game/greedyJumpGame.js
index df52789..3f2c7a2 100644
--- a/src/algorithms/uncategorized/jump-game/greedyJumpGame.js
+++ b/src/algorithms/uncategorized/jump-game/greedyJumpGame.js
@@ -24,7 +24,11 @@ export default function greedyJumpGame(numbers) {
   let leftGoodPosition = numbers.length - 1;
 
   // Go through all numbers from right to left.
-  for (let numberIndex = numbers.length - 2; numberIndex >= 0; numberIndex -= 1) {
+  for (
+    let numberIndex = numbers.length - 2;
+    numberIndex >= 0;
+    numberIndex -= 1
+  ) {
     // If we can reach the "good" cell from the current one then for sure the current
     // one is also "good". Since after all we'll be able to reach the end of the array
     // from it.
@@ -38,3 +42,4 @@ export default function greedyJumpGame(numbers) {
   // possible jump to the end of the array from the first cell;
   return leftGoodPosition === 0;
 }
+
diff --git a/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js b/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js
index bc3ee0a..c3654d4 100644
--- a/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js
+++ b/src/algorithms/uncategorized/knight-tour/__test__/knightTour.test.js
@@ -1,13 +1,13 @@
-import knightTour from '../knightTour';
+import knightTour from "../knightTour";
 
-describe('knightTour', () => {
-  it('should not find solution on 3x3 board', () => {
+describe("knightTour", () => {
+  it("should not find solution on 3x3 board", () => {
     const moves = knightTour(3);
 
     expect(moves.length).toBe(0);
   });
 
-  it('should find one solution to do knight tour on 5x5 board', () => {
+  it("should find one solution to do knight tour on 5x5 board", () => {
     const moves = knightTour(5);
 
     expect(moves.length).toBe(25);
@@ -41,3 +41,4 @@ describe('knightTour', () => {
     ]);
   });
 });
+
diff --git a/src/algorithms/uncategorized/knight-tour/knightTour.js b/src/algorithms/uncategorized/knight-tour/knightTour.js
index c9c2737..fdc3a37 100644
--- a/src/algorithms/uncategorized/knight-tour/knightTour.js
+++ b/src/algorithms/uncategorized/knight-tour/knightTour.js
@@ -19,7 +19,9 @@ function getPossibleMoves(chessboard, position) {
   // Filter out all moves that go beyond the board.
   return possibleMoves.filter((move) => {
     const boardSize = chessboard.length;
-    return move[0] >= 0 && move[1] >= 0 && move[0] < boardSize && move[1] < boardSize;
+    return (
+      move[0] >= 0 && move[1] >= 0 && move[0] < boardSize && move[1] < boardSize
+    );
   });
 }
 
@@ -95,7 +97,9 @@ function knightTourRecursive(chessboard, moves) {
  */
 export default function knightTour(chessboardSize) {
   // Init chessboard.
-  const chessboard = Array(chessboardSize).fill(null).map(() => Array(chessboardSize).fill(0));
+  const chessboard = Array(chessboardSize)
+    .fill(null)
+    .map(() => Array(chessboardSize).fill(0));
 
   // Init moves array.
   const moves = [];
@@ -110,3 +114,4 @@ export default function knightTour(chessboardSize) {
 
   return solutionWasFound ? moves : [];
 }
+
diff --git a/src/algorithms/uncategorized/n-queens/QueenPosition.js b/src/algorithms/uncategorized/n-queens/QueenPosition.js
index 9ad278b..c08004a 100644
--- a/src/algorithms/uncategorized/n-queens/QueenPosition.js
+++ b/src/algorithms/uncategorized/n-queens/QueenPosition.js
@@ -37,3 +37,4 @@ export default class QueenPosition {
     return `${this.rowIndex},${this.columnIndex}`;
   }
 }
+
diff --git a/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js b/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js
index a842dce..4baf123 100644
--- a/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js
+++ b/src/algorithms/uncategorized/n-queens/__test__/QueensPosition.test.js
@@ -1,7 +1,7 @@
-import QueenPosition from '../QueenPosition';
+import QueenPosition from "../QueenPosition";
 
-describe('QueenPosition', () => {
-  it('should store queen position on chessboard', () => {
+describe("QueenPosition", () => {
+  it("should store queen position on chessboard", () => {
     const position1 = new QueenPosition(0, 0);
     const position2 = new QueenPosition(2, 1);
 
@@ -11,6 +11,7 @@ describe('QueenPosition', () => {
     expect(position1.rightDiagonal).toBe(0);
     expect(position2.leftDiagonal).toBe(1);
     expect(position2.rightDiagonal).toBe(3);
-    expect(position2.toString()).toBe('2,1');
+    expect(position2.toString()).toBe("2,1");
   });
 });
+
diff --git a/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js b/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js
index 1f01b3a..7601dac 100644
--- a/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js
+++ b/src/algorithms/uncategorized/n-queens/__test__/nQueens.test.js
@@ -1,38 +1,39 @@
-import nQueens from '../nQueens';
+import nQueens from "../nQueens";
 
-describe('nQueens', () => {
-  it('should not hae solution for 3 queens', () => {
+describe("nQueens", () => {
+  it("should not hae solution for 3 queens", () => {
     const solutions = nQueens(3);
     expect(solutions.length).toBe(0);
   });
 
-  it('should solve n-queens problem for 4 queens', () => {
+  it("should solve n-queens problem for 4 queens", () => {
     const solutions = nQueens(4);
     expect(solutions.length).toBe(2);
 
     // First solution.
-    expect(solutions[0][0].toString()).toBe('0,1');
-    expect(solutions[0][1].toString()).toBe('1,3');
-    expect(solutions[0][2].toString()).toBe('2,0');
-    expect(solutions[0][3].toString()).toBe('3,2');
+    expect(solutions[0][0].toString()).toBe("0,1");
+    expect(solutions[0][1].toString()).toBe("1,3");
+    expect(solutions[0][2].toString()).toBe("2,0");
+    expect(solutions[0][3].toString()).toBe("3,2");
 
     // Second solution (mirrored).
-    expect(solutions[1][0].toString()).toBe('0,2');
-    expect(solutions[1][1].toString()).toBe('1,0');
-    expect(solutions[1][2].toString()).toBe('2,3');
-    expect(solutions[1][3].toString()).toBe('3,1');
+    expect(solutions[1][0].toString()).toBe("0,2");
+    expect(solutions[1][1].toString()).toBe("1,0");
+    expect(solutions[1][2].toString()).toBe("2,3");
+    expect(solutions[1][3].toString()).toBe("3,1");
   });
 
-  it('should solve n-queens problem for 6 queens', () => {
+  it("should solve n-queens problem for 6 queens", () => {
     const solutions = nQueens(6);
     expect(solutions.length).toBe(4);
 
     // First solution.
-    expect(solutions[0][0].toString()).toBe('0,1');
-    expect(solutions[0][1].toString()).toBe('1,3');
-    expect(solutions[0][2].toString()).toBe('2,5');
-    expect(solutions[0][3].toString()).toBe('3,0');
-    expect(solutions[0][4].toString()).toBe('4,2');
-    expect(solutions[0][5].toString()).toBe('5,4');
+    expect(solutions[0][0].toString()).toBe("0,1");
+    expect(solutions[0][1].toString()).toBe("1,3");
+    expect(solutions[0][2].toString()).toBe("2,5");
+    expect(solutions[0][3].toString()).toBe("3,0");
+    expect(solutions[0][4].toString()).toBe("4,2");
+    expect(solutions[0][5].toString()).toBe("5,4");
   });
 });
+
diff --git a/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js b/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js
index 87dea41..31f2238 100644
--- a/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js
+++ b/src/algorithms/uncategorized/n-queens/__test__/nQueensBitwise.test.js
@@ -1,7 +1,7 @@
-import nQueensBitwise from '../nQueensBitwise';
+import nQueensBitwise from "../nQueensBitwise";
 
-describe('nQueensBitwise', () => {
-  it('should have solutions for 4 to N queens', () => {
+describe("nQueensBitwise", () => {
+  it("should have solutions for 4 to N queens", () => {
     expect(nQueensBitwise(4)).toBe(2);
     expect(nQueensBitwise(5)).toBe(10);
     expect(nQueensBitwise(6)).toBe(4);
@@ -12,3 +12,4 @@ describe('nQueensBitwise', () => {
     expect(nQueensBitwise(11)).toBe(2680);
   });
 });
+
diff --git a/src/algorithms/uncategorized/n-queens/nQueens.js b/src/algorithms/uncategorized/n-queens/nQueens.js
index d95d182..315b89c 100644
--- a/src/algorithms/uncategorized/n-queens/nQueens.js
+++ b/src/algorithms/uncategorized/n-queens/nQueens.js
@@ -1,4 +1,4 @@
-import QueenPosition from './QueenPosition';
+import QueenPosition from "./QueenPosition";
 
 /**
  * @param {QueenPosition[]} queensPositions
@@ -11,22 +11,24 @@ function isSafe(queensPositions, rowIndex, columnIndex) {
   const newQueenPosition = new QueenPosition(rowIndex, columnIndex);
 
   // Check if new queen position conflicts with any other queens.
-  for (let queenIndex = 0; queenIndex < queensPositions.length; queenIndex += 1) {
+  for (
+    let queenIndex = 0;
+    queenIndex < queensPositions.length;
+    queenIndex += 1
+  ) {
     const currentQueenPosition = queensPositions[queenIndex];
 
     if (
       // Check if queen has been already placed.
-      currentQueenPosition
-      && (
-        // Check if there are any queen on the same column.
-        newQueenPosition.columnIndex === currentQueenPosition.columnIndex
+      currentQueenPosition &&
+      // Check if there are any queen on the same column.
+      (newQueenPosition.columnIndex === currentQueenPosition.columnIndex ||
         // Check if there are any queen on the same row.
-        || newQueenPosition.rowIndex === currentQueenPosition.rowIndex
+        newQueenPosition.rowIndex === currentQueenPosition.rowIndex ||
         // Check if there are any queen on the same left diagonal.
-        || newQueenPosition.leftDiagonal === currentQueenPosition.leftDiagonal
+        newQueenPosition.leftDiagonal === currentQueenPosition.leftDiagonal ||
         // Check if there are any queen on the same right diagonal.
-        || newQueenPosition.rightDiagonal === currentQueenPosition.rightDiagonal
-      )
+        newQueenPosition.rightDiagonal === currentQueenPosition.rightDiagonal)
     ) {
       // Can't place queen into current position since there are other queens that
       // are threatening it.
@@ -45,13 +47,17 @@ function isSafe(queensPositions, rowIndex, columnIndex) {
  * @param {number} rowIndex
  * @return {boolean}
  */
-function nQueensRecursive(solutions, previousQueensPositions, queensCount, rowIndex) {
+function nQueensRecursive(
+  solutions,
+  previousQueensPositions,
+  queensCount,
+  rowIndex
+) {
   // Clone positions array.
   const queensPositions = [...previousQueensPositions].map((queenPosition) => {
-    return !queenPosition ? queenPosition : new QueenPosition(
-      queenPosition.rowIndex,
-      queenPosition.columnIndex,
-    );
+    return !queenPosition
+      ? queenPosition
+      : new QueenPosition(queenPosition.rowIndex, queenPosition.columnIndex);
   });
 
   if (rowIndex === queensCount) {
@@ -101,3 +107,4 @@ export default function nQueens(queensCount) {
 
   return solutions;
 }
+
diff --git a/src/algorithms/uncategorized/n-queens/nQueensBitwise.js b/src/algorithms/uncategorized/n-queens/nQueensBitwise.js
index 05dd40b..aaaa4b3 100644
--- a/src/algorithms/uncategorized/n-queens/nQueensBitwise.js
+++ b/src/algorithms/uncategorized/n-queens/nQueensBitwise.js
@@ -11,13 +11,15 @@
  * @param {number} solutionsCount - Keeps track of the number of valid solutions.
  * @return {number} - Number of possible solutions.
  */
-function nQueensBitwiseRecursive(
-  boardSize,
-  leftDiagonal = 0,
-  column = 0,
-  rightDiagonal = 0,
-  solutionsCount = 0,
-) {
+function nQueensBitwiseRecursive(boardSize) {
+  let leftDiagonal =
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+  let column =
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
+  let rightDiagonal =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
+  let solutionsCount =
+    arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
   // Keeps track of the number of valid solutions.
   let currentSolutionsCount = solutionsCount;
 
@@ -25,7 +27,7 @@ function nQueensBitwiseRecursive(
   // isDone simply has a bit sequence with 1 for every entry up to the Nth. For example,
   // when N=5, done will equal 11111. The "isDone" variable simply allows us to not worry about any
   // bits beyond the Nth.
-  const isDone = (2 ** boardSize) - 1;
+  const isDone = 2 ** boardSize - 1;
 
   // All columns are occupied (i.e. 0b1111 for boardSize = 4), so the solution must be complete.
   // Since the algorithm never places a queen illegally (ie. when it can attack or be attacked),
@@ -84,7 +86,7 @@ function nQueensBitwiseRecursive(
       (leftDiagonal | firstAvailablePosition) >> 1,
       column | firstAvailablePosition,
       (rightDiagonal | firstAvailablePosition) << 1,
-      solutionsCount,
+      solutionsCount
     );
   }
 
@@ -99,3 +101,4 @@ function nQueensBitwiseRecursive(
 export default function nQueensBitwise(boardSize) {
   return nQueensBitwiseRecursive(boardSize);
 }
+
diff --git a/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js b/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js
index d11fc95..5ee8e41 100644
--- a/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js
+++ b/src/algorithms/uncategorized/rain-terraces/__test__/bfRainTerraces.test.js
@@ -1,7 +1,7 @@
-import bfRainTerraces from '../bfRainTerraces';
+import bfRainTerraces from "../bfRainTerraces";
 
-describe('bfRainTerraces', () => {
-  it('should find the amount of water collected after raining', () => {
+describe("bfRainTerraces", () => {
+  it("should find the amount of water collected after raining", () => {
     expect(bfRainTerraces([1])).toBe(0);
     expect(bfRainTerraces([1, 0])).toBe(0);
     expect(bfRainTerraces([0, 1])).toBe(0);
@@ -19,3 +19,4 @@ describe('bfRainTerraces', () => {
     expect(bfRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
   });
 });
+
diff --git a/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js b/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js
index 50c3386..d8086ee 100644
--- a/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js
+++ b/src/algorithms/uncategorized/rain-terraces/__test__/dpRainTerraces.test.js
@@ -1,7 +1,7 @@
-import dpRainTerraces from '../dpRainTerraces';
+import dpRainTerraces from "../dpRainTerraces";
 
-describe('dpRainTerraces', () => {
-  it('should find the amount of water collected after raining', () => {
+describe("dpRainTerraces", () => {
+  it("should find the amount of water collected after raining", () => {
     expect(dpRainTerraces([1])).toBe(0);
     expect(dpRainTerraces([1, 0])).toBe(0);
     expect(dpRainTerraces([0, 1])).toBe(0);
@@ -19,3 +19,4 @@ describe('dpRainTerraces', () => {
     expect(dpRainTerraces([0, 2, 4, 3, 4, 2, 4, 0, 8, 7, 0])).toBe(7);
   });
 });
+
diff --git a/src/algorithms/uncategorized/rain-terraces/bfRainTerraces.js b/src/algorithms/uncategorized/rain-terraces/bfRainTerraces.js
index 0d3443a..421e0a3 100644
--- a/src/algorithms/uncategorized/rain-terraces/bfRainTerraces.js
+++ b/src/algorithms/uncategorized/rain-terraces/bfRainTerraces.js
@@ -7,7 +7,11 @@
 export default function bfRainTerraces(terraces) {
   let waterAmount = 0;
 
-  for (let terraceIndex = 0; terraceIndex < terraces.length; terraceIndex += 1) {
+  for (
+    let terraceIndex = 0;
+    terraceIndex < terraces.length;
+    terraceIndex += 1
+  ) {
     // Get left most high terrace.
     let leftHighestLevel = 0;
     for (let leftIndex = terraceIndex - 1; leftIndex >= 0; leftIndex -= 1) {
@@ -16,7 +20,11 @@ export default function bfRainTerraces(terraces) {
 
     // Get right most high terrace.
     let rightHighestLevel = 0;
-    for (let rightIndex = terraceIndex + 1; rightIndex < terraces.length; rightIndex += 1) {
+    for (
+      let rightIndex = terraceIndex + 1;
+      rightIndex < terraces.length;
+      rightIndex += 1
+    ) {
       rightHighestLevel = Math.max(rightHighestLevel, terraces[rightIndex]);
     }
 
@@ -31,3 +39,4 @@ export default function bfRainTerraces(terraces) {
 
   return waterAmount;
 }
+
diff --git a/src/algorithms/uncategorized/rain-terraces/dpRainTerraces.js b/src/algorithms/uncategorized/rain-terraces/dpRainTerraces.js
index 1c48cbd..f27980a 100644
--- a/src/algorithms/uncategorized/rain-terraces/dpRainTerraces.js
+++ b/src/algorithms/uncategorized/rain-terraces/dpRainTerraces.js
@@ -1,3 +1,61 @@
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+  return arr2;
+}
+function _iterableToArrayLimit(arr, i) {
+  var _i =
+    arr == null
+      ? null
+      : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
+        arr["@@iterator"];
+  if (_i == null) return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _s, _e;
+  try {
+    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
+      _arr.push(_s.value);
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+  return _arr;
+}
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
 /**
  * DYNAMIC PROGRAMMING approach of solving Trapping Rain Water problem.
  *
@@ -12,30 +70,43 @@ export default function dpRainTerraces(terraces) {
   const rightMaxLevels = new Array(terraces.length).fill(0);
 
   // Calculate the highest terrace level from the LEFT relative to the current terrace.
-  [leftMaxLevels[0]] = terraces;
-  for (let terraceIndex = 1; terraceIndex < terraces.length; terraceIndex += 1) {
+  var _terraces = _slicedToArray(terraces, 1);
+  leftMaxLevels[0] = _terraces[0];
+  for (
+    let terraceIndex = 1;
+    terraceIndex < terraces.length;
+    terraceIndex += 1
+  ) {
     leftMaxLevels[terraceIndex] = Math.max(
       terraces[terraceIndex],
-      leftMaxLevels[terraceIndex - 1],
+      leftMaxLevels[terraceIndex - 1]
     );
   }
 
   // Calculate the highest terrace level from the RIGHT relative to the current terrace.
   rightMaxLevels[terraces.length - 1] = terraces[terraces.length - 1];
-  for (let terraceIndex = terraces.length - 2; terraceIndex >= 0; terraceIndex -= 1) {
+  for (
+    let terraceIndex = terraces.length - 2;
+    terraceIndex >= 0;
+    terraceIndex -= 1
+  ) {
     rightMaxLevels[terraceIndex] = Math.max(
       terraces[terraceIndex],
-      rightMaxLevels[terraceIndex + 1],
+      rightMaxLevels[terraceIndex + 1]
     );
   }
 
   // Not let's go through all terraces one by one and calculate how much water
   // each terrace may accumulate based on previously calculated values.
-  for (let terraceIndex = 0; terraceIndex < terraces.length; terraceIndex += 1) {
+  for (
+    let terraceIndex = 0;
+    terraceIndex < terraces.length;
+    terraceIndex += 1
+  ) {
     // Pick the lowest from the left/right highest terraces.
     const currentTerraceBoundary = Math.min(
       leftMaxLevels[terraceIndex],
-      rightMaxLevels[terraceIndex],
+      rightMaxLevels[terraceIndex]
     );
 
     if (currentTerraceBoundary > terraces[terraceIndex]) {
@@ -45,3 +116,4 @@ export default function dpRainTerraces(terraces) {
 
   return waterAmount;
 }
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js
index d1cccf4..240e54d 100644
--- a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js
+++ b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseBF.test.js
@@ -1,7 +1,7 @@
-import recursiveStaircaseBF from '../recursiveStaircaseBF';
+import recursiveStaircaseBF from "../recursiveStaircaseBF";
 
-describe('recursiveStaircaseBF', () => {
-  it('should calculate number of variants using Brute Force solution', () => {
+describe("recursiveStaircaseBF", () => {
+  it("should calculate number of variants using Brute Force solution", () => {
     expect(recursiveStaircaseBF(-1)).toBe(0);
     expect(recursiveStaircaseBF(0)).toBe(0);
     expect(recursiveStaircaseBF(1)).toBe(1);
@@ -16,3 +16,4 @@ describe('recursiveStaircaseBF', () => {
     expect(recursiveStaircaseBF(10)).toBe(89);
   });
 });
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js
index b8edd83..bfe5fc0 100644
--- a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js
+++ b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseDP.test.js
@@ -1,7 +1,7 @@
-import recursiveStaircaseDP from '../recursiveStaircaseDP';
+import recursiveStaircaseDP from "../recursiveStaircaseDP";
 
-describe('recursiveStaircaseDP', () => {
-  it('should calculate number of variants using Dynamic Programming solution', () => {
+describe("recursiveStaircaseDP", () => {
+  it("should calculate number of variants using Dynamic Programming solution", () => {
     expect(recursiveStaircaseDP(-1)).toBe(0);
     expect(recursiveStaircaseDP(0)).toBe(0);
     expect(recursiveStaircaseDP(1)).toBe(1);
@@ -16,3 +16,4 @@ describe('recursiveStaircaseDP', () => {
     expect(recursiveStaircaseDP(10)).toBe(89);
   });
 });
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js
index 2c0eb73..9ee63f4 100644
--- a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js
+++ b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseIT.test.js
@@ -1,7 +1,7 @@
-import recursiveStaircaseIT from '../recursiveStaircaseIT';
+import recursiveStaircaseIT from "../recursiveStaircaseIT";
 
-describe('recursiveStaircaseIT', () => {
-  it('should calculate number of variants using Iterative solution', () => {
+describe("recursiveStaircaseIT", () => {
+  it("should calculate number of variants using Iterative solution", () => {
     expect(recursiveStaircaseIT(-1)).toBe(0);
     expect(recursiveStaircaseIT(0)).toBe(0);
     expect(recursiveStaircaseIT(1)).toBe(1);
@@ -16,3 +16,4 @@ describe('recursiveStaircaseIT', () => {
     expect(recursiveStaircaseIT(10)).toBe(89);
   });
 });
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js
index 3099873..70ababa 100644
--- a/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js
+++ b/src/algorithms/uncategorized/recursive-staircase/__test__/recursiveStaircaseMEM.test.js
@@ -1,7 +1,7 @@
-import recursiveStaircaseMEM from '../recursiveStaircaseMEM';
+import recursiveStaircaseMEM from "../recursiveStaircaseMEM";
 
-describe('recursiveStaircaseMEM', () => {
-  it('should calculate number of variants using Brute Force with Memoization', () => {
+describe("recursiveStaircaseMEM", () => {
+  it("should calculate number of variants using Brute Force with Memoization", () => {
     expect(recursiveStaircaseMEM(-1)).toBe(0);
     expect(recursiveStaircaseMEM(0)).toBe(0);
     expect(recursiveStaircaseMEM(1)).toBe(1);
@@ -16,3 +16,4 @@ describe('recursiveStaircaseMEM', () => {
     expect(recursiveStaircaseMEM(10)).toBe(89);
   });
 });
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseBF.js b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseBF.js
index 108aae2..7005f27 100644
--- a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseBF.js
+++ b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseBF.js
@@ -23,5 +23,8 @@ export default function recursiveStaircaseBF(stairsNum) {
 
   // Sum up how many steps we need to take after doing one step up with the number of
   // steps we need to take after doing two steps up.
-  return recursiveStaircaseBF(stairsNum - 1) + recursiveStaircaseBF(stairsNum - 2);
+  return (
+    recursiveStaircaseBF(stairsNum - 1) + recursiveStaircaseBF(stairsNum - 2)
+  );
 }
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseDP.js b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseDP.js
index f8cffcf..dd64868 100644
--- a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseDP.js
+++ b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseDP.js
@@ -31,3 +31,4 @@ export default function recursiveStaircaseDP(stairsNum) {
   // Return possible ways to get to the requested step.
   return steps[stairsNum];
 }
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseIT.js b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseIT.js
index e464504..a9cfd40 100644
--- a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseIT.js
+++ b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseIT.js
@@ -23,9 +23,12 @@ export default function recursiveStaircaseIT(stairsNum) {
   // Comparing to Dynamic Programming solution we don't store info for all the steps but
   // rather for two previous ones only.
   for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {
-    [steps[0], steps[1]] = [steps[1], steps[0] + steps[1]];
+    var _ref = [steps[1], steps[0] + steps[1]];
+    steps[0] = _ref[0];
+    steps[1] = _ref[1];
   }
 
   // Return possible ways to get to the requested step.
   return steps[1];
 }
+
diff --git a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseMEM.js b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseMEM.js
index dcc9f9a..5df7515 100644
--- a/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseMEM.js
+++ b/src/algorithms/uncategorized/recursive-staircase/recursiveStaircaseMEM.js
@@ -42,3 +42,4 @@ export default function recursiveStaircaseMEM(totalStairs) {
   // Return possible ways to get to the requested step.
   return getSteps(totalStairs);
 }
+
diff --git a/src/algorithms/uncategorized/square-matrix-rotation/__test__/squareMatrixRotation.test.js b/src/algorithms/uncategorized/square-matrix-rotation/__test__/squareMatrixRotation.test.js
index cb22a9c..c6b3e7d 100644
--- a/src/algorithms/uncategorized/square-matrix-rotation/__test__/squareMatrixRotation.test.js
+++ b/src/algorithms/uncategorized/square-matrix-rotation/__test__/squareMatrixRotation.test.js
@@ -1,7 +1,7 @@
-import squareMatrixRotation from '../squareMatrixRotation';
+import squareMatrixRotation from "../squareMatrixRotation";
 
-describe('squareMatrixRotation', () => {
-  it('should rotate matrix #0 in-place', () => {
+describe("squareMatrixRotation", () => {
+  it("should rotate matrix #0 in-place", () => {
     const matrix = [[1]];
 
     const rotatedMatrix = [[1]];
@@ -9,7 +9,7 @@ describe('squareMatrixRotation', () => {
     expect(squareMatrixRotation(matrix)).toEqual(rotatedMatrix);
   });
 
-  it('should rotate matrix #1 in-place', () => {
+  it("should rotate matrix #1 in-place", () => {
     const matrix = [
       [1, 2],
       [3, 4],
@@ -23,7 +23,7 @@ describe('squareMatrixRotation', () => {
     expect(squareMatrixRotation(matrix)).toEqual(rotatedMatrix);
   });
 
-  it('should rotate matrix #2 in-place', () => {
+  it("should rotate matrix #2 in-place", () => {
     const matrix = [
       [1, 2, 3],
       [4, 5, 6],
@@ -39,7 +39,7 @@ describe('squareMatrixRotation', () => {
     expect(squareMatrixRotation(matrix)).toEqual(rotatedMatrix);
   });
 
-  it('should rotate matrix #3 in-place', () => {
+  it("should rotate matrix #3 in-place", () => {
     const matrix = [
       [5, 1, 9, 11],
       [2, 4, 8, 10],
@@ -57,3 +57,4 @@ describe('squareMatrixRotation', () => {
     expect(squareMatrixRotation(matrix)).toEqual(rotatedMatrix);
   });
 });
+
diff --git a/src/algorithms/uncategorized/square-matrix-rotation/squareMatrixRotation.js b/src/algorithms/uncategorized/square-matrix-rotation/squareMatrixRotation.js
index f2a52a7..acac251 100644
--- a/src/algorithms/uncategorized/square-matrix-rotation/squareMatrixRotation.js
+++ b/src/algorithms/uncategorized/square-matrix-rotation/squareMatrixRotation.js
@@ -7,31 +7,35 @@ export default function squareMatrixRotation(originalMatrix) {
 
   // Do top-right/bottom-left diagonal reflection of the matrix.
   for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {
-    for (let columnIndex = rowIndex + 1; columnIndex < matrix.length; columnIndex += 1) {
+    for (
+      let columnIndex = rowIndex + 1;
+      columnIndex < matrix.length;
+      columnIndex += 1
+    ) {
       // Swap elements.
-      [
-        matrix[columnIndex][rowIndex],
-        matrix[rowIndex][columnIndex],
-      ] = [
-        matrix[rowIndex][columnIndex],
-        matrix[columnIndex][rowIndex],
-      ];
+      var _ref = [matrix[rowIndex][columnIndex], matrix[columnIndex][rowIndex]];
+      matrix[columnIndex][rowIndex] = _ref[0];
+      matrix[rowIndex][columnIndex] = _ref[1];
     }
   }
 
   // Do horizontal reflection of the matrix.
   for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {
-    for (let columnIndex = 0; columnIndex < matrix.length / 2; columnIndex += 1) {
+    for (
+      let columnIndex = 0;
+      columnIndex < matrix.length / 2;
+      columnIndex += 1
+    ) {
       // Swap elements.
-      [
-        matrix[rowIndex][matrix.length - columnIndex - 1],
-        matrix[rowIndex][columnIndex],
-      ] = [
+      var _ref2 = [
         matrix[rowIndex][columnIndex],
         matrix[rowIndex][matrix.length - columnIndex - 1],
       ];
+      matrix[rowIndex][matrix.length - columnIndex - 1] = _ref2[0];
+      matrix[rowIndex][columnIndex] = _ref2[1];
     }
   }
 
   return matrix;
 }
+
diff --git a/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js b/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js
index 655f8a3..b630195 100644
--- a/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js
+++ b/src/algorithms/uncategorized/unique-paths/__test__/btUniquePaths.test.js
@@ -1,7 +1,7 @@
-import btUniquePaths from '../btUniquePaths';
+import btUniquePaths from "../btUniquePaths";
 
-describe('btUniquePaths', () => {
-  it('should find the number of unique paths on board', () => {
+describe("btUniquePaths", () => {
+  it("should find the number of unique paths on board", () => {
     expect(btUniquePaths(3, 2)).toBe(3);
     expect(btUniquePaths(7, 3)).toBe(28);
     expect(btUniquePaths(3, 7)).toBe(28);
@@ -10,3 +10,4 @@ describe('btUniquePaths', () => {
     expect(btUniquePaths(1, 100)).toBe(1);
   });
 });
+
diff --git a/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js b/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js
index d5d7bb7..974d492 100644
--- a/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js
+++ b/src/algorithms/uncategorized/unique-paths/__test__/dpUniquePaths.test.js
@@ -1,7 +1,7 @@
-import dpUniquePaths from '../dpUniquePaths';
+import dpUniquePaths from "../dpUniquePaths";
 
-describe('dpUniquePaths', () => {
-  it('should find the number of unique paths on board', () => {
+describe("dpUniquePaths", () => {
+  it("should find the number of unique paths on board", () => {
     expect(dpUniquePaths(3, 2)).toBe(3);
     expect(dpUniquePaths(7, 3)).toBe(28);
     expect(dpUniquePaths(3, 7)).toBe(28);
@@ -10,3 +10,4 @@ describe('dpUniquePaths', () => {
     expect(dpUniquePaths(1, 100)).toBe(1);
   });
 });
+
diff --git a/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js b/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js
index da152b3..6d63cc9 100644
--- a/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js
+++ b/src/algorithms/uncategorized/unique-paths/__test__/uniquePaths.test.js
@@ -1,7 +1,7 @@
-import uniquePaths from '../uniquePaths';
+import uniquePaths from "../uniquePaths";
 
-describe('uniquePaths', () => {
-  it('should find the number of unique paths on board', () => {
+describe("uniquePaths", () => {
+  it("should find the number of unique paths on board", () => {
     expect(uniquePaths(3, 2)).toBe(3);
     expect(uniquePaths(7, 3)).toBe(28);
     expect(uniquePaths(3, 7)).toBe(28);
@@ -10,3 +10,4 @@ describe('uniquePaths', () => {
     expect(uniquePaths(1, 100)).toBe(1);
   });
 });
+
diff --git a/src/algorithms/uncategorized/unique-paths/btUniquePaths.js b/src/algorithms/uncategorized/unique-paths/btUniquePaths.js
index abe9449..98b45db 100644
--- a/src/algorithms/uncategorized/unique-paths/btUniquePaths.js
+++ b/src/algorithms/uncategorized/unique-paths/btUniquePaths.js
@@ -7,7 +7,13 @@
  * @param {number} uniqueSteps - Total number of unique steps.
  * @return {number} - Number of unique paths.
  */
-export default function btUniquePaths(width, height, steps = [[0, 0]], uniqueSteps = 0) {
+export default function btUniquePaths(width, height) {
+  let steps =
+    arguments.length > 2 && arguments[2] !== undefined
+      ? arguments[2]
+      : [[0, 0]];
+  let uniqueSteps =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
   // Fetch current position on board.
   const currentPos = steps[steps.length - 1];
 
@@ -25,10 +31,7 @@ export default function btUniquePaths(width, height, steps = [[0, 0]], uniqueSte
 
   // Do right step if possible.
   if (currentPos[0] < width - 1) {
-    steps.push([
-      currentPos[0] + 1,
-      currentPos[1],
-    ]);
+    steps.push([currentPos[0] + 1, currentPos[1]]);
 
     // Calculate how many unique paths we'll get by moving right.
     rightUniqueSteps = btUniquePaths(width, height, steps, uniqueSteps);
@@ -39,10 +42,7 @@ export default function btUniquePaths(width, height, steps = [[0, 0]], uniqueSte
 
   // Do down step if possible.
   if (currentPos[1] < height - 1) {
-    steps.push([
-      currentPos[0],
-      currentPos[1] + 1,
-    ]);
+    steps.push([currentPos[0], currentPos[1] + 1]);
 
     // Calculate how many unique paths we'll get by moving down.
     downUniqueSteps = btUniquePaths(width, height, steps, uniqueSteps);
@@ -56,3 +56,4 @@ export default function btUniquePaths(width, height, steps = [[0, 0]], uniqueSte
   // by going down.
   return rightUniqueSteps + downUniqueSteps;
 }
+
diff --git a/src/algorithms/uncategorized/unique-paths/dpUniquePaths.js b/src/algorithms/uncategorized/unique-paths/dpUniquePaths.js
index 75d33ed..770431d 100644
--- a/src/algorithms/uncategorized/unique-paths/dpUniquePaths.js
+++ b/src/algorithms/uncategorized/unique-paths/dpUniquePaths.js
@@ -7,9 +7,11 @@
  */
 export default function dpUniquePaths(width, height) {
   // Init board.
-  const board = Array(height).fill(null).map(() => {
-    return Array(width).fill(0);
-  });
+  const board = Array(height)
+    .fill(null)
+    .map(() => {
+      return Array(width).fill(0);
+    });
 
   // Base case.
   // There is only one way of getting to board[0][any] and
@@ -38,3 +40,4 @@ export default function dpUniquePaths(width, height) {
 
   return board[height - 1][width - 1];
 }
+
diff --git a/src/algorithms/uncategorized/unique-paths/uniquePaths.js b/src/algorithms/uncategorized/unique-paths/uniquePaths.js
index c39b659..d974adf 100644
--- a/src/algorithms/uncategorized/unique-paths/uniquePaths.js
+++ b/src/algorithms/uncategorized/unique-paths/uniquePaths.js
@@ -1,4 +1,4 @@
-import pascalTriangle from '../../math/pascal-triangle/pascalTriangle';
+import pascalTriangle from "../../math/pascal-triangle/pascalTriangle";
 
 /**
  * @param {number} width
@@ -11,3 +11,4 @@ export default function uniquePaths(width, height) {
 
   return pascalTriangle(pascalLine)[pascalLinePosition];
 }
+
diff --git a/src/data-structures/bloom-filter/BloomFilter.js b/src/data-structures/bloom-filter/BloomFilter.js
index dd26488..f65679c 100644
--- a/src/data-structures/bloom-filter/BloomFilter.js
+++ b/src/data-structures/bloom-filter/BloomFilter.js
@@ -2,7 +2,9 @@ export default class BloomFilter {
   /**
    * @param {number} size - the size of the storage.
    */
-  constructor(size = 100) {
+  constructor() {
+    let size =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
     // Bloom filter size directly affects the likelihood of false positives.
     // The bigger the size the lower the likelihood of false positives.
     this.size = size;
@@ -50,7 +52,11 @@ export default class BloomFilter {
     const storage = [];
 
     // Initialize all indexes to false
-    for (let storageCellIndex = 0; storageCellIndex < size; storageCellIndex += 1) {
+    for (
+      let storageCellIndex = 0;
+      storageCellIndex < size;
+      storageCellIndex += 1
+    ) {
       storage.push(false);
     }
 
@@ -122,10 +128,7 @@ export default class BloomFilter {
    * @return {number[]}
    */
   getHashValues(item) {
-    return [
-      this.hash1(item),
-      this.hash2(item),
-      this.hash3(item),
-    ];
+    return [this.hash1(item), this.hash2(item), this.hash3(item)];
   }
 }
+
diff --git a/src/data-structures/bloom-filter/__test__/BloomFilter.test.js b/src/data-structures/bloom-filter/__test__/BloomFilter.test.js
index cc5891e..3d83bbe 100644
--- a/src/data-structures/bloom-filter/__test__/BloomFilter.test.js
+++ b/src/data-structures/bloom-filter/__test__/BloomFilter.test.js
@@ -1,30 +1,26 @@
-import BloomFilter from '../BloomFilter';
+import BloomFilter from "../BloomFilter";
 
-describe('BloomFilter', () => {
+describe("BloomFilter", () => {
   let bloomFilter;
-  const people = [
-    'Bruce Wayne',
-    'Clark Kent',
-    'Barry Allen',
-  ];
+  const people = ["Bruce Wayne", "Clark Kent", "Barry Allen"];
 
   beforeEach(() => {
     bloomFilter = new BloomFilter();
   });
 
   it('should have methods named "insert" and "mayContain"', () => {
-    expect(typeof bloomFilter.insert).toBe('function');
-    expect(typeof bloomFilter.mayContain).toBe('function');
+    expect(typeof bloomFilter.insert).toBe("function");
+    expect(typeof bloomFilter.mayContain).toBe("function");
   });
 
-  it('should create a new filter store with the appropriate methods', () => {
+  it("should create a new filter store with the appropriate methods", () => {
     const store = bloomFilter.createStore(18);
-    expect(typeof store.getValue).toBe('function');
-    expect(typeof store.setValue).toBe('function');
+    expect(typeof store.getValue).toBe("function");
+    expect(typeof store.setValue).toBe("function");
   });
 
-  it('should hash deterministically with all 3 hash functions', () => {
-    const str1 = 'apple';
+  it("should hash deterministically with all 3 hash functions", () => {
+    const str1 = "apple";
 
     expect(bloomFilter.hash1(str1)).toEqual(bloomFilter.hash1(str1));
     expect(bloomFilter.hash2(str1)).toEqual(bloomFilter.hash2(str1));
@@ -34,7 +30,7 @@ describe('BloomFilter', () => {
     expect(bloomFilter.hash2(str1)).toBe(43);
     expect(bloomFilter.hash3(str1)).toBe(10);
 
-    const str2 = 'orange';
+    const str2 = "orange";
 
     expect(bloomFilter.hash1(str2)).toEqual(bloomFilter.hash1(str2));
     expect(bloomFilter.hash2(str2)).toEqual(bloomFilter.hash2(str2));
@@ -45,18 +41,19 @@ describe('BloomFilter', () => {
     expect(bloomFilter.hash3(str2)).toBe(10);
   });
 
-  it('should create an array with 3 hash values', () => {
-    expect(bloomFilter.getHashValues('abc').length).toBe(3);
-    expect(bloomFilter.getHashValues('abc')).toEqual([66, 63, 54]);
+  it("should create an array with 3 hash values", () => {
+    expect(bloomFilter.getHashValues("abc").length).toBe(3);
+    expect(bloomFilter.getHashValues("abc")).toEqual([66, 63, 54]);
   });
 
-  it('should insert strings correctly and return true when checking for inserted values', () => {
+  it("should insert strings correctly and return true when checking for inserted values", () => {
     people.forEach((person) => bloomFilter.insert(person));
 
-    expect(bloomFilter.mayContain('Bruce Wayne')).toBe(true);
-    expect(bloomFilter.mayContain('Clark Kent')).toBe(true);
-    expect(bloomFilter.mayContain('Barry Allen')).toBe(true);
+    expect(bloomFilter.mayContain("Bruce Wayne")).toBe(true);
+    expect(bloomFilter.mayContain("Clark Kent")).toBe(true);
+    expect(bloomFilter.mayContain("Barry Allen")).toBe(true);
 
-    expect(bloomFilter.mayContain('Tony Stark')).toBe(false);
+    expect(bloomFilter.mayContain("Tony Stark")).toBe(false);
   });
 });
+
diff --git a/src/data-structures/disjoint-set/DisjointSet.js b/src/data-structures/disjoint-set/DisjointSet.js
index 2fe3c25..6a1ae50 100644
--- a/src/data-structures/disjoint-set/DisjointSet.js
+++ b/src/data-structures/disjoint-set/DisjointSet.js
@@ -1,4 +1,4 @@
-import DisjointSetItem from './DisjointSetItem';
+import DisjointSetItem from "./DisjointSetItem";
 
 export default class DisjointSet {
   /**
@@ -31,7 +31,10 @@ export default class DisjointSet {
    * @return {(string|null)}
    */
   find(itemValue) {
-    const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);
+    const templateDisjointItem = new DisjointSetItem(
+      itemValue,
+      this.keyCallback
+    );
 
     // Try to find item itself;
     const requiredDisjointItem = this.items[templateDisjointItem.getKey()];
@@ -55,7 +58,7 @@ export default class DisjointSet {
     const rootKeyB = this.find(valueB);
 
     if (rootKeyA === null || rootKeyB === null) {
-      throw new Error('One or two values are not in sets');
+      throw new Error("One or two values are not in sets");
     }
 
     if (rootKeyA === rootKeyB) {
@@ -89,9 +92,10 @@ export default class DisjointSet {
     const rootKeyB = this.find(valueB);
 
     if (rootKeyA === null || rootKeyB === null) {
-      throw new Error('One or two values are not in sets');
+      throw new Error("One or two values are not in sets");
     }
 
     return rootKeyA === rootKeyB;
   }
 }
+
diff --git a/src/data-structures/disjoint-set/DisjointSetItem.js b/src/data-structures/disjoint-set/DisjointSetItem.js
index 037d0e0..fc693a5 100644
--- a/src/data-structures/disjoint-set/DisjointSetItem.js
+++ b/src/data-structures/disjoint-set/DisjointSetItem.js
@@ -74,7 +74,9 @@ export default class DisjointSetItem {
    * @param {boolean} forceSettingParentChild
    * @return {DisjointSetItem}
    */
-  setParent(parentItem, forceSettingParentChild = true) {
+  setParent(parentItem) {
+    let forceSettingParentChild =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
     this.parent = parentItem;
     if (forceSettingParentChild) {
       parentItem.addChild(this);
@@ -94,3 +96,4 @@ export default class DisjointSetItem {
     return this;
   }
 }
+
diff --git a/src/data-structures/disjoint-set/__test__/DisjointSet.test.js b/src/data-structures/disjoint-set/__test__/DisjointSet.test.js
index db0d019..06d6023 100644
--- a/src/data-structures/disjoint-set/__test__/DisjointSet.test.js
+++ b/src/data-structures/disjoint-set/__test__/DisjointSet.test.js
@@ -1,119 +1,115 @@
-import DisjointSet from '../DisjointSet';
+import DisjointSet from "../DisjointSet";
 
-describe('DisjointSet', () => {
-  it('should throw error when trying to union and check not existing sets', () => {
+describe("DisjointSet", () => {
+  it("should throw error when trying to union and check not existing sets", () => {
     function mergeNotExistingSets() {
       const disjointSet = new DisjointSet();
 
-      disjointSet.union('A', 'B');
+      disjointSet.union("A", "B");
     }
 
     function checkNotExistingSets() {
       const disjointSet = new DisjointSet();
 
-      disjointSet.inSameSet('A', 'B');
+      disjointSet.inSameSet("A", "B");
     }
 
     expect(mergeNotExistingSets).toThrow();
     expect(checkNotExistingSets).toThrow();
   });
 
-  it('should do basic manipulations on disjoint set', () => {
+  it("should do basic manipulations on disjoint set", () => {
     const disjointSet = new DisjointSet();
 
-    expect(disjointSet.find('A')).toBeNull();
-    expect(disjointSet.find('B')).toBeNull();
+    expect(disjointSet.find("A")).toBeNull();
+    expect(disjointSet.find("B")).toBeNull();
 
-    disjointSet.makeSet('A');
+    disjointSet.makeSet("A");
 
-    expect(disjointSet.find('A')).toBe('A');
-    expect(disjointSet.find('B')).toBeNull();
+    expect(disjointSet.find("A")).toBe("A");
+    expect(disjointSet.find("B")).toBeNull();
 
-    disjointSet.makeSet('B');
+    disjointSet.makeSet("B");
 
-    expect(disjointSet.find('A')).toBe('A');
-    expect(disjointSet.find('B')).toBe('B');
+    expect(disjointSet.find("A")).toBe("A");
+    expect(disjointSet.find("B")).toBe("B");
 
-    disjointSet.makeSet('C');
+    disjointSet.makeSet("C");
 
-    expect(disjointSet.inSameSet('A', 'B')).toBe(false);
+    expect(disjointSet.inSameSet("A", "B")).toBe(false);
 
-    disjointSet.union('A', 'B');
+    disjointSet.union("A", "B");
 
-    expect(disjointSet.find('A')).toBe('A');
-    expect(disjointSet.find('B')).toBe('A');
-    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
-    expect(disjointSet.inSameSet('B', 'A')).toBe(true);
-    expect(disjointSet.inSameSet('A', 'C')).toBe(false);
+    expect(disjointSet.find("A")).toBe("A");
+    expect(disjointSet.find("B")).toBe("A");
+    expect(disjointSet.inSameSet("A", "B")).toBe(true);
+    expect(disjointSet.inSameSet("B", "A")).toBe(true);
+    expect(disjointSet.inSameSet("A", "C")).toBe(false);
 
-    disjointSet.union('A', 'A');
+    disjointSet.union("A", "A");
 
-    disjointSet.union('B', 'C');
+    disjointSet.union("B", "C");
 
-    expect(disjointSet.find('A')).toBe('A');
-    expect(disjointSet.find('B')).toBe('A');
-    expect(disjointSet.find('C')).toBe('A');
+    expect(disjointSet.find("A")).toBe("A");
+    expect(disjointSet.find("B")).toBe("A");
+    expect(disjointSet.find("C")).toBe("A");
 
-    expect(disjointSet.inSameSet('A', 'B')).toBe(true);
-    expect(disjointSet.inSameSet('B', 'C')).toBe(true);
-    expect(disjointSet.inSameSet('A', 'C')).toBe(true);
+    expect(disjointSet.inSameSet("A", "B")).toBe(true);
+    expect(disjointSet.inSameSet("B", "C")).toBe(true);
+    expect(disjointSet.inSameSet("A", "C")).toBe(true);
 
     disjointSet
-      .makeSet('E')
-      .makeSet('F')
-      .makeSet('G')
-      .makeSet('H')
-      .makeSet('I');
+      .makeSet("E")
+      .makeSet("F")
+      .makeSet("G")
+      .makeSet("H")
+      .makeSet("I");
 
-    disjointSet
-      .union('E', 'F')
-      .union('F', 'G')
-      .union('G', 'H')
-      .union('H', 'I');
+    disjointSet.union("E", "F").union("F", "G").union("G", "H").union("H", "I");
 
-    expect(disjointSet.inSameSet('A', 'I')).toBe(false);
-    expect(disjointSet.inSameSet('E', 'I')).toBe(true);
+    expect(disjointSet.inSameSet("A", "I")).toBe(false);
+    expect(disjointSet.inSameSet("E", "I")).toBe(true);
 
-    disjointSet.union('I', 'C');
+    disjointSet.union("I", "C");
 
-    expect(disjointSet.find('I')).toBe('E');
-    expect(disjointSet.inSameSet('A', 'I')).toBe(true);
+    expect(disjointSet.find("I")).toBe("E");
+    expect(disjointSet.inSameSet("A", "I")).toBe(true);
   });
 
-  it('should union smaller set with bigger one making bigger one to be new root', () => {
+  it("should union smaller set with bigger one making bigger one to be new root", () => {
     const disjointSet = new DisjointSet();
 
     disjointSet
-      .makeSet('A')
-      .makeSet('B')
-      .makeSet('C')
-      .union('B', 'C')
-      .union('A', 'C');
+      .makeSet("A")
+      .makeSet("B")
+      .makeSet("C")
+      .union("B", "C")
+      .union("A", "C");
 
-    expect(disjointSet.find('A')).toBe('B');
+    expect(disjointSet.find("A")).toBe("B");
   });
 
-  it('should do basic manipulations on disjoint set with custom key extractor', () => {
+  it("should do basic manipulations on disjoint set with custom key extractor", () => {
     const keyExtractor = (value) => value.key;
 
     const disjointSet = new DisjointSet(keyExtractor);
 
-    const itemA = { key: 'A', value: 1 };
-    const itemB = { key: 'B', value: 2 };
-    const itemC = { key: 'C', value: 3 };
+    const itemA = { key: "A", value: 1 };
+    const itemB = { key: "B", value: 2 };
+    const itemC = { key: "C", value: 3 };
 
     expect(disjointSet.find(itemA)).toBeNull();
     expect(disjointSet.find(itemB)).toBeNull();
 
     disjointSet.makeSet(itemA);
 
-    expect(disjointSet.find(itemA)).toBe('A');
+    expect(disjointSet.find(itemA)).toBe("A");
     expect(disjointSet.find(itemB)).toBeNull();
 
     disjointSet.makeSet(itemB);
 
-    expect(disjointSet.find(itemA)).toBe('A');
-    expect(disjointSet.find(itemB)).toBe('B');
+    expect(disjointSet.find(itemA)).toBe("A");
+    expect(disjointSet.find(itemB)).toBe("B");
 
     disjointSet.makeSet(itemC);
 
@@ -121,20 +117,21 @@ describe('DisjointSet', () => {
 
     disjointSet.union(itemA, itemB);
 
-    expect(disjointSet.find(itemA)).toBe('A');
-    expect(disjointSet.find(itemB)).toBe('A');
+    expect(disjointSet.find(itemA)).toBe("A");
+    expect(disjointSet.find(itemB)).toBe("A");
     expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
     expect(disjointSet.inSameSet(itemB, itemA)).toBe(true);
     expect(disjointSet.inSameSet(itemA, itemC)).toBe(false);
 
     disjointSet.union(itemA, itemC);
 
-    expect(disjointSet.find(itemA)).toBe('A');
-    expect(disjointSet.find(itemB)).toBe('A');
-    expect(disjointSet.find(itemC)).toBe('A');
+    expect(disjointSet.find(itemA)).toBe("A");
+    expect(disjointSet.find(itemB)).toBe("A");
+    expect(disjointSet.find(itemC)).toBe("A");
 
     expect(disjointSet.inSameSet(itemA, itemB)).toBe(true);
     expect(disjointSet.inSameSet(itemB, itemC)).toBe(true);
     expect(disjointSet.inSameSet(itemA, itemC)).toBe(true);
   });
 });
+
diff --git a/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js b/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js
index 8383093..85232db 100644
--- a/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js
+++ b/src/data-structures/disjoint-set/__test__/DisjointSetItem.test.js
@@ -1,15 +1,15 @@
-import DisjointSetItem from '../DisjointSetItem';
+import DisjointSetItem from "../DisjointSetItem";
 
-describe('DisjointSetItem', () => {
-  it('should do basic manipulation with disjoint set item', () => {
-    const itemA = new DisjointSetItem('A');
-    const itemB = new DisjointSetItem('B');
-    const itemC = new DisjointSetItem('C');
-    const itemD = new DisjointSetItem('D');
+describe("DisjointSetItem", () => {
+  it("should do basic manipulation with disjoint set item", () => {
+    const itemA = new DisjointSetItem("A");
+    const itemB = new DisjointSetItem("B");
+    const itemC = new DisjointSetItem("C");
+    const itemD = new DisjointSetItem("D");
 
     expect(itemA.getRank()).toBe(0);
     expect(itemA.getChildren()).toEqual([]);
-    expect(itemA.getKey()).toBe('A');
+    expect(itemA.getKey()).toBe("A");
     expect(itemA.getRoot()).toEqual(itemA);
     expect(itemA.isRoot()).toBe(true);
     expect(itemB.isRoot()).toBe(true);
@@ -55,19 +55,19 @@ describe('DisjointSetItem', () => {
     expect(itemC.getRank()).toEqual(1);
   });
 
-  it('should do basic manipulation with disjoint set item with custom key extractor', () => {
+  it("should do basic manipulation with disjoint set item with custom key extractor", () => {
     const keyExtractor = (value) => {
       return value.key;
     };
 
-    const itemA = new DisjointSetItem({ key: 'A', value: 1 }, keyExtractor);
-    const itemB = new DisjointSetItem({ key: 'B', value: 2 }, keyExtractor);
-    const itemC = new DisjointSetItem({ key: 'C', value: 3 }, keyExtractor);
-    const itemD = new DisjointSetItem({ key: 'D', value: 4 }, keyExtractor);
+    const itemA = new DisjointSetItem({ key: "A", value: 1 }, keyExtractor);
+    const itemB = new DisjointSetItem({ key: "B", value: 2 }, keyExtractor);
+    const itemC = new DisjointSetItem({ key: "C", value: 3 }, keyExtractor);
+    const itemD = new DisjointSetItem({ key: "D", value: 4 }, keyExtractor);
 
     expect(itemA.getRank()).toBe(0);
     expect(itemA.getChildren()).toEqual([]);
-    expect(itemA.getKey()).toBe('A');
+    expect(itemA.getKey()).toBe("A");
     expect(itemA.getRoot()).toEqual(itemA);
     expect(itemA.isRoot()).toBe(true);
     expect(itemB.isRoot()).toBe(true);
@@ -113,3 +113,4 @@ describe('DisjointSetItem', () => {
     expect(itemC.getRank()).toEqual(1);
   });
 });
+
diff --git a/src/data-structures/doubly-linked-list/DoublyLinkedList.js b/src/data-structures/doubly-linked-list/DoublyLinkedList.js
index 6c3306b..d7a55db 100644
--- a/src/data-structures/doubly-linked-list/DoublyLinkedList.js
+++ b/src/data-structures/doubly-linked-list/DoublyLinkedList.js
@@ -1,5 +1,5 @@
-import DoublyLinkedListNode from './DoublyLinkedListNode';
-import Comparator from '../../utils/comparator/Comparator';
+import DoublyLinkedListNode from "./DoublyLinkedListNode";
+import Comparator from "../../utils/comparator/Comparator";
 
 export default class DoublyLinkedList {
   /**
@@ -126,7 +126,11 @@ export default class DoublyLinkedList {
    * @param {function} [findParams.callback]
    * @return {DoublyLinkedListNode}
    */
-  find({ value = undefined, callback = undefined }) {
+  find(_ref) {
+    let _ref$value = _ref.value,
+      value = _ref$value === void 0 ? undefined : _ref$value,
+      _ref$callback = _ref.callback,
+      callback = _ref$callback === void 0 ? undefined : _ref$callback;
     if (!this.head) {
       return null;
     }
@@ -228,7 +232,9 @@ export default class DoublyLinkedList {
    * @return {string}
    */
   toString(callback) {
-    return this.toArray().map((node) => node.toString(callback)).toString();
+    return this.toArray()
+      .map((node) => node.toString(callback))
+      .toString();
   }
 
   /**
@@ -261,3 +267,4 @@ export default class DoublyLinkedList {
     return this;
   }
 }
+
diff --git a/src/data-structures/doubly-linked-list/DoublyLinkedListNode.js b/src/data-structures/doubly-linked-list/DoublyLinkedListNode.js
index 1c97bd2..696e727 100644
--- a/src/data-structures/doubly-linked-list/DoublyLinkedListNode.js
+++ b/src/data-structures/doubly-linked-list/DoublyLinkedListNode.js
@@ -1,5 +1,9 @@
 export default class DoublyLinkedListNode {
-  constructor(value, next = null, previous = null) {
+  constructor(value) {
+    let next =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
+    let previous =
+      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
     this.value = value;
     this.next = next;
     this.previous = previous;
@@ -9,3 +13,4 @@ export default class DoublyLinkedListNode {
     return callback ? callback(this.value) : `${this.value}`;
   }
 }
+
diff --git a/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js b/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js
index b6060d1..b747c08 100644
--- a/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js
+++ b/src/data-structures/doubly-linked-list/__test__/DoublyLinkedList.test.js
@@ -1,12 +1,12 @@
-import DoublyLinkedList from '../DoublyLinkedList';
+import DoublyLinkedList from "../DoublyLinkedList";
 
-describe('DoublyLinkedList', () => {
-  it('should create empty linked list', () => {
+describe("DoublyLinkedList", () => {
+  it("should create empty linked list", () => {
     const linkedList = new DoublyLinkedList();
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
   });
 
-  it('should append node to linked list', () => {
+  it("should append node to linked list", () => {
     const linkedList = new DoublyLinkedList();
 
     expect(linkedList.head).toBeNull();
@@ -17,15 +17,15 @@ describe('DoublyLinkedList', () => {
 
     expect(linkedList.head.next.value).toBe(2);
     expect(linkedList.tail.previous.value).toBe(1);
-    expect(linkedList.toString()).toBe('1,2');
+    expect(linkedList.toString()).toBe("1,2");
   });
 
-  it('should prepend node to linked list', () => {
+  it("should prepend node to linked list", () => {
     const linkedList = new DoublyLinkedList();
 
     linkedList.prepend(2);
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("2");
 
     linkedList.append(1);
     linkedList.prepend(3);
@@ -33,17 +33,17 @@ describe('DoublyLinkedList', () => {
     expect(linkedList.head.next.next.previous).toBe(linkedList.head.next);
     expect(linkedList.tail.previous.next).toBe(linkedList.tail);
     expect(linkedList.tail.previous.value).toBe(2);
-    expect(linkedList.toString()).toBe('3,2,1');
+    expect(linkedList.toString()).toBe("3,2,1");
   });
 
-  it('should create linked list from array', () => {
+  it("should create linked list from array", () => {
     const linkedList = new DoublyLinkedList();
     linkedList.fromArray([1, 1, 2, 3, 3, 3, 4, 5]);
 
-    expect(linkedList.toString()).toBe('1,1,2,3,3,3,4,5');
+    expect(linkedList.toString()).toBe("1,1,2,3,3,3,4,5");
   });
 
-  it('should delete node by value from linked list', () => {
+  it("should delete node by value from linked list", () => {
     const linkedList = new DoublyLinkedList();
 
     expect(linkedList.delete(5)).toBeNull();
@@ -57,43 +57,43 @@ describe('DoublyLinkedList', () => {
     linkedList.append(4);
     linkedList.append(5);
 
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('5');
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("5");
 
     const deletedNode = linkedList.delete(3);
     expect(deletedNode.value).toBe(3);
     expect(linkedList.tail.previous.previous.value).toBe(2);
-    expect(linkedList.toString()).toBe('1,1,2,4,5');
+    expect(linkedList.toString()).toBe("1,1,2,4,5");
 
     linkedList.delete(3);
-    expect(linkedList.toString()).toBe('1,1,2,4,5');
+    expect(linkedList.toString()).toBe("1,1,2,4,5");
 
     linkedList.delete(1);
-    expect(linkedList.toString()).toBe('2,4,5');
+    expect(linkedList.toString()).toBe("2,4,5");
 
-    expect(linkedList.head.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("2");
     expect(linkedList.head.next.next).toBe(linkedList.tail);
     expect(linkedList.tail.previous.previous).toBe(linkedList.head);
-    expect(linkedList.tail.toString()).toBe('5');
+    expect(linkedList.tail.toString()).toBe("5");
 
     linkedList.delete(5);
-    expect(linkedList.toString()).toBe('2,4');
+    expect(linkedList.toString()).toBe("2,4");
 
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('4');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("4");
 
     linkedList.delete(4);
-    expect(linkedList.toString()).toBe('2');
+    expect(linkedList.toString()).toBe("2");
 
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("2");
     expect(linkedList.head).toBe(linkedList.tail);
 
     linkedList.delete(2);
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
   });
 
-  it('should delete linked list tail', () => {
+  it("should delete linked list tail", () => {
     const linkedList = new DoublyLinkedList();
 
     expect(linkedList.deleteTail()).toBeNull();
@@ -102,32 +102,32 @@ describe('DoublyLinkedList', () => {
     linkedList.append(2);
     linkedList.append(3);
 
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('3');
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("3");
 
     const deletedNode1 = linkedList.deleteTail();
 
     expect(deletedNode1.value).toBe(3);
-    expect(linkedList.toString()).toBe('1,2');
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.toString()).toBe("1,2");
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("2");
 
     const deletedNode2 = linkedList.deleteTail();
 
     expect(deletedNode2.value).toBe(2);
-    expect(linkedList.toString()).toBe('1');
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('1');
+    expect(linkedList.toString()).toBe("1");
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("1");
 
     const deletedNode3 = linkedList.deleteTail();
 
     expect(deletedNode3.value).toBe(1);
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
     expect(linkedList.head).toBeNull();
     expect(linkedList.tail).toBeNull();
   });
 
-  it('should delete linked list head', () => {
+  it("should delete linked list head", () => {
     const linkedList = new DoublyLinkedList();
 
     expect(linkedList.deleteHead()).toBeNull();
@@ -135,41 +135,39 @@ describe('DoublyLinkedList', () => {
     linkedList.append(1);
     linkedList.append(2);
 
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("2");
 
     const deletedNode1 = linkedList.deleteHead();
 
     expect(deletedNode1.value).toBe(1);
     expect(linkedList.head.previous).toBeNull();
-    expect(linkedList.toString()).toBe('2');
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.toString()).toBe("2");
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("2");
 
     const deletedNode2 = linkedList.deleteHead();
 
     expect(deletedNode2.value).toBe(2);
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
     expect(linkedList.head).toBeNull();
     expect(linkedList.tail).toBeNull();
   });
 
-  it('should be possible to store objects in the list and to print them out', () => {
+  it("should be possible to store objects in the list and to print them out", () => {
     const linkedList = new DoublyLinkedList();
 
-    const nodeValue1 = { value: 1, key: 'key1' };
-    const nodeValue2 = { value: 2, key: 'key2' };
+    const nodeValue1 = { value: 1, key: "key1" };
+    const nodeValue2 = { value: 2, key: "key2" };
 
-    linkedList
-      .append(nodeValue1)
-      .prepend(nodeValue2);
+    linkedList.append(nodeValue1).prepend(nodeValue2);
 
     const nodeStringifier = (value) => `${value.key}:${value.value}`;
 
-    expect(linkedList.toString(nodeStringifier)).toBe('key2:2,key1:1');
+    expect(linkedList.toString(nodeStringifier)).toBe("key2:2,key1:1");
   });
 
-  it('should find node by value', () => {
+  it("should find node by value", () => {
     const linkedList = new DoublyLinkedList();
 
     expect(linkedList.find({ value: 5 })).toBeNull();
@@ -177,9 +175,7 @@ describe('DoublyLinkedList', () => {
     linkedList.append(1);
     expect(linkedList.find({ value: 1 })).toBeDefined();
 
-    linkedList
-      .append(2)
-      .append(3);
+    linkedList.append(2).append(3);
 
     const node = linkedList.find({ value: 2 });
 
@@ -187,23 +183,27 @@ describe('DoublyLinkedList', () => {
     expect(linkedList.find({ value: 5 })).toBeNull();
   });
 
-  it('should find node by callback', () => {
+  it("should find node by callback", () => {
     const linkedList = new DoublyLinkedList();
 
     linkedList
-      .append({ value: 1, key: 'test1' })
-      .append({ value: 2, key: 'test2' })
-      .append({ value: 3, key: 'test3' });
+      .append({ value: 1, key: "test1" })
+      .append({ value: 2, key: "test2" })
+      .append({ value: 3, key: "test3" });
 
-    const node = linkedList.find({ callback: (value) => value.key === 'test2' });
+    const node = linkedList.find({
+      callback: (value) => value.key === "test2",
+    });
 
     expect(node).toBeDefined();
     expect(node.value.value).toBe(2);
-    expect(node.value.key).toBe('test2');
-    expect(linkedList.find({ callback: (value) => value.key === 'test5' })).toBeNull();
+    expect(node.value.key).toBe("test2");
+    expect(
+      linkedList.find({ callback: (value) => value.key === "test5" })
+    ).toBeNull();
   });
 
-  it('should find node by means of custom compare function', () => {
+  it("should find node by means of custom compare function", () => {
     const comparatorFunction = (a, b) => {
       if (a.customValue === b.customValue) {
         return 0;
@@ -215,38 +215,34 @@ describe('DoublyLinkedList', () => {
     const linkedList = new DoublyLinkedList(comparatorFunction);
 
     linkedList
-      .append({ value: 1, customValue: 'test1' })
-      .append({ value: 2, customValue: 'test2' })
-      .append({ value: 3, customValue: 'test3' });
+      .append({ value: 1, customValue: "test1" })
+      .append({ value: 2, customValue: "test2" })
+      .append({ value: 3, customValue: "test3" });
 
     const node = linkedList.find({
-      value: { value: 2, customValue: 'test2' },
+      value: { value: 2, customValue: "test2" },
     });
 
     expect(node).toBeDefined();
     expect(node.value.value).toBe(2);
-    expect(node.value.customValue).toBe('test2');
-    expect(linkedList.find({ value: 2, customValue: 'test5' })).toBeNull();
+    expect(node.value.customValue).toBe("test2");
+    expect(linkedList.find({ value: 2, customValue: "test5" })).toBeNull();
   });
 
-  it('should reverse linked list', () => {
+  it("should reverse linked list", () => {
     const linkedList = new DoublyLinkedList();
 
     // Add test values to linked list.
-    linkedList
-      .append(1)
-      .append(2)
-      .append(3)
-      .append(4);
+    linkedList.append(1).append(2).append(3).append(4);
 
-    expect(linkedList.toString()).toBe('1,2,3,4');
+    expect(linkedList.toString()).toBe("1,2,3,4");
     expect(linkedList.head.value).toBe(1);
     expect(linkedList.tail.value).toBe(4);
 
     // Reverse linked list.
     linkedList.reverse();
 
-    expect(linkedList.toString()).toBe('4,3,2,1');
+    expect(linkedList.toString()).toBe("4,3,2,1");
 
     expect(linkedList.head.previous).toBeNull();
     expect(linkedList.head.value).toBe(4);
@@ -263,7 +259,7 @@ describe('DoublyLinkedList', () => {
     // Reverse linked list back to initial state.
     linkedList.reverse();
 
-    expect(linkedList.toString()).toBe('1,2,3,4');
+    expect(linkedList.toString()).toBe("1,2,3,4");
 
     expect(linkedList.head.previous).toBeNull();
     expect(linkedList.head.value).toBe(1);
@@ -278,3 +274,4 @@ describe('DoublyLinkedList', () => {
     expect(linkedList.tail.previous.previous.previous.value).toBe(1);
   });
 });
+
diff --git a/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js b/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js
index fdcf65a..bfffc4a 100644
--- a/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js
+++ b/src/data-structures/doubly-linked-list/__test__/DoublyLinkedListNode.test.js
@@ -1,7 +1,7 @@
-import DoublyLinkedListNode from '../DoublyLinkedListNode';
+import DoublyLinkedListNode from "../DoublyLinkedListNode";
 
-describe('DoublyLinkedListNode', () => {
-  it('should create list node with value', () => {
+describe("DoublyLinkedListNode", () => {
+  it("should create list node with value", () => {
     const node = new DoublyLinkedListNode(1);
 
     expect(node.value).toBe(1);
@@ -9,17 +9,17 @@ describe('DoublyLinkedListNode', () => {
     expect(node.previous).toBeNull();
   });
 
-  it('should create list node with object as a value', () => {
-    const nodeValue = { value: 1, key: 'test' };
+  it("should create list node with object as a value", () => {
+    const nodeValue = { value: 1, key: "test" };
     const node = new DoublyLinkedListNode(nodeValue);
 
     expect(node.value.value).toBe(1);
-    expect(node.value.key).toBe('test');
+    expect(node.value.key).toBe("test");
     expect(node.next).toBeNull();
     expect(node.previous).toBeNull();
   });
 
-  it('should link nodes together', () => {
+  it("should link nodes together", () => {
     const node2 = new DoublyLinkedListNode(2);
     const node1 = new DoublyLinkedListNode(1, node2);
     const node3 = new DoublyLinkedListNode(10, node1, node2);
@@ -36,20 +36,22 @@ describe('DoublyLinkedListNode', () => {
     expect(node3.previous.value).toBe(2);
   });
 
-  it('should convert node to string', () => {
+  it("should convert node to string", () => {
     const node = new DoublyLinkedListNode(1);
 
-    expect(node.toString()).toBe('1');
+    expect(node.toString()).toBe("1");
 
-    node.value = 'string value';
-    expect(node.toString()).toBe('string value');
+    node.value = "string value";
+    expect(node.toString()).toBe("string value");
   });
 
-  it('should convert node to string with custom stringifier', () => {
-    const nodeValue = { value: 1, key: 'test' };
+  it("should convert node to string with custom stringifier", () => {
+    const nodeValue = { value: 1, key: "test" };
     const node = new DoublyLinkedListNode(nodeValue);
-    const toStringCallback = (value) => `value: ${value.value}, key: ${value.key}`;
+    const toStringCallback = (value) =>
+      `value: ${value.value}, key: ${value.key}`;
 
-    expect(node.toString(toStringCallback)).toBe('value: 1, key: test');
+    expect(node.toString(toStringCallback)).toBe("value: 1, key: test");
   });
 });
+
diff --git a/src/data-structures/graph/Graph.js b/src/data-structures/graph/Graph.js
index ba0b6d0..55e1915 100644
--- a/src/data-structures/graph/Graph.js
+++ b/src/data-structures/graph/Graph.js
@@ -2,7 +2,9 @@ export default class Graph {
   /**
    * @param {boolean} isDirected
    */
-  constructor(isDirected = false) {
+  constructor() {
+    let isDirected =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
     this.vertices = {};
     this.edges = {};
     this.isDirected = isDirected;
@@ -71,7 +73,7 @@ export default class Graph {
 
     // Check if edge has been already added.
     if (this.edges[edge.getKey()]) {
-      throw new Error('Edge has already been added before');
+      throw new Error("Edge has already been added before");
     } else {
       this.edges[edge.getKey()] = edge;
     }
@@ -97,7 +99,7 @@ export default class Graph {
     if (this.edges[edge.getKey()]) {
       delete this.edges[edge.getKey()];
     } else {
-      throw new Error('Edge not found in graph');
+      throw new Error("Edge not found in graph");
     }
 
     // Try to find and end start vertices and delete edge from them.
@@ -173,15 +175,20 @@ export default class Graph {
 
     // Init matrix with infinities meaning that there is no ways of
     // getting from one vertex to another yet.
-    const adjacencyMatrix = Array(vertices.length).fill(null).map(() => {
-      return Array(vertices.length).fill(Infinity);
-    });
+    const adjacencyMatrix = Array(vertices.length)
+      .fill(null)
+      .map(() => {
+        return Array(vertices.length).fill(Infinity);
+      });
 
     // Fill the columns.
     vertices.forEach((vertex, vertexIndex) => {
       vertex.getNeighbors().forEach((neighbor) => {
         const neighborIndex = verticesIndices[neighbor.getKey()];
-        adjacencyMatrix[vertexIndex][neighborIndex] = this.findEdge(vertex, neighbor).weight;
+        adjacencyMatrix[vertexIndex][neighborIndex] = this.findEdge(
+          vertex,
+          neighbor
+        ).weight;
       });
     });
 
@@ -195,3 +202,4 @@ export default class Graph {
     return Object.keys(this.vertices).toString();
   }
 }
+
diff --git a/src/data-structures/graph/GraphEdge.js b/src/data-structures/graph/GraphEdge.js
index 9a5b5db..5ff2b42 100644
--- a/src/data-structures/graph/GraphEdge.js
+++ b/src/data-structures/graph/GraphEdge.js
@@ -4,7 +4,9 @@ export default class GraphEdge {
    * @param {GraphVertex} endVertex
    * @param {number} [weight=1]
    */
-  constructor(startVertex, endVertex, weight = 0) {
+  constructor(startVertex, endVertex) {
+    let weight =
+      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
     this.startVertex = startVertex;
     this.endVertex = endVertex;
     this.weight = weight;
@@ -38,3 +40,4 @@ export default class GraphEdge {
     return this.getKey();
   }
 }
+
diff --git a/src/data-structures/graph/GraphVertex.js b/src/data-structures/graph/GraphVertex.js
index f11dd2c..df66346 100644
--- a/src/data-structures/graph/GraphVertex.js
+++ b/src/data-structures/graph/GraphVertex.js
@@ -1,4 +1,4 @@
-import LinkedList from '../linked-list/LinkedList';
+import LinkedList from "../linked-list/LinkedList";
 
 export default class GraphVertex {
   /**
@@ -6,7 +6,7 @@ export default class GraphVertex {
    */
   constructor(value) {
     if (value === undefined) {
-      throw new Error('Graph vertex must have a value');
+      throw new Error("Graph vertex must have a value");
     }
 
     /**
@@ -52,7 +52,9 @@ export default class GraphVertex {
 
     /** @param {LinkedListNode} node */
     const neighborsConverter = (node) => {
-      return node.value.startVertex === this ? node.value.endVertex : node.value.startVertex;
+      return node.value.startVertex === this
+        ? node.value.endVertex
+        : node.value.startVertex;
     };
 
     // Return either start or end vertex.
@@ -92,7 +94,8 @@ export default class GraphVertex {
    */
   hasNeighbor(vertex) {
     const vertexNode = this.edges.find({
-      callback: (edge) => edge.startVertex === vertex || edge.endVertex === vertex,
+      callback: (edge) =>
+        edge.startVertex === vertex || edge.endVertex === vertex,
     });
 
     return !!vertexNode;
@@ -136,3 +139,4 @@ export default class GraphVertex {
     return callback ? callback(this.value) : `${this.value}`;
   }
 }
+
diff --git a/src/data-structures/graph/__test__/Graph.test.js b/src/data-structures/graph/__test__/Graph.test.js
index 936a69b..e468ad1 100644
--- a/src/data-structures/graph/__test__/Graph.test.js
+++ b/src/data-structures/graph/__test__/Graph.test.js
@@ -1,28 +1,26 @@
-import Graph from '../Graph';
-import GraphVertex from '../GraphVertex';
-import GraphEdge from '../GraphEdge';
+import Graph from "../Graph";
+import GraphVertex from "../GraphVertex";
+import GraphEdge from "../GraphEdge";
 
-describe('Graph', () => {
-  it('should add vertices to graph', () => {
+describe("Graph", () => {
+  it("should add vertices to graph", () => {
     const graph = new Graph();
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
 
-    graph
-      .addVertex(vertexA)
-      .addVertex(vertexB);
+    graph.addVertex(vertexA).addVertex(vertexB);
 
-    expect(graph.toString()).toBe('A,B');
+    expect(graph.toString()).toBe("A,B");
     expect(graph.getVertexByKey(vertexA.getKey())).toEqual(vertexA);
     expect(graph.getVertexByKey(vertexB.getKey())).toEqual(vertexB);
   });
 
-  it('should add edges to undirected graph', () => {
+  it("should add edges to undirected graph", () => {
     const graph = new Graph();
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
 
@@ -35,11 +33,11 @@ describe('Graph', () => {
     const graphVertexA = graph.getVertexByKey(vertexA.getKey());
     const graphVertexB = graph.getVertexByKey(vertexB.getKey());
 
-    expect(graph.toString()).toBe('A,B');
+    expect(graph.toString()).toBe("A,B");
     expect(graphVertexA).toBeDefined();
     expect(graphVertexB).toBeDefined();
 
-    expect(graph.getVertexByKey('not existing')).toBeUndefined();
+    expect(graph.getVertexByKey("not existing")).toBeUndefined();
 
     expect(graphVertexA.getNeighbors().length).toBe(1);
     expect(graphVertexA.getNeighbors()[0]).toEqual(vertexB);
@@ -50,11 +48,11 @@ describe('Graph', () => {
     expect(graphVertexB.getNeighbors()[0]).toEqual(graphVertexA);
   });
 
-  it('should add edges to directed graph', () => {
+  it("should add edges to directed graph", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
 
@@ -63,7 +61,7 @@ describe('Graph', () => {
     const graphVertexA = graph.getVertexByKey(vertexA.getKey());
     const graphVertexB = graph.getVertexByKey(vertexB.getKey());
 
-    expect(graph.toString()).toBe('A,B');
+    expect(graph.toString()).toBe("A,B");
     expect(graphVertexA).toBeDefined();
     expect(graphVertexB).toBeDefined();
 
@@ -74,12 +72,12 @@ describe('Graph', () => {
     expect(graphVertexB.getNeighbors().length).toBe(0);
   });
 
-  it('should find edge by vertices in undirected graph', () => {
+  it("should find edge by vertices in undirected graph", () => {
     const graph = new Graph();
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 10);
 
@@ -97,12 +95,12 @@ describe('Graph', () => {
     expect(graphEdgeAB.weight).toBe(10);
   });
 
-  it('should find edge by vertices in directed graph', () => {
+  it("should find edge by vertices in directed graph", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 10);
 
@@ -120,19 +118,17 @@ describe('Graph', () => {
     expect(graphEdgeAB.weight).toBe(10);
   });
 
-  it('should return vertex neighbors', () => {
+  it("should return vertex neighbors", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeAC);
+    graph.addEdge(edgeAB).addEdge(edgeAC);
 
     const neighbors = graph.getNeighbors(vertexA);
 
@@ -141,36 +137,32 @@ describe('Graph', () => {
     expect(neighbors[1]).toEqual(vertexC);
   });
 
-  it('should throw an error when trying to add edge twice', () => {
+  it("should throw an error when trying to add edge twice", () => {
     function addSameEdgeTwice() {
       const graph = new Graph(true);
 
-      const vertexA = new GraphVertex('A');
-      const vertexB = new GraphVertex('B');
+      const vertexA = new GraphVertex("A");
+      const vertexB = new GraphVertex("B");
 
       const edgeAB = new GraphEdge(vertexA, vertexB);
 
-      graph
-        .addEdge(edgeAB)
-        .addEdge(edgeAB);
+      graph.addEdge(edgeAB).addEdge(edgeAB);
     }
 
     expect(addSameEdgeTwice).toThrow();
   });
 
-  it('should return the list of all added edges', () => {
+  it("should return the list of all added edges", () => {
     const graph = new Graph(true);
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC);
+    graph.addEdge(edgeAB).addEdge(edgeBC);
 
     const edges = graph.getAllEdges();
 
@@ -179,65 +171,54 @@ describe('Graph', () => {
     expect(edges[1]).toEqual(edgeBC);
   });
 
-  it('should calculate total graph weight for default graph', () => {
+  it("should calculate total graph weight for default graph", () => {
     const graph = new Graph();
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
     const edgeCD = new GraphEdge(vertexC, vertexD);
     const edgeAD = new GraphEdge(vertexA, vertexD);
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD)
-      .addEdge(edgeAD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD).addEdge(edgeAD);
 
     expect(graph.getWeight()).toBe(0);
   });
 
-  it('should calculate total graph weight for weighted graph', () => {
+  it("should calculate total graph weight for weighted graph", () => {
     const graph = new Graph();
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 1);
     const edgeBC = new GraphEdge(vertexB, vertexC, 2);
     const edgeCD = new GraphEdge(vertexC, vertexD, 3);
     const edgeAD = new GraphEdge(vertexA, vertexD, 4);
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD)
-      .addEdge(edgeAD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD).addEdge(edgeAD);
 
     expect(graph.getWeight()).toBe(10);
   });
 
-  it('should be possible to delete edges from graph', () => {
+  it("should be possible to delete edges from graph", () => {
     const graph = new Graph();
 
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
     const edgeAC = new GraphEdge(vertexA, vertexC);
 
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeAC);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeAC);
 
     expect(graph.getAllEdges().length).toBe(3);
 
@@ -248,13 +229,13 @@ describe('Graph', () => {
     expect(graph.getAllEdges()[1].getKey()).toBe(edgeAC.getKey());
   });
 
-  it('should should throw an error when trying to delete not existing edge', () => {
+  it("should should throw an error when trying to delete not existing edge", () => {
     function deleteNotExistingEdge() {
       const graph = new Graph();
 
-      const vertexA = new GraphVertex('A');
-      const vertexB = new GraphVertex('B');
-      const vertexC = new GraphVertex('C');
+      const vertexA = new GraphVertex("A");
+      const vertexB = new GraphVertex("B");
+      const vertexC = new GraphVertex("C");
 
       const edgeAB = new GraphEdge(vertexA, vertexB);
       const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -266,23 +247,20 @@ describe('Graph', () => {
     expect(deleteNotExistingEdge).toThrowError();
   });
 
-  it('should be possible to reverse graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should be possible to reverse graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
     const edgeCD = new GraphEdge(vertexC, vertexD);
 
     const graph = new Graph(true);
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeAC)
-      .addEdge(edgeCD);
+    graph.addEdge(edgeAB).addEdge(edgeAC).addEdge(edgeCD);
 
-    expect(graph.toString()).toBe('A,B,C,D');
+    expect(graph.toString()).toBe("A,B,C,D");
     expect(graph.getAllEdges().length).toBe(3);
     expect(graph.getNeighbors(vertexA).length).toBe(2);
     expect(graph.getNeighbors(vertexA)[0].getKey()).toBe(vertexB.getKey());
@@ -294,7 +272,7 @@ describe('Graph', () => {
 
     graph.reverse();
 
-    expect(graph.toString()).toBe('A,B,C,D');
+    expect(graph.toString()).toBe("A,B,C,D");
     expect(graph.getAllEdges().length).toBe(3);
     expect(graph.getNeighbors(vertexA).length).toBe(0);
     expect(graph.getNeighbors(vertexB).length).toBe(1);
@@ -305,11 +283,11 @@ describe('Graph', () => {
     expect(graph.getNeighbors(vertexD)[0].getKey()).toBe(vertexC.getKey());
   });
 
-  it('should return vertices indices', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should return vertices indices", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -317,11 +295,7 @@ describe('Graph', () => {
     const edgeBD = new GraphEdge(vertexB, vertexD);
 
     const graph = new Graph();
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD)
-      .addEdge(edgeBD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD).addEdge(edgeBD);
 
     const verticesIndices = graph.getVerticesIndices();
     expect(verticesIndices).toEqual({
@@ -332,11 +306,11 @@ describe('Graph', () => {
     });
   });
 
-  it('should generate adjacency matrix for undirected graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should generate adjacency matrix for undirected graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeBC = new GraphEdge(vertexB, vertexC);
@@ -344,11 +318,7 @@ describe('Graph', () => {
     const edgeBD = new GraphEdge(vertexB, vertexD);
 
     const graph = new Graph();
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD)
-      .addEdge(edgeBD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD).addEdge(edgeBD);
 
     const adjacencyMatrix = graph.getAdjacencyMatrix();
     expect(adjacencyMatrix).toEqual([
@@ -359,11 +329,11 @@ describe('Graph', () => {
     ]);
   });
 
-  it('should generate adjacency matrix for directed graph', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
-    const vertexD = new GraphVertex('D');
+  it("should generate adjacency matrix for directed graph", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
+    const vertexD = new GraphVertex("D");
 
     const edgeAB = new GraphEdge(vertexA, vertexB, 2);
     const edgeBC = new GraphEdge(vertexB, vertexC, 1);
@@ -371,11 +341,7 @@ describe('Graph', () => {
     const edgeBD = new GraphEdge(vertexB, vertexD, 7);
 
     const graph = new Graph(true);
-    graph
-      .addEdge(edgeAB)
-      .addEdge(edgeBC)
-      .addEdge(edgeCD)
-      .addEdge(edgeBD);
+    graph.addEdge(edgeAB).addEdge(edgeBC).addEdge(edgeCD).addEdge(edgeBD);
 
     const adjacencyMatrix = graph.getAdjacencyMatrix();
     expect(adjacencyMatrix).toEqual([
@@ -386,3 +352,4 @@ describe('Graph', () => {
     ]);
   });
 });
+
diff --git a/src/data-structures/graph/__test__/GraphEdge.test.js b/src/data-structures/graph/__test__/GraphEdge.test.js
index ceb84ab..6ecdfe5 100644
--- a/src/data-structures/graph/__test__/GraphEdge.test.js
+++ b/src/data-structures/graph/__test__/GraphEdge.test.js
@@ -1,22 +1,22 @@
-import GraphEdge from '../GraphEdge';
-import GraphVertex from '../GraphVertex';
+import GraphEdge from "../GraphEdge";
+import GraphVertex from "../GraphVertex";
 
-describe('GraphEdge', () => {
-  it('should create graph edge with default weight', () => {
-    const startVertex = new GraphVertex('A');
-    const endVertex = new GraphVertex('B');
+describe("GraphEdge", () => {
+  it("should create graph edge with default weight", () => {
+    const startVertex = new GraphVertex("A");
+    const endVertex = new GraphVertex("B");
     const edge = new GraphEdge(startVertex, endVertex);
 
-    expect(edge.getKey()).toBe('A_B');
-    expect(edge.toString()).toBe('A_B');
+    expect(edge.getKey()).toBe("A_B");
+    expect(edge.toString()).toBe("A_B");
     expect(edge.startVertex).toEqual(startVertex);
     expect(edge.endVertex).toEqual(endVertex);
     expect(edge.weight).toEqual(0);
   });
 
-  it('should create graph edge with predefined weight', () => {
-    const startVertex = new GraphVertex('A');
-    const endVertex = new GraphVertex('B');
+  it("should create graph edge with predefined weight", () => {
+    const startVertex = new GraphVertex("A");
+    const endVertex = new GraphVertex("B");
     const edge = new GraphEdge(startVertex, endVertex, 10);
 
     expect(edge.startVertex).toEqual(startVertex);
@@ -24,9 +24,9 @@ describe('GraphEdge', () => {
     expect(edge.weight).toEqual(10);
   });
 
-  it('should be possible to do edge reverse', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
+  it("should be possible to do edge reverse", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
     const edge = new GraphEdge(vertexA, vertexB, 10);
 
     expect(edge.startVertex).toEqual(vertexA);
@@ -40,3 +40,4 @@ describe('GraphEdge', () => {
     expect(edge.weight).toEqual(10);
   });
 });
+
diff --git a/src/data-structures/graph/__test__/GraphVertex.test.js b/src/data-structures/graph/__test__/GraphVertex.test.js
index 4810a1c..3b40b1e 100644
--- a/src/data-structures/graph/__test__/GraphVertex.test.js
+++ b/src/data-structures/graph/__test__/GraphVertex.test.js
@@ -1,8 +1,8 @@
-import GraphVertex from '../GraphVertex';
-import GraphEdge from '../GraphEdge';
+import GraphVertex from "../GraphVertex";
+import GraphEdge from "../GraphEdge";
 
-describe('GraphVertex', () => {
-  it('should throw an error when trying to create vertex without value', () => {
+describe("GraphVertex", () => {
+  it("should throw an error when trying to create vertex without value", () => {
     let vertex = null;
 
     function createEmptyVertex() {
@@ -13,20 +13,20 @@ describe('GraphVertex', () => {
     expect(createEmptyVertex).toThrow();
   });
 
-  it('should create graph vertex', () => {
-    const vertex = new GraphVertex('A');
+  it("should create graph vertex", () => {
+    const vertex = new GraphVertex("A");
 
     expect(vertex).toBeDefined();
-    expect(vertex.value).toBe('A');
-    expect(vertex.toString()).toBe('A');
-    expect(vertex.getKey()).toBe('A');
-    expect(vertex.edges.toString()).toBe('');
+    expect(vertex.value).toBe("A");
+    expect(vertex.toString()).toBe("A");
+    expect(vertex.getKey()).toBe("A");
+    expect(vertex.edges.toString()).toBe("");
     expect(vertex.getEdges()).toEqual([]);
   });
 
-  it('should add edges to vertex and check if it exists', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
+  it("should add edges to vertex and check if it exists", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     vertexA.addEdge(edgeAB);
@@ -34,19 +34,17 @@ describe('GraphVertex', () => {
     expect(vertexA.hasEdge(edgeAB)).toBe(true);
     expect(vertexB.hasEdge(edgeAB)).toBe(false);
     expect(vertexA.getEdges().length).toBe(1);
-    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
+    expect(vertexA.getEdges()[0].toString()).toBe("A_B");
   });
 
-  it('should delete edges from vertex', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+  it("should delete edges from vertex", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
-    vertexA
-      .addEdge(edgeAB)
-      .addEdge(edgeAC);
+    vertexA.addEdge(edgeAB).addEdge(edgeAC);
 
     expect(vertexA.hasEdge(edgeAB)).toBe(true);
     expect(vertexB.hasEdge(edgeAB)).toBe(false);
@@ -56,13 +54,13 @@ describe('GraphVertex', () => {
 
     expect(vertexA.getEdges().length).toBe(2);
 
-    expect(vertexA.getEdges()[0].toString()).toBe('A_B');
-    expect(vertexA.getEdges()[1].toString()).toBe('A_C');
+    expect(vertexA.getEdges()[0].toString()).toBe("A_B");
+    expect(vertexA.getEdges()[1].toString()).toBe("A_C");
 
     vertexA.deleteEdge(edgeAB);
     expect(vertexA.hasEdge(edgeAB)).toBe(false);
     expect(vertexA.hasEdge(edgeAC)).toBe(true);
-    expect(vertexA.getEdges()[0].toString()).toBe('A_C');
+    expect(vertexA.getEdges()[0].toString()).toBe("A_C");
 
     vertexA.deleteEdge(edgeAC);
     expect(vertexA.hasEdge(edgeAB)).toBe(false);
@@ -70,16 +68,14 @@ describe('GraphVertex', () => {
     expect(vertexA.getEdges().length).toBe(0);
   });
 
-  it('should delete all edges from vertex', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+  it("should delete all edges from vertex", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
-    vertexA
-      .addEdge(edgeAB)
-      .addEdge(edgeAC);
+    vertexA.addEdge(edgeAB).addEdge(edgeAC);
 
     expect(vertexA.hasEdge(edgeAB)).toBe(true);
     expect(vertexB.hasEdge(edgeAB)).toBe(false);
@@ -100,16 +96,14 @@ describe('GraphVertex', () => {
     expect(vertexA.getEdges().length).toBe(0);
   });
 
-  it('should return vertex neighbors in case if current node is start one', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+  it("should return vertex neighbors in case if current node is start one", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     const edgeAC = new GraphEdge(vertexA, vertexC);
-    vertexA
-      .addEdge(edgeAB)
-      .addEdge(edgeAC);
+    vertexA.addEdge(edgeAB).addEdge(edgeAC);
 
     expect(vertexB.getNeighbors()).toEqual([]);
 
@@ -120,16 +114,14 @@ describe('GraphVertex', () => {
     expect(neighbors[1]).toEqual(vertexC);
   });
 
-  it('should return vertex neighbors in case if current node is end one', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+  it("should return vertex neighbors in case if current node is end one", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeBA = new GraphEdge(vertexB, vertexA);
     const edgeCA = new GraphEdge(vertexC, vertexA);
-    vertexA
-      .addEdge(edgeBA)
-      .addEdge(edgeCA);
+    vertexA.addEdge(edgeBA).addEdge(edgeCA);
 
     expect(vertexB.getNeighbors()).toEqual([]);
 
@@ -140,10 +132,10 @@ describe('GraphVertex', () => {
     expect(neighbors[1]).toEqual(vertexC);
   });
 
-  it('should check if vertex has specific neighbor', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+  it("should check if vertex has specific neighbor", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     vertexA.addEdge(edgeAB);
@@ -152,10 +144,10 @@ describe('GraphVertex', () => {
     expect(vertexA.hasNeighbor(vertexC)).toBe(false);
   });
 
-  it('should edge by vertex', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
-    const vertexC = new GraphVertex('C');
+  it("should edge by vertex", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
+    const vertexC = new GraphVertex("C");
 
     const edgeAB = new GraphEdge(vertexA, vertexB);
     vertexA.addEdge(edgeAB);
@@ -164,9 +156,9 @@ describe('GraphVertex', () => {
     expect(vertexA.findEdge(vertexC)).toBeNull();
   });
 
-  it('should calculate vertex degree', () => {
-    const vertexA = new GraphVertex('A');
-    const vertexB = new GraphVertex('B');
+  it("should calculate vertex degree", () => {
+    const vertexA = new GraphVertex("A");
+    const vertexB = new GraphVertex("B");
 
     expect(vertexA.getDegree()).toBe(0);
 
@@ -186,3 +178,4 @@ describe('GraphVertex', () => {
     expect(vertexA.getEdges().length).toEqual(3);
   });
 });
+
diff --git a/src/data-structures/hash-table/HashTable.js b/src/data-structures/hash-table/HashTable.js
index b8b523e..1cbc6ea 100644
--- a/src/data-structures/hash-table/HashTable.js
+++ b/src/data-structures/hash-table/HashTable.js
@@ -1,4 +1,4 @@
-import LinkedList from '../linked-list/LinkedList';
+import LinkedList from "../linked-list/LinkedList";
 
 // Hash table size directly affects on the number of collisions.
 // The bigger the hash table size the less collisions you'll get.
@@ -10,9 +10,15 @@ export default class HashTable {
   /**
    * @param {number} hashTableSize
    */
-  constructor(hashTableSize = defaultHashTableSize) {
+  constructor() {
+    let hashTableSize =
+      arguments.length > 0 && arguments[0] !== undefined
+        ? arguments[0]
+        : defaultHashTableSize;
     // Create hash table of certain size and fill each bucket with empty linked list.
-    this.buckets = Array(hashTableSize).fill(null).map(() => new LinkedList());
+    this.buckets = Array(hashTableSize)
+      .fill(null)
+      .map(() => new LinkedList());
 
     // Just to keep track of all actual keys in a fast way.
     this.keys = {};
@@ -36,8 +42,8 @@ export default class HashTable {
     // where charCodeAt(i) is the i-th character code of the key, n is the length of the key and
     // PRIME is just any prime number like 31.
     const hash = Array.from(key).reduce(
-      (hashAccumulator, keySymbol) => (hashAccumulator + keySymbol.charCodeAt(0)),
-      0,
+      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0),
+      0
     );
 
     // Reduce hash number so it would fit hash table size.
@@ -52,7 +58,9 @@ export default class HashTable {
     const keyHash = this.hash(key);
     this.keys[key] = keyHash;
     const bucketLinkedList = this.buckets[keyHash];
-    const node = bucketLinkedList.find({ callback: (nodeValue) => nodeValue.key === key });
+    const node = bucketLinkedList.find({
+      callback: (nodeValue) => nodeValue.key === key,
+    });
 
     if (!node) {
       // Insert new node.
@@ -71,7 +79,9 @@ export default class HashTable {
     const keyHash = this.hash(key);
     delete this.keys[key];
     const bucketLinkedList = this.buckets[keyHash];
-    const node = bucketLinkedList.find({ callback: (nodeValue) => nodeValue.key === key });
+    const node = bucketLinkedList.find({
+      callback: (nodeValue) => nodeValue.key === key,
+    });
 
     if (node) {
       return bucketLinkedList.delete(node.value);
@@ -86,7 +96,9 @@ export default class HashTable {
    */
   get(key) {
     const bucketLinkedList = this.buckets[this.hash(key)];
-    const node = bucketLinkedList.find({ callback: (nodeValue) => nodeValue.key === key });
+    const node = bucketLinkedList.find({
+      callback: (nodeValue) => nodeValue.key === key,
+    });
 
     return node ? node.value.value : undefined;
   }
@@ -113,9 +125,11 @@ export default class HashTable {
    */
   getValues() {
     return this.buckets.reduce((values, bucket) => {
-      const bucketValues = bucket.toArray()
+      const bucketValues = bucket
+        .toArray()
         .map((linkedListNode) => linkedListNode.value.value);
       return values.concat(bucketValues);
     }, []);
   }
 }
+
diff --git a/src/data-structures/hash-table/__test__/HashTable.test.js b/src/data-structures/hash-table/__test__/HashTable.test.js
index 86bbf3a..604445f 100644
--- a/src/data-structures/hash-table/__test__/HashTable.test.js
+++ b/src/data-structures/hash-table/__test__/HashTable.test.js
@@ -1,7 +1,7 @@
-import HashTable from '../HashTable';
+import HashTable from "../HashTable";
 
-describe('HashTable', () => {
-  it('should create hash table of certain size', () => {
+describe("HashTable", () => {
+  it("should create hash table of certain size", () => {
     const defaultHashTable = new HashTable();
     expect(defaultHashTable.buckets.length).toBe(32);
 
@@ -9,109 +9,110 @@ describe('HashTable', () => {
     expect(biggerHashTable.buckets.length).toBe(64);
   });
 
-  it('should generate proper hash for specified keys', () => {
+  it("should generate proper hash for specified keys", () => {
     const hashTable = new HashTable();
 
-    expect(hashTable.hash('a')).toBe(1);
-    expect(hashTable.hash('b')).toBe(2);
-    expect(hashTable.hash('abc')).toBe(6);
+    expect(hashTable.hash("a")).toBe(1);
+    expect(hashTable.hash("b")).toBe(2);
+    expect(hashTable.hash("abc")).toBe(6);
   });
 
-  it('should set, read and delete data with collisions', () => {
+  it("should set, read and delete data with collisions", () => {
     const hashTable = new HashTable(3);
 
-    expect(hashTable.hash('a')).toBe(1);
-    expect(hashTable.hash('b')).toBe(2);
-    expect(hashTable.hash('c')).toBe(0);
-    expect(hashTable.hash('d')).toBe(1);
+    expect(hashTable.hash("a")).toBe(1);
+    expect(hashTable.hash("b")).toBe(2);
+    expect(hashTable.hash("c")).toBe(0);
+    expect(hashTable.hash("d")).toBe(1);
 
-    hashTable.set('a', 'sky-old');
-    hashTable.set('a', 'sky');
-    hashTable.set('b', 'sea');
-    hashTable.set('c', 'earth');
-    hashTable.set('d', 'ocean');
+    hashTable.set("a", "sky-old");
+    hashTable.set("a", "sky");
+    hashTable.set("b", "sea");
+    hashTable.set("c", "earth");
+    hashTable.set("d", "ocean");
 
-    expect(hashTable.has('x')).toBe(false);
-    expect(hashTable.has('b')).toBe(true);
-    expect(hashTable.has('c')).toBe(true);
+    expect(hashTable.has("x")).toBe(false);
+    expect(hashTable.has("b")).toBe(true);
+    expect(hashTable.has("c")).toBe(true);
 
     const stringifier = (value) => `${value.key}:${value.value}`;
 
-    expect(hashTable.buckets[0].toString(stringifier)).toBe('c:earth');
-    expect(hashTable.buckets[1].toString(stringifier)).toBe('a:sky,d:ocean');
-    expect(hashTable.buckets[2].toString(stringifier)).toBe('b:sea');
+    expect(hashTable.buckets[0].toString(stringifier)).toBe("c:earth");
+    expect(hashTable.buckets[1].toString(stringifier)).toBe("a:sky,d:ocean");
+    expect(hashTable.buckets[2].toString(stringifier)).toBe("b:sea");
 
-    expect(hashTable.get('a')).toBe('sky');
-    expect(hashTable.get('d')).toBe('ocean');
-    expect(hashTable.get('x')).not.toBeDefined();
+    expect(hashTable.get("a")).toBe("sky");
+    expect(hashTable.get("d")).toBe("ocean");
+    expect(hashTable.get("x")).not.toBeDefined();
 
-    hashTable.delete('a');
+    hashTable.delete("a");
 
-    expect(hashTable.delete('not-existing')).toBeNull();
+    expect(hashTable.delete("not-existing")).toBeNull();
 
-    expect(hashTable.get('a')).not.toBeDefined();
-    expect(hashTable.get('d')).toBe('ocean');
+    expect(hashTable.get("a")).not.toBeDefined();
+    expect(hashTable.get("d")).toBe("ocean");
 
-    hashTable.set('d', 'ocean-new');
-    expect(hashTable.get('d')).toBe('ocean-new');
+    hashTable.set("d", "ocean-new");
+    expect(hashTable.get("d")).toBe("ocean-new");
   });
 
-  it('should be possible to add objects to hash table', () => {
+  it("should be possible to add objects to hash table", () => {
     const hashTable = new HashTable();
 
-    hashTable.set('objectKey', { prop1: 'a', prop2: 'b' });
+    hashTable.set("objectKey", { prop1: "a", prop2: "b" });
 
-    const object = hashTable.get('objectKey');
+    const object = hashTable.get("objectKey");
     expect(object).toBeDefined();
-    expect(object.prop1).toBe('a');
-    expect(object.prop2).toBe('b');
+    expect(object.prop1).toBe("a");
+    expect(object.prop2).toBe("b");
   });
 
-  it('should track actual keys', () => {
+  it("should track actual keys", () => {
     const hashTable = new HashTable(3);
 
-    hashTable.set('a', 'sky-old');
-    hashTable.set('a', 'sky');
-    hashTable.set('b', 'sea');
-    hashTable.set('c', 'earth');
-    hashTable.set('d', 'ocean');
+    hashTable.set("a", "sky-old");
+    hashTable.set("a", "sky");
+    hashTable.set("b", "sea");
+    hashTable.set("c", "earth");
+    hashTable.set("d", "ocean");
 
-    expect(hashTable.getKeys()).toEqual(['a', 'b', 'c', 'd']);
-    expect(hashTable.has('a')).toBe(true);
-    expect(hashTable.has('x')).toBe(false);
+    expect(hashTable.getKeys()).toEqual(["a", "b", "c", "d"]);
+    expect(hashTable.has("a")).toBe(true);
+    expect(hashTable.has("x")).toBe(false);
 
-    hashTable.delete('a');
+    hashTable.delete("a");
 
-    expect(hashTable.has('a')).toBe(false);
-    expect(hashTable.has('b')).toBe(true);
-    expect(hashTable.has('x')).toBe(false);
+    expect(hashTable.has("a")).toBe(false);
+    expect(hashTable.has("b")).toBe(true);
+    expect(hashTable.has("x")).toBe(false);
   });
 
-  it('should get all the values', () => {
+  it("should get all the values", () => {
     const hashTable = new HashTable(3);
 
-    hashTable.set('a', 'alpha');
-    hashTable.set('b', 'beta');
-    hashTable.set('c', 'gamma');
+    hashTable.set("a", "alpha");
+    hashTable.set("b", "beta");
+    hashTable.set("c", "gamma");
 
-    expect(hashTable.getValues()).toEqual(['gamma', 'alpha', 'beta']);
+    expect(hashTable.getValues()).toEqual(["gamma", "alpha", "beta"]);
   });
 
-  it('should get all the values from empty hash table', () => {
+  it("should get all the values from empty hash table", () => {
     const hashTable = new HashTable();
     expect(hashTable.getValues()).toEqual([]);
   });
 
-  it('should get all the values in case of hash collision', () => {
+  it("should get all the values in case of hash collision", () => {
     const hashTable = new HashTable(3);
 
     // Keys `ab` and `ba` in current implementation should result in one hash (one bucket).
     // We need to make sure that several items from one bucket will be serialized.
-    hashTable.set('ab', 'one');
-    hashTable.set('ba', 'two');
+    hashTable.set("ab", "one");
+    hashTable.set("ba", "two");
 
-    hashTable.set('ac', 'three');
+    hashTable.set("ac", "three");
 
-    expect(hashTable.getValues()).toEqual(['one', 'two', 'three']);
+    expect(hashTable.getValues()).toEqual(["one", "two", "three"]);
   });
 });
+
diff --git a/src/data-structures/heap/Heap.js b/src/data-structures/heap/Heap.js
index 45dfcfa..ced703f 100644
--- a/src/data-structures/heap/Heap.js
+++ b/src/data-structures/heap/Heap.js
@@ -1,4 +1,4 @@
-import Comparator from '../../utils/comparator/Comparator';
+import Comparator from "../../utils/comparator/Comparator";
 
 /**
  * Parent class for Min and Max Heaps.
@@ -10,7 +10,7 @@ export default class Heap {
    */
   constructor(comparatorFunction) {
     if (new.target === Heap) {
-      throw new TypeError('Cannot construct Heap instance directly');
+      throw new TypeError("Cannot construct Heap instance directly");
     }
 
     // Array representation of the heap.
@@ -23,7 +23,7 @@ export default class Heap {
    * @return {number}
    */
   getLeftChildIndex(parentIndex) {
-    return (2 * parentIndex) + 1;
+    return 2 * parentIndex + 1;
   }
 
   /**
@@ -31,7 +31,7 @@ export default class Heap {
    * @return {number}
    */
   getRightChildIndex(parentIndex) {
-    return (2 * parentIndex) + 2;
+    return 2 * parentIndex + 2;
   }
 
   /**
@@ -147,7 +147,11 @@ export default class Heap {
    * @param {Comparator} [comparator]
    * @return {Heap}
    */
-  remove(item, comparator = this.compare) {
+  remove(item) {
+    let comparator =
+      arguments.length > 1 && arguments[1] !== undefined
+        ? arguments[1]
+        : this.compare;
     // Find number of items to remove.
     const numberOfItemsToRemove = this.find(item, comparator).length;
 
@@ -158,7 +162,7 @@ export default class Heap {
 
       // If we need to remove last child in the heap then just remove it.
       // There is no need to heapify the heap afterwards.
-      if (indexToRemove === (this.heapContainer.length - 1)) {
+      if (indexToRemove === this.heapContainer.length - 1) {
         this.heapContainer.pop();
       } else {
         // Move last element in heap to the vacant (removed) position.
@@ -170,11 +174,12 @@ export default class Heap {
         // If there is no parent or parent is in correct order with the node
         // we're going to delete then heapify down. Otherwise heapify up.
         if (
-          this.hasLeftChild(indexToRemove)
-          && (
-            !parentItem
-            || this.pairIsInCorrectOrder(parentItem, this.heapContainer[indexToRemove])
-          )
+          this.hasLeftChild(indexToRemove) &&
+          (!parentItem ||
+            this.pairIsInCorrectOrder(
+              parentItem,
+              this.heapContainer[indexToRemove]
+            ))
         ) {
           this.heapifyDown(indexToRemove);
         } else {
@@ -191,10 +196,18 @@ export default class Heap {
    * @param {Comparator} [comparator]
    * @return {Number[]}
    */
-  find(item, comparator = this.compare) {
+  find(item) {
+    let comparator =
+      arguments.length > 1 && arguments[1] !== undefined
+        ? arguments[1]
+        : this.compare;
     const foundItemIndices = [];
 
-    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {
+    for (
+      let itemIndex = 0;
+      itemIndex < this.heapContainer.length;
+      itemIndex += 1
+    ) {
       if (comparator.equal(item, this.heapContainer[itemIndex])) {
         foundItemIndices.push(itemIndex);
       }
@@ -227,8 +240,11 @@ export default class Heap {
     let currentIndex = customStartIndex || this.heapContainer.length - 1;
 
     while (
-      this.hasParent(currentIndex)
-      && !this.pairIsInCorrectOrder(this.parent(currentIndex), this.heapContainer[currentIndex])
+      this.hasParent(currentIndex) &&
+      !this.pairIsInCorrectOrder(
+        this.parent(currentIndex),
+        this.heapContainer[currentIndex]
+      )
     ) {
       this.swap(currentIndex, this.getParentIndex(currentIndex));
       currentIndex = this.getParentIndex(currentIndex);
@@ -238,7 +254,9 @@ export default class Heap {
   /**
    * @param {number} [customStartIndex]
    */
-  heapifyDown(customStartIndex = 0) {
+  heapifyDown() {
+    let customStartIndex =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
     // Compare the parent element to its children and swap parent with the appropriate
     // child (smallest child for MinHeap, largest child for MaxHeap).
     // Do the same for next children after swap.
@@ -247,18 +265,23 @@ export default class Heap {
 
     while (this.hasLeftChild(currentIndex)) {
       if (
-        this.hasRightChild(currentIndex)
-        && this.pairIsInCorrectOrder(this.rightChild(currentIndex), this.leftChild(currentIndex))
+        this.hasRightChild(currentIndex) &&
+        this.pairIsInCorrectOrder(
+          this.rightChild(currentIndex),
+          this.leftChild(currentIndex)
+        )
       ) {
         nextIndex = this.getRightChildIndex(currentIndex);
       } else {
         nextIndex = this.getLeftChildIndex(currentIndex);
       }
 
-      if (this.pairIsInCorrectOrder(
-        this.heapContainer[currentIndex],
-        this.heapContainer[nextIndex],
-      )) {
+      if (
+        this.pairIsInCorrectOrder(
+          this.heapContainer[currentIndex],
+          this.heapContainer[nextIndex]
+        )
+      ) {
         break;
       }
 
@@ -284,3 +307,4 @@ export default class Heap {
     `);
   }
 }
+
diff --git a/src/data-structures/heap/MaxHeap.js b/src/data-structures/heap/MaxHeap.js
index 7a5d8a2..878afe3 100644
--- a/src/data-structures/heap/MaxHeap.js
+++ b/src/data-structures/heap/MaxHeap.js
@@ -1,4 +1,4 @@
-import Heap from './Heap';
+import Heap from "./Heap";
 
 export default class MaxHeap extends Heap {
   /**
@@ -14,3 +14,4 @@ export default class MaxHeap extends Heap {
     return this.compare.greaterThanOrEqual(firstElement, secondElement);
   }
 }
+
diff --git a/src/data-structures/heap/MinHeap.js b/src/data-structures/heap/MinHeap.js
index 2e4cd98..061fb58 100644
--- a/src/data-structures/heap/MinHeap.js
+++ b/src/data-structures/heap/MinHeap.js
@@ -1,4 +1,4 @@
-import Heap from './Heap';
+import Heap from "./Heap";
 
 export default class MinHeap extends Heap {
   /**
@@ -14,3 +14,4 @@ export default class MinHeap extends Heap {
     return this.compare.lessThanOrEqual(firstElement, secondElement);
   }
 }
+
diff --git a/src/data-structures/heap/__test__/Heap.test.js b/src/data-structures/heap/__test__/Heap.test.js
index 55e3e24..dfda32f 100644
--- a/src/data-structures/heap/__test__/Heap.test.js
+++ b/src/data-structures/heap/__test__/Heap.test.js
@@ -1,7 +1,7 @@
-import Heap from '../Heap';
+import Heap from "../Heap";
 
-describe('Heap', () => {
-  it('should not allow to create instance of the Heap directly', () => {
+describe("Heap", () => {
+  it("should not allow to create instance of the Heap directly", () => {
     const instantiateHeap = () => {
       const heap = new Heap();
       heap.add(5);
@@ -10,3 +10,4 @@ describe('Heap', () => {
     expect(instantiateHeap).toThrow();
   });
 });
+
diff --git a/src/data-structures/heap/__test__/MaxHeap.test.js b/src/data-structures/heap/__test__/MaxHeap.test.js
index c005e7d..c5f1d54 100644
--- a/src/data-structures/heap/__test__/MaxHeap.test.js
+++ b/src/data-structures/heap/__test__/MaxHeap.test.js
@@ -1,8 +1,8 @@
-import MaxHeap from '../MaxHeap';
-import Comparator from '../../../utils/comparator/Comparator';
+import MaxHeap from "../MaxHeap";
+import Comparator from "../../../utils/comparator/Comparator";
 
-describe('MaxHeap', () => {
-  it('should create an empty max heap', () => {
+describe("MaxHeap", () => {
+  it("should create an empty max heap", () => {
     const maxHeap = new MaxHeap();
 
     expect(maxHeap).toBeDefined();
@@ -10,41 +10,41 @@ describe('MaxHeap', () => {
     expect(maxHeap.isEmpty()).toBe(true);
   });
 
-  it('should add items to the heap and heapify it up', () => {
+  it("should add items to the heap and heapify it up", () => {
     const maxHeap = new MaxHeap();
 
     maxHeap.add(5);
     expect(maxHeap.isEmpty()).toBe(false);
     expect(maxHeap.peek()).toBe(5);
-    expect(maxHeap.toString()).toBe('5');
+    expect(maxHeap.toString()).toBe("5");
 
     maxHeap.add(3);
     expect(maxHeap.peek()).toBe(5);
-    expect(maxHeap.toString()).toBe('5,3');
+    expect(maxHeap.toString()).toBe("5,3");
 
     maxHeap.add(10);
     expect(maxHeap.peek()).toBe(10);
-    expect(maxHeap.toString()).toBe('10,3,5');
+    expect(maxHeap.toString()).toBe("10,3,5");
 
     maxHeap.add(1);
     expect(maxHeap.peek()).toBe(10);
-    expect(maxHeap.toString()).toBe('10,3,5,1');
+    expect(maxHeap.toString()).toBe("10,3,5,1");
 
     maxHeap.add(1);
     expect(maxHeap.peek()).toBe(10);
-    expect(maxHeap.toString()).toBe('10,3,5,1,1');
+    expect(maxHeap.toString()).toBe("10,3,5,1,1");
 
     expect(maxHeap.poll()).toBe(10);
-    expect(maxHeap.toString()).toBe('5,3,1,1');
+    expect(maxHeap.toString()).toBe("5,3,1,1");
 
     expect(maxHeap.poll()).toBe(5);
-    expect(maxHeap.toString()).toBe('3,1,1');
+    expect(maxHeap.toString()).toBe("3,1,1");
 
     expect(maxHeap.poll()).toBe(3);
-    expect(maxHeap.toString()).toBe('1,1');
+    expect(maxHeap.toString()).toBe("1,1");
   });
 
-  it('should poll items from the heap and heapify it down', () => {
+  it("should poll items from the heap and heapify it down", () => {
     const maxHeap = new MaxHeap();
 
     maxHeap.add(5);
@@ -53,44 +53,44 @@ describe('MaxHeap', () => {
     maxHeap.add(11);
     maxHeap.add(1);
 
-    expect(maxHeap.toString()).toBe('11,10,5,3,1');
+    expect(maxHeap.toString()).toBe("11,10,5,3,1");
 
     expect(maxHeap.poll()).toBe(11);
-    expect(maxHeap.toString()).toBe('10,3,5,1');
+    expect(maxHeap.toString()).toBe("10,3,5,1");
 
     expect(maxHeap.poll()).toBe(10);
-    expect(maxHeap.toString()).toBe('5,3,1');
+    expect(maxHeap.toString()).toBe("5,3,1");
 
     expect(maxHeap.poll()).toBe(5);
-    expect(maxHeap.toString()).toBe('3,1');
+    expect(maxHeap.toString()).toBe("3,1");
 
     expect(maxHeap.poll()).toBe(3);
-    expect(maxHeap.toString()).toBe('1');
+    expect(maxHeap.toString()).toBe("1");
 
     expect(maxHeap.poll()).toBe(1);
-    expect(maxHeap.toString()).toBe('');
+    expect(maxHeap.toString()).toBe("");
 
     expect(maxHeap.poll()).toBeNull();
-    expect(maxHeap.toString()).toBe('');
+    expect(maxHeap.toString()).toBe("");
   });
 
-  it('should heapify down through the right branch as well', () => {
+  it("should heapify down through the right branch as well", () => {
     const maxHeap = new MaxHeap();
 
     maxHeap.add(3);
     maxHeap.add(12);
     maxHeap.add(10);
 
-    expect(maxHeap.toString()).toBe('12,3,10');
+    expect(maxHeap.toString()).toBe("12,3,10");
 
     maxHeap.add(11);
-    expect(maxHeap.toString()).toBe('12,11,10,3');
+    expect(maxHeap.toString()).toBe("12,11,10,3");
 
     expect(maxHeap.poll()).toBe(12);
-    expect(maxHeap.toString()).toBe('11,3,10');
+    expect(maxHeap.toString()).toBe("11,3,10");
   });
 
-  it('should be possible to find item indices in heap', () => {
+  it("should be possible to find item indices in heap", () => {
     const maxHeap = new MaxHeap();
 
     maxHeap.add(3);
@@ -99,14 +99,14 @@ describe('MaxHeap', () => {
     maxHeap.add(11);
     maxHeap.add(11);
 
-    expect(maxHeap.toString()).toBe('12,11,10,3,11');
+    expect(maxHeap.toString()).toBe("12,11,10,3,11");
 
     expect(maxHeap.find(5)).toEqual([]);
     expect(maxHeap.find(12)).toEqual([0]);
     expect(maxHeap.find(11)).toEqual([1, 4]);
   });
 
-  it('should be possible to remove items from heap with heapify down', () => {
+  it("should be possible to remove items from heap with heapify down", () => {
     const maxHeap = new MaxHeap();
 
     maxHeap.add(3);
@@ -115,15 +115,15 @@ describe('MaxHeap', () => {
     maxHeap.add(11);
     maxHeap.add(11);
 
-    expect(maxHeap.toString()).toBe('12,11,10,3,11');
+    expect(maxHeap.toString()).toBe("12,11,10,3,11");
 
-    expect(maxHeap.remove(12).toString()).toEqual('11,11,10,3');
+    expect(maxHeap.remove(12).toString()).toEqual("11,11,10,3");
     expect(maxHeap.remove(12).peek()).toEqual(11);
-    expect(maxHeap.remove(11).toString()).toEqual('10,3');
+    expect(maxHeap.remove(11).toString()).toEqual("10,3");
     expect(maxHeap.remove(10).peek()).toEqual(3);
   });
 
-  it('should be possible to remove items from heap with heapify up', () => {
+  it("should be possible to remove items from heap with heapify up", () => {
     const maxHeap = new MaxHeap();
 
     maxHeap.add(3);
@@ -137,26 +137,26 @@ describe('MaxHeap', () => {
     maxHeap.add(2);
     maxHeap.add(1);
 
-    expect(maxHeap.toString()).toBe('10,8,6,7,6,4,5,3,2,1');
-    expect(maxHeap.remove(4).toString()).toEqual('10,8,6,7,6,1,5,3,2');
-    expect(maxHeap.remove(3).toString()).toEqual('10,8,6,7,6,1,5,2');
-    expect(maxHeap.remove(5).toString()).toEqual('10,8,6,7,6,1,2');
-    expect(maxHeap.remove(10).toString()).toEqual('8,7,6,2,6,1');
-    expect(maxHeap.remove(6).toString()).toEqual('8,7,1,2');
-    expect(maxHeap.remove(2).toString()).toEqual('8,7,1');
-    expect(maxHeap.remove(1).toString()).toEqual('8,7');
-    expect(maxHeap.remove(7).toString()).toEqual('8');
-    expect(maxHeap.remove(8).toString()).toEqual('');
+    expect(maxHeap.toString()).toBe("10,8,6,7,6,4,5,3,2,1");
+    expect(maxHeap.remove(4).toString()).toEqual("10,8,6,7,6,1,5,3,2");
+    expect(maxHeap.remove(3).toString()).toEqual("10,8,6,7,6,1,5,2");
+    expect(maxHeap.remove(5).toString()).toEqual("10,8,6,7,6,1,2");
+    expect(maxHeap.remove(10).toString()).toEqual("8,7,6,2,6,1");
+    expect(maxHeap.remove(6).toString()).toEqual("8,7,1,2");
+    expect(maxHeap.remove(2).toString()).toEqual("8,7,1");
+    expect(maxHeap.remove(1).toString()).toEqual("8,7");
+    expect(maxHeap.remove(7).toString()).toEqual("8");
+    expect(maxHeap.remove(8).toString()).toEqual("");
   });
 
-  it('should be possible to remove items from heap with custom finding comparator', () => {
+  it("should be possible to remove items from heap with custom finding comparator", () => {
     const maxHeap = new MaxHeap();
-    maxHeap.add('a');
-    maxHeap.add('bb');
-    maxHeap.add('ccc');
-    maxHeap.add('dddd');
+    maxHeap.add("a");
+    maxHeap.add("bb");
+    maxHeap.add("ccc");
+    maxHeap.add("dddd");
 
-    expect(maxHeap.toString()).toBe('dddd,ccc,bb,a');
+    expect(maxHeap.toString()).toBe("dddd,ccc,bb,a");
 
     const comparator = new Comparator((a, b) => {
       if (a.length === b.length) {
@@ -166,7 +166,8 @@ describe('MaxHeap', () => {
       return a.length < b.length ? -1 : 1;
     });
 
-    maxHeap.remove('hey', comparator);
-    expect(maxHeap.toString()).toBe('dddd,a,bb');
+    maxHeap.remove("hey", comparator);
+    expect(maxHeap.toString()).toBe("dddd,a,bb");
   });
 });
+
diff --git a/src/data-structures/heap/__test__/MinHeap.test.js b/src/data-structures/heap/__test__/MinHeap.test.js
index b963a41..20974e5 100644
--- a/src/data-structures/heap/__test__/MinHeap.test.js
+++ b/src/data-structures/heap/__test__/MinHeap.test.js
@@ -1,8 +1,8 @@
-import MinHeap from '../MinHeap';
-import Comparator from '../../../utils/comparator/Comparator';
+import MinHeap from "../MinHeap";
+import Comparator from "../../../utils/comparator/Comparator";
 
-describe('MinHeap', () => {
-  it('should create an empty min heap', () => {
+describe("MinHeap", () => {
+  it("should create an empty min heap", () => {
     const minHeap = new MinHeap();
 
     expect(minHeap).toBeDefined();
@@ -10,41 +10,41 @@ describe('MinHeap', () => {
     expect(minHeap.isEmpty()).toBe(true);
   });
 
-  it('should add items to the heap and heapify it up', () => {
+  it("should add items to the heap and heapify it up", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(5);
     expect(minHeap.isEmpty()).toBe(false);
     expect(minHeap.peek()).toBe(5);
-    expect(minHeap.toString()).toBe('5');
+    expect(minHeap.toString()).toBe("5");
 
     minHeap.add(3);
     expect(minHeap.peek()).toBe(3);
-    expect(minHeap.toString()).toBe('3,5');
+    expect(minHeap.toString()).toBe("3,5");
 
     minHeap.add(10);
     expect(minHeap.peek()).toBe(3);
-    expect(minHeap.toString()).toBe('3,5,10');
+    expect(minHeap.toString()).toBe("3,5,10");
 
     minHeap.add(1);
     expect(minHeap.peek()).toBe(1);
-    expect(minHeap.toString()).toBe('1,3,10,5');
+    expect(minHeap.toString()).toBe("1,3,10,5");
 
     minHeap.add(1);
     expect(minHeap.peek()).toBe(1);
-    expect(minHeap.toString()).toBe('1,1,10,5,3');
+    expect(minHeap.toString()).toBe("1,1,10,5,3");
 
     expect(minHeap.poll()).toBe(1);
-    expect(minHeap.toString()).toBe('1,3,10,5');
+    expect(minHeap.toString()).toBe("1,3,10,5");
 
     expect(minHeap.poll()).toBe(1);
-    expect(minHeap.toString()).toBe('3,5,10');
+    expect(minHeap.toString()).toBe("3,5,10");
 
     expect(minHeap.poll()).toBe(3);
-    expect(minHeap.toString()).toBe('5,10');
+    expect(minHeap.toString()).toBe("5,10");
   });
 
-  it('should poll items from the heap and heapify it down', () => {
+  it("should poll items from the heap and heapify it down", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(5);
@@ -53,44 +53,44 @@ describe('MinHeap', () => {
     minHeap.add(11);
     minHeap.add(1);
 
-    expect(minHeap.toString()).toBe('1,3,10,11,5');
+    expect(minHeap.toString()).toBe("1,3,10,11,5");
 
     expect(minHeap.poll()).toBe(1);
-    expect(minHeap.toString()).toBe('3,5,10,11');
+    expect(minHeap.toString()).toBe("3,5,10,11");
 
     expect(minHeap.poll()).toBe(3);
-    expect(minHeap.toString()).toBe('5,11,10');
+    expect(minHeap.toString()).toBe("5,11,10");
 
     expect(minHeap.poll()).toBe(5);
-    expect(minHeap.toString()).toBe('10,11');
+    expect(minHeap.toString()).toBe("10,11");
 
     expect(minHeap.poll()).toBe(10);
-    expect(minHeap.toString()).toBe('11');
+    expect(minHeap.toString()).toBe("11");
 
     expect(minHeap.poll()).toBe(11);
-    expect(minHeap.toString()).toBe('');
+    expect(minHeap.toString()).toBe("");
 
     expect(minHeap.poll()).toBeNull();
-    expect(minHeap.toString()).toBe('');
+    expect(minHeap.toString()).toBe("");
   });
 
-  it('should heapify down through the right branch as well', () => {
+  it("should heapify down through the right branch as well", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(3);
     minHeap.add(12);
     minHeap.add(10);
 
-    expect(minHeap.toString()).toBe('3,12,10');
+    expect(minHeap.toString()).toBe("3,12,10");
 
     minHeap.add(11);
-    expect(minHeap.toString()).toBe('3,11,10,12');
+    expect(minHeap.toString()).toBe("3,11,10,12");
 
     expect(minHeap.poll()).toBe(3);
-    expect(minHeap.toString()).toBe('10,11,12');
+    expect(minHeap.toString()).toBe("10,11,12");
   });
 
-  it('should be possible to find item indices in heap', () => {
+  it("should be possible to find item indices in heap", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(3);
@@ -99,14 +99,14 @@ describe('MinHeap', () => {
     minHeap.add(11);
     minHeap.add(11);
 
-    expect(minHeap.toString()).toBe('3,11,10,12,11');
+    expect(minHeap.toString()).toBe("3,11,10,12,11");
 
     expect(minHeap.find(5)).toEqual([]);
     expect(minHeap.find(3)).toEqual([0]);
     expect(minHeap.find(11)).toEqual([1, 4]);
   });
 
-  it('should be possible to remove items from heap with heapify down', () => {
+  it("should be possible to remove items from heap with heapify down", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(3);
@@ -115,15 +115,15 @@ describe('MinHeap', () => {
     minHeap.add(11);
     minHeap.add(11);
 
-    expect(minHeap.toString()).toBe('3,11,10,12,11');
+    expect(minHeap.toString()).toBe("3,11,10,12,11");
 
-    expect(minHeap.remove(3).toString()).toEqual('10,11,11,12');
+    expect(minHeap.remove(3).toString()).toEqual("10,11,11,12");
     expect(minHeap.remove(3).peek()).toEqual(10);
-    expect(minHeap.remove(11).toString()).toEqual('10,12');
+    expect(minHeap.remove(11).toString()).toEqual("10,12");
     expect(minHeap.remove(3).peek()).toEqual(10);
   });
 
-  it('should be possible to remove items from heap with heapify up', () => {
+  it("should be possible to remove items from heap with heapify up", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(3);
@@ -137,26 +137,26 @@ describe('MinHeap', () => {
     minHeap.add(2);
     minHeap.add(1);
 
-    expect(minHeap.toString()).toBe('1,2,4,6,3,5,6,10,8,7');
-    expect(minHeap.remove(8).toString()).toEqual('1,2,4,6,3,5,6,10,7');
-    expect(minHeap.remove(7).toString()).toEqual('1,2,4,6,3,5,6,10');
-    expect(minHeap.remove(1).toString()).toEqual('2,3,4,6,10,5,6');
-    expect(minHeap.remove(2).toString()).toEqual('3,6,4,6,10,5');
-    expect(minHeap.remove(6).toString()).toEqual('3,5,4,10');
-    expect(minHeap.remove(10).toString()).toEqual('3,5,4');
-    expect(minHeap.remove(5).toString()).toEqual('3,4');
-    expect(minHeap.remove(3).toString()).toEqual('4');
-    expect(minHeap.remove(4).toString()).toEqual('');
+    expect(minHeap.toString()).toBe("1,2,4,6,3,5,6,10,8,7");
+    expect(minHeap.remove(8).toString()).toEqual("1,2,4,6,3,5,6,10,7");
+    expect(minHeap.remove(7).toString()).toEqual("1,2,4,6,3,5,6,10");
+    expect(minHeap.remove(1).toString()).toEqual("2,3,4,6,10,5,6");
+    expect(minHeap.remove(2).toString()).toEqual("3,6,4,6,10,5");
+    expect(minHeap.remove(6).toString()).toEqual("3,5,4,10");
+    expect(minHeap.remove(10).toString()).toEqual("3,5,4");
+    expect(minHeap.remove(5).toString()).toEqual("3,4");
+    expect(minHeap.remove(3).toString()).toEqual("4");
+    expect(minHeap.remove(4).toString()).toEqual("");
   });
 
-  it('should be possible to remove items from heap with custom finding comparator', () => {
+  it("should be possible to remove items from heap with custom finding comparator", () => {
     const minHeap = new MinHeap();
-    minHeap.add('dddd');
-    minHeap.add('ccc');
-    minHeap.add('bb');
-    minHeap.add('a');
+    minHeap.add("dddd");
+    minHeap.add("ccc");
+    minHeap.add("bb");
+    minHeap.add("a");
 
-    expect(minHeap.toString()).toBe('a,bb,ccc,dddd');
+    expect(minHeap.toString()).toBe("a,bb,ccc,dddd");
 
     const comparator = new Comparator((a, b) => {
       if (a.length === b.length) {
@@ -166,11 +166,11 @@ describe('MinHeap', () => {
       return a.length < b.length ? -1 : 1;
     });
 
-    minHeap.remove('hey', comparator);
-    expect(minHeap.toString()).toBe('a,bb,dddd');
+    minHeap.remove("hey", comparator);
+    expect(minHeap.toString()).toBe("a,bb,dddd");
   });
 
-  it('should remove values from heap and correctly re-order the tree', () => {
+  it("should remove values from heap and correctly re-order the tree", () => {
     const minHeap = new MinHeap();
 
     minHeap.add(1);
@@ -183,12 +183,13 @@ describe('MinHeap', () => {
     minHeap.add(8);
     minHeap.add(9);
 
-    expect(minHeap.toString()).toBe('1,2,3,4,5,6,7,8,9');
+    expect(minHeap.toString()).toBe("1,2,3,4,5,6,7,8,9");
 
     minHeap.remove(2);
-    expect(minHeap.toString()).toBe('1,4,3,8,5,6,7,9');
+    expect(minHeap.toString()).toBe("1,4,3,8,5,6,7,9");
 
     minHeap.remove(4);
-    expect(minHeap.toString()).toBe('1,5,3,8,9,6,7');
+    expect(minHeap.toString()).toBe("1,5,3,8,9,6,7");
   });
 });
+
diff --git a/src/data-structures/linked-list/LinkedList.js b/src/data-structures/linked-list/LinkedList.js
index ba7d0e3..3262d1a 100644
--- a/src/data-structures/linked-list/LinkedList.js
+++ b/src/data-structures/linked-list/LinkedList.js
@@ -1,5 +1,5 @@
-import LinkedListNode from './LinkedListNode';
-import Comparator from '../../utils/comparator/Comparator';
+import LinkedListNode from "./LinkedListNode";
+import Comparator from "../../utils/comparator/Comparator";
 
 export default class LinkedList {
   /**
@@ -134,7 +134,11 @@ export default class LinkedList {
    * @param {function} [findParams.callback]
    * @return {LinkedListNode}
    */
-  find({ value = undefined, callback = undefined }) {
+  find(_ref) {
+    let _ref$value = _ref.value,
+      value = _ref$value === void 0 ? undefined : _ref$value,
+      _ref$callback = _ref.callback,
+      callback = _ref$callback === void 0 ? undefined : _ref$callback;
     if (!this.head) {
       return null;
     }
@@ -239,7 +243,9 @@ export default class LinkedList {
    * @return {string}
    */
   toString(callback) {
-    return this.toArray().map((node) => node.toString(callback)).toString();
+    return this.toArray()
+      .map((node) => node.toString(callback))
+      .toString();
   }
 
   /**
@@ -270,3 +276,4 @@ export default class LinkedList {
     return this;
   }
 }
+
diff --git a/src/data-structures/linked-list/LinkedListNode.js b/src/data-structures/linked-list/LinkedListNode.js
index d136e86..622d2f6 100644
--- a/src/data-structures/linked-list/LinkedListNode.js
+++ b/src/data-structures/linked-list/LinkedListNode.js
@@ -1,5 +1,7 @@
 export default class LinkedListNode {
-  constructor(value, next = null) {
+  constructor(value) {
+    let next =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
     this.value = value;
     this.next = next;
   }
@@ -8,3 +10,4 @@ export default class LinkedListNode {
     return callback ? callback(this.value) : `${this.value}`;
   }
 }
+
diff --git a/src/data-structures/linked-list/__test__/LinkedList.test.js b/src/data-structures/linked-list/__test__/LinkedList.test.js
index 6ac41dd..722f8b1 100644
--- a/src/data-structures/linked-list/__test__/LinkedList.test.js
+++ b/src/data-structures/linked-list/__test__/LinkedList.test.js
@@ -1,12 +1,12 @@
-import LinkedList from '../LinkedList';
+import LinkedList from "../LinkedList";
 
-describe('LinkedList', () => {
-  it('should create empty linked list', () => {
+describe("LinkedList", () => {
+  it("should create empty linked list", () => {
     const linkedList = new LinkedList();
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
   });
 
-  it('should append node to linked list', () => {
+  it("should append node to linked list", () => {
     const linkedList = new LinkedList();
 
     expect(linkedList.head).toBeNull();
@@ -15,39 +15,39 @@ describe('LinkedList', () => {
     linkedList.append(1);
     linkedList.append(2);
 
-    expect(linkedList.toString()).toBe('1,2');
+    expect(linkedList.toString()).toBe("1,2");
     expect(linkedList.tail.next).toBeNull();
   });
 
-  it('should prepend node to linked list', () => {
+  it("should prepend node to linked list", () => {
     const linkedList = new LinkedList();
 
     linkedList.prepend(2);
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("2");
 
     linkedList.append(1);
     linkedList.prepend(3);
 
-    expect(linkedList.toString()).toBe('3,2,1');
+    expect(linkedList.toString()).toBe("3,2,1");
   });
 
-  it('should insert node to linked list', () => {
+  it("should insert node to linked list", () => {
     const linkedList = new LinkedList();
 
     linkedList.insert(4, 3);
-    expect(linkedList.head.toString()).toBe('4');
-    expect(linkedList.tail.toString()).toBe('4');
+    expect(linkedList.head.toString()).toBe("4");
+    expect(linkedList.tail.toString()).toBe("4");
 
     linkedList.insert(3, 2);
     linkedList.insert(2, 1);
     linkedList.insert(1, -7);
     linkedList.insert(10, 9);
 
-    expect(linkedList.toString()).toBe('1,4,2,3,10');
+    expect(linkedList.toString()).toBe("1,4,2,3,10");
   });
 
-  it('should delete node by value from linked list', () => {
+  it("should delete node by value from linked list", () => {
     const linkedList = new LinkedList();
 
     expect(linkedList.delete(5)).toBeNull();
@@ -61,71 +61,71 @@ describe('LinkedList', () => {
     linkedList.append(4);
     linkedList.append(5);
 
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('5');
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("5");
 
     const deletedNode = linkedList.delete(3);
     expect(deletedNode.value).toBe(3);
-    expect(linkedList.toString()).toBe('1,1,2,4,5');
+    expect(linkedList.toString()).toBe("1,1,2,4,5");
 
     linkedList.delete(3);
-    expect(linkedList.toString()).toBe('1,1,2,4,5');
+    expect(linkedList.toString()).toBe("1,1,2,4,5");
 
     linkedList.delete(1);
-    expect(linkedList.toString()).toBe('2,4,5');
+    expect(linkedList.toString()).toBe("2,4,5");
 
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('5');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("5");
 
     linkedList.delete(5);
-    expect(linkedList.toString()).toBe('2,4');
+    expect(linkedList.toString()).toBe("2,4");
 
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('4');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("4");
 
     linkedList.delete(4);
-    expect(linkedList.toString()).toBe('2');
+    expect(linkedList.toString()).toBe("2");
 
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("2");
 
     linkedList.delete(2);
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
   });
 
-  it('should delete linked list tail', () => {
+  it("should delete linked list tail", () => {
     const linkedList = new LinkedList();
 
     linkedList.append(1);
     linkedList.append(2);
     linkedList.append(3);
 
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('3');
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("3");
 
     const deletedNode1 = linkedList.deleteTail();
 
     expect(deletedNode1.value).toBe(3);
-    expect(linkedList.toString()).toBe('1,2');
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.toString()).toBe("1,2");
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("2");
 
     const deletedNode2 = linkedList.deleteTail();
 
     expect(deletedNode2.value).toBe(2);
-    expect(linkedList.toString()).toBe('1');
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('1');
+    expect(linkedList.toString()).toBe("1");
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("1");
 
     const deletedNode3 = linkedList.deleteTail();
 
     expect(deletedNode3.value).toBe(1);
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
     expect(linkedList.head).toBeNull();
     expect(linkedList.tail).toBeNull();
   });
 
-  it('should delete linked list head', () => {
+  it("should delete linked list head", () => {
     const linkedList = new LinkedList();
 
     expect(linkedList.deleteHead()).toBeNull();
@@ -133,40 +133,38 @@ describe('LinkedList', () => {
     linkedList.append(1);
     linkedList.append(2);
 
-    expect(linkedList.head.toString()).toBe('1');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.head.toString()).toBe("1");
+    expect(linkedList.tail.toString()).toBe("2");
 
     const deletedNode1 = linkedList.deleteHead();
 
     expect(deletedNode1.value).toBe(1);
-    expect(linkedList.toString()).toBe('2');
-    expect(linkedList.head.toString()).toBe('2');
-    expect(linkedList.tail.toString()).toBe('2');
+    expect(linkedList.toString()).toBe("2");
+    expect(linkedList.head.toString()).toBe("2");
+    expect(linkedList.tail.toString()).toBe("2");
 
     const deletedNode2 = linkedList.deleteHead();
 
     expect(deletedNode2.value).toBe(2);
-    expect(linkedList.toString()).toBe('');
+    expect(linkedList.toString()).toBe("");
     expect(linkedList.head).toBeNull();
     expect(linkedList.tail).toBeNull();
   });
 
-  it('should be possible to store objects in the list and to print them out', () => {
+  it("should be possible to store objects in the list and to print them out", () => {
     const linkedList = new LinkedList();
 
-    const nodeValue1 = { value: 1, key: 'key1' };
-    const nodeValue2 = { value: 2, key: 'key2' };
+    const nodeValue1 = { value: 1, key: "key1" };
+    const nodeValue2 = { value: 2, key: "key2" };
 
-    linkedList
-      .append(nodeValue1)
-      .prepend(nodeValue2);
+    linkedList.append(nodeValue1).prepend(nodeValue2);
 
     const nodeStringifier = (value) => `${value.key}:${value.value}`;
 
-    expect(linkedList.toString(nodeStringifier)).toBe('key2:2,key1:1');
+    expect(linkedList.toString(nodeStringifier)).toBe("key2:2,key1:1");
   });
 
-  it('should find node by value', () => {
+  it("should find node by value", () => {
     const linkedList = new LinkedList();
 
     expect(linkedList.find({ value: 5 })).toBeNull();
@@ -174,9 +172,7 @@ describe('LinkedList', () => {
     linkedList.append(1);
     expect(linkedList.find({ value: 1 })).toBeDefined();
 
-    linkedList
-      .append(2)
-      .append(3);
+    linkedList.append(2).append(3);
 
     const node = linkedList.find({ value: 2 });
 
@@ -184,30 +180,34 @@ describe('LinkedList', () => {
     expect(linkedList.find({ value: 5 })).toBeNull();
   });
 
-  it('should find node by callback', () => {
+  it("should find node by callback", () => {
     const linkedList = new LinkedList();
 
     linkedList
-      .append({ value: 1, key: 'test1' })
-      .append({ value: 2, key: 'test2' })
-      .append({ value: 3, key: 'test3' });
+      .append({ value: 1, key: "test1" })
+      .append({ value: 2, key: "test2" })
+      .append({ value: 3, key: "test3" });
 
-    const node = linkedList.find({ callback: (value) => value.key === 'test2' });
+    const node = linkedList.find({
+      callback: (value) => value.key === "test2",
+    });
 
     expect(node).toBeDefined();
     expect(node.value.value).toBe(2);
-    expect(node.value.key).toBe('test2');
-    expect(linkedList.find({ callback: (value) => value.key === 'test5' })).toBeNull();
+    expect(node.value.key).toBe("test2");
+    expect(
+      linkedList.find({ callback: (value) => value.key === "test5" })
+    ).toBeNull();
   });
 
-  it('should create linked list from array', () => {
+  it("should create linked list from array", () => {
     const linkedList = new LinkedList();
     linkedList.fromArray([1, 1, 2, 3, 3, 3, 4, 5]);
 
-    expect(linkedList.toString()).toBe('1,1,2,3,3,3,4,5');
+    expect(linkedList.toString()).toBe("1,1,2,3,3,3,4,5");
   });
 
-  it('should find node by means of custom compare function', () => {
+  it("should find node by means of custom compare function", () => {
     const comparatorFunction = (a, b) => {
       if (a.customValue === b.customValue) {
         return 0;
@@ -219,21 +219,23 @@ describe('LinkedList', () => {
     const linkedList = new LinkedList(comparatorFunction);
 
     linkedList
-      .append({ value: 1, customValue: 'test1' })
-      .append({ value: 2, customValue: 'test2' })
-      .append({ value: 3, customValue: 'test3' });
+      .append({ value: 1, customValue: "test1" })
+      .append({ value: 2, customValue: "test2" })
+      .append({ value: 3, customValue: "test3" });
 
     const node = linkedList.find({
-      value: { value: 2, customValue: 'test2' },
+      value: { value: 2, customValue: "test2" },
     });
 
     expect(node).toBeDefined();
     expect(node.value.value).toBe(2);
-    expect(node.value.customValue).toBe('test2');
-    expect(linkedList.find({ value: { value: 2, customValue: 'test5' } })).toBeNull();
+    expect(node.value.customValue).toBe("test2");
+    expect(
+      linkedList.find({ value: { value: 2, customValue: "test5" } })
+    ).toBeNull();
   });
 
-  it('should find preferring callback over compare function', () => {
+  it("should find preferring callback over compare function", () => {
     const greaterThan = (value, compareTo) => (value > compareTo ? 0 : 1);
 
     const linkedList = new LinkedList(greaterThan);
@@ -246,37 +248,35 @@ describe('LinkedList', () => {
     expect(node.value).toBe(1);
   });
 
-  it('should convert to array', () => {
+  it("should convert to array", () => {
     const linkedList = new LinkedList();
     linkedList.append(1);
     linkedList.append(2);
     linkedList.append(3);
-    expect(linkedList.toArray().join(',')).toBe('1,2,3');
+    expect(linkedList.toArray().join(",")).toBe("1,2,3");
   });
 
-  it('should reverse linked list', () => {
+  it("should reverse linked list", () => {
     const linkedList = new LinkedList();
 
     // Add test values to linked list.
-    linkedList
-      .append(1)
-      .append(2)
-      .append(3);
+    linkedList.append(1).append(2).append(3);
 
-    expect(linkedList.toString()).toBe('1,2,3');
+    expect(linkedList.toString()).toBe("1,2,3");
     expect(linkedList.head.value).toBe(1);
     expect(linkedList.tail.value).toBe(3);
 
     // Reverse linked list.
     linkedList.reverse();
-    expect(linkedList.toString()).toBe('3,2,1');
+    expect(linkedList.toString()).toBe("3,2,1");
     expect(linkedList.head.value).toBe(3);
     expect(linkedList.tail.value).toBe(1);
 
     // Reverse linked list back to initial state.
     linkedList.reverse();
-    expect(linkedList.toString()).toBe('1,2,3');
+    expect(linkedList.toString()).toBe("1,2,3");
     expect(linkedList.head.value).toBe(1);
     expect(linkedList.tail.value).toBe(3);
   });
 });
+
diff --git a/src/data-structures/linked-list/__test__/LinkedListNode.test.js b/src/data-structures/linked-list/__test__/LinkedListNode.test.js
index 71b2d28..a00343b 100644
--- a/src/data-structures/linked-list/__test__/LinkedListNode.test.js
+++ b/src/data-structures/linked-list/__test__/LinkedListNode.test.js
@@ -1,23 +1,23 @@
-import LinkedListNode from '../LinkedListNode';
+import LinkedListNode from "../LinkedListNode";
 
-describe('LinkedListNode', () => {
-  it('should create list node with value', () => {
+describe("LinkedListNode", () => {
+  it("should create list node with value", () => {
     const node = new LinkedListNode(1);
 
     expect(node.value).toBe(1);
     expect(node.next).toBeNull();
   });
 
-  it('should create list node with object as a value', () => {
-    const nodeValue = { value: 1, key: 'test' };
+  it("should create list node with object as a value", () => {
+    const nodeValue = { value: 1, key: "test" };
     const node = new LinkedListNode(nodeValue);
 
     expect(node.value.value).toBe(1);
-    expect(node.value.key).toBe('test');
+    expect(node.value.key).toBe("test");
     expect(node.next).toBeNull();
   });
 
-  it('should link nodes together', () => {
+  it("should link nodes together", () => {
     const node2 = new LinkedListNode(2);
     const node1 = new LinkedListNode(1, node2);
 
@@ -27,20 +27,22 @@ describe('LinkedListNode', () => {
     expect(node1.next.value).toBe(2);
   });
 
-  it('should convert node to string', () => {
+  it("should convert node to string", () => {
     const node = new LinkedListNode(1);
 
-    expect(node.toString()).toBe('1');
+    expect(node.toString()).toBe("1");
 
-    node.value = 'string value';
-    expect(node.toString()).toBe('string value');
+    node.value = "string value";
+    expect(node.toString()).toBe("string value");
   });
 
-  it('should convert node to string with custom stringifier', () => {
-    const nodeValue = { value: 1, key: 'test' };
+  it("should convert node to string with custom stringifier", () => {
+    const nodeValue = { value: 1, key: "test" };
     const node = new LinkedListNode(nodeValue);
-    const toStringCallback = (value) => `value: ${value.value}, key: ${value.key}`;
+    const toStringCallback = (value) =>
+      `value: ${value.value}, key: ${value.key}`;
 
-    expect(node.toString(toStringCallback)).toBe('value: 1, key: test');
+    expect(node.toString(toStringCallback)).toBe("value: 1, key: test");
   });
 });
+
diff --git a/src/data-structures/priority-queue/PriorityQueue.js b/src/data-structures/priority-queue/PriorityQueue.js
index 0b283c2..6a09ba8 100644
--- a/src/data-structures/priority-queue/PriorityQueue.js
+++ b/src/data-structures/priority-queue/PriorityQueue.js
@@ -1,5 +1,5 @@
-import MinHeap from '../heap/MinHeap';
-import Comparator from '../../utils/comparator/Comparator';
+import MinHeap from "../heap/MinHeap";
+import Comparator from "../../utils/comparator/Comparator";
 
 // It is the same as min heap except that when comparing two elements
 // we take into account its priority instead of the element's value.
@@ -22,7 +22,9 @@ export default class PriorityQueue extends MinHeap {
    * @param {number} [priority] - items priority.
    * @return {PriorityQueue}
    */
-  add(item, priority = 0) {
+  add(item) {
+    let priority =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
     this.priorities.set(item, priority);
     super.add(item);
     return this;
@@ -96,3 +98,4 @@ export default class PriorityQueue extends MinHeap {
     return a < b ? -1 : 1;
   }
 }
+
diff --git a/src/data-structures/priority-queue/__test__/PriorityQueue.test.js b/src/data-structures/priority-queue/__test__/PriorityQueue.test.js
index 2ffe4ac..d04aacf 100644
--- a/src/data-structures/priority-queue/__test__/PriorityQueue.test.js
+++ b/src/data-structures/priority-queue/__test__/PriorityQueue.test.js
@@ -1,13 +1,13 @@
-import PriorityQueue from '../PriorityQueue';
+import PriorityQueue from "../PriorityQueue";
 
-describe('PriorityQueue', () => {
-  it('should create default priority queue', () => {
+describe("PriorityQueue", () => {
+  it("should create default priority queue", () => {
     const priorityQueue = new PriorityQueue();
 
     expect(priorityQueue).toBeDefined();
   });
 
-  it('should insert items to the queue and respect priorities', () => {
+  it("should insert items to the queue and respect priorities", () => {
     const priorityQueue = new PriorityQueue();
 
     priorityQueue.add(10, 1);
@@ -20,12 +20,12 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.peek()).toBe(100);
   });
 
-  it('should be possible to use objects in priority queue', () => {
+  it("should be possible to use objects in priority queue", () => {
     const priorityQueue = new PriorityQueue();
 
-    const user1 = { name: 'Mike' };
-    const user2 = { name: 'Bill' };
-    const user3 = { name: 'Jane' };
+    const user1 = { name: "Mike" };
+    const user2 = { name: "Bill" };
+    const user3 = { name: "Jane" };
 
     priorityQueue.add(user1, 1);
     expect(priorityQueue.peek()).toBe(user1);
@@ -37,7 +37,7 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.peek()).toBe(user3);
   });
 
-  it('should poll from queue with respect to priorities', () => {
+  it("should poll from queue with respect to priorities", () => {
     const priorityQueue = new PriorityQueue();
 
     priorityQueue.add(10, 1);
@@ -51,7 +51,7 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.poll()).toBe(5);
   });
 
-  it('should be possible to change priority of head node', () => {
+  it("should be possible to change priority of head node", () => {
     const priorityQueue = new PriorityQueue();
 
     priorityQueue.add(10, 1);
@@ -70,7 +70,7 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.poll()).toBe(10);
   });
 
-  it('should be possible to change priority of internal nodes', () => {
+  it("should be possible to change priority of internal nodes", () => {
     const priorityQueue = new PriorityQueue();
 
     priorityQueue.add(10, 1);
@@ -89,7 +89,7 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.poll()).toBe(10);
   });
 
-  it('should be possible to change priority along with node addition', () => {
+  it("should be possible to change priority along with node addition", () => {
     const priorityQueue = new PriorityQueue();
 
     priorityQueue.add(10, 1);
@@ -109,7 +109,7 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.poll()).toBe(10);
   });
 
-  it('should be possible to search in priority queue by value', () => {
+  it("should be possible to search in priority queue by value", () => {
     const priorityQueue = new PriorityQueue();
 
     priorityQueue.add(10, 1);
@@ -122,3 +122,4 @@ describe('PriorityQueue', () => {
     expect(priorityQueue.hasValue(15)).toBe(true);
   });
 });
+
diff --git a/src/data-structures/queue/Queue.js b/src/data-structures/queue/Queue.js
index 64e646f..c1d569f 100644
--- a/src/data-structures/queue/Queue.js
+++ b/src/data-structures/queue/Queue.js
@@ -1,4 +1,4 @@
-import LinkedList from '../linked-list/LinkedList';
+import LinkedList from "../linked-list/LinkedList";
 
 export default class Queue {
   constructor() {
@@ -56,3 +56,4 @@ export default class Queue {
     return this.linkedList.toString(callback);
   }
 }
+
diff --git a/src/data-structures/queue/__test__/Queue.test.js b/src/data-structures/queue/__test__/Queue.test.js
index a0b2cd5..69da571 100644
--- a/src/data-structures/queue/__test__/Queue.test.js
+++ b/src/data-structures/queue/__test__/Queue.test.js
@@ -1,35 +1,35 @@
-import Queue from '../Queue';
+import Queue from "../Queue";
 
-describe('Queue', () => {
-  it('should create empty queue', () => {
+describe("Queue", () => {
+  it("should create empty queue", () => {
     const queue = new Queue();
     expect(queue).not.toBeNull();
     expect(queue.linkedList).not.toBeNull();
   });
 
-  it('should enqueue data to queue', () => {
+  it("should enqueue data to queue", () => {
     const queue = new Queue();
 
     queue.enqueue(1);
     queue.enqueue(2);
 
-    expect(queue.toString()).toBe('1,2');
+    expect(queue.toString()).toBe("1,2");
   });
 
-  it('should be possible to enqueue/dequeue objects', () => {
+  it("should be possible to enqueue/dequeue objects", () => {
     const queue = new Queue();
 
-    queue.enqueue({ value: 'test1', key: 'key1' });
-    queue.enqueue({ value: 'test2', key: 'key2' });
+    queue.enqueue({ value: "test1", key: "key1" });
+    queue.enqueue({ value: "test2", key: "key2" });
 
     const stringifier = (value) => `${value.key}:${value.value}`;
 
-    expect(queue.toString(stringifier)).toBe('key1:test1,key2:test2');
-    expect(queue.dequeue().value).toBe('test1');
-    expect(queue.dequeue().value).toBe('test2');
+    expect(queue.toString(stringifier)).toBe("key1:test1,key2:test2");
+    expect(queue.dequeue().value).toBe("test1");
+    expect(queue.dequeue().value).toBe("test2");
   });
 
-  it('should peek data from queue', () => {
+  it("should peek data from queue", () => {
     const queue = new Queue();
 
     expect(queue.peek()).toBeNull();
@@ -41,7 +41,7 @@ describe('Queue', () => {
     expect(queue.peek()).toBe(1);
   });
 
-  it('should check if queue is empty', () => {
+  it("should check if queue is empty", () => {
     const queue = new Queue();
 
     expect(queue.isEmpty()).toBe(true);
@@ -51,7 +51,7 @@ describe('Queue', () => {
     expect(queue.isEmpty()).toBe(false);
   });
 
-  it('should dequeue from queue in FIFO order', () => {
+  it("should dequeue from queue in FIFO order", () => {
     const queue = new Queue();
 
     queue.enqueue(1);
@@ -63,3 +63,4 @@ describe('Queue', () => {
     expect(queue.isEmpty()).toBe(true);
   });
 });
+
diff --git a/src/data-structures/stack/Stack.js b/src/data-structures/stack/Stack.js
index 8d06141..20fbf82 100644
--- a/src/data-structures/stack/Stack.js
+++ b/src/data-structures/stack/Stack.js
@@ -1,4 +1,4 @@
-import LinkedList from '../linked-list/LinkedList';
+import LinkedList from "../linked-list/LinkedList";
 
 export default class Stack {
   constructor() {
@@ -65,3 +65,4 @@ export default class Stack {
     return this.linkedList.toString(callback);
   }
 }
+
diff --git a/src/data-structures/stack/__test__/Stack.test.js b/src/data-structures/stack/__test__/Stack.test.js
index 1112277..8ee9e93 100644
--- a/src/data-structures/stack/__test__/Stack.test.js
+++ b/src/data-structures/stack/__test__/Stack.test.js
@@ -1,22 +1,22 @@
-import Stack from '../Stack';
+import Stack from "../Stack";
 
-describe('Stack', () => {
-  it('should create empty stack', () => {
+describe("Stack", () => {
+  it("should create empty stack", () => {
     const stack = new Stack();
     expect(stack).not.toBeNull();
     expect(stack.linkedList).not.toBeNull();
   });
 
-  it('should stack data to stack', () => {
+  it("should stack data to stack", () => {
     const stack = new Stack();
 
     stack.push(1);
     stack.push(2);
 
-    expect(stack.toString()).toBe('2,1');
+    expect(stack.toString()).toBe("2,1");
   });
 
-  it('should peek data from stack', () => {
+  it("should peek data from stack", () => {
     const stack = new Stack();
 
     expect(stack.peek()).toBeNull();
@@ -28,7 +28,7 @@ describe('Stack', () => {
     expect(stack.peek()).toBe(2);
   });
 
-  it('should check if stack is empty', () => {
+  it("should check if stack is empty", () => {
     const stack = new Stack();
 
     expect(stack.isEmpty()).toBe(true);
@@ -38,7 +38,7 @@ describe('Stack', () => {
     expect(stack.isEmpty()).toBe(false);
   });
 
-  it('should pop data from stack', () => {
+  it("should pop data from stack", () => {
     const stack = new Stack();
 
     stack.push(1);
@@ -50,20 +50,20 @@ describe('Stack', () => {
     expect(stack.isEmpty()).toBe(true);
   });
 
-  it('should be possible to push/pop objects', () => {
+  it("should be possible to push/pop objects", () => {
     const stack = new Stack();
 
-    stack.push({ value: 'test1', key: 'key1' });
-    stack.push({ value: 'test2', key: 'key2' });
+    stack.push({ value: "test1", key: "key1" });
+    stack.push({ value: "test2", key: "key2" });
 
     const stringifier = (value) => `${value.key}:${value.value}`;
 
-    expect(stack.toString(stringifier)).toBe('key2:test2,key1:test1');
-    expect(stack.pop().value).toBe('test2');
-    expect(stack.pop().value).toBe('test1');
+    expect(stack.toString(stringifier)).toBe("key2:test2,key1:test1");
+    expect(stack.pop().value).toBe("test2");
+    expect(stack.pop().value).toBe("test1");
   });
 
-  it('should be possible to convert stack to array', () => {
+  it("should be possible to convert stack to array", () => {
     const stack = new Stack();
 
     expect(stack.peek()).toBeNull();
@@ -75,3 +75,4 @@ describe('Stack', () => {
     expect(stack.toArray()).toEqual([3, 2, 1]);
   });
 });
+
diff --git a/src/data-structures/tree/BinaryTreeNode.js b/src/data-structures/tree/BinaryTreeNode.js
index 44c9390..0f00b45 100644
--- a/src/data-structures/tree/BinaryTreeNode.js
+++ b/src/data-structures/tree/BinaryTreeNode.js
@@ -1,11 +1,13 @@
-import Comparator from '../../utils/comparator/Comparator';
-import HashTable from '../hash-table/HashTable';
+import Comparator from "../../utils/comparator/Comparator";
+import HashTable from "../hash-table/HashTable";
 
 export default class BinaryTreeNode {
   /**
    * @param {*} [value] - node value.
    */
-  constructor(value = null) {
+  constructor() {
+    let value =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
     this.left = null;
     this.right = null;
     this.parent = null;
@@ -217,3 +219,4 @@ export default class BinaryTreeNode {
     return this.traverseInOrder().toString();
   }
 }
+
diff --git a/src/data-structures/tree/__test__/BinaryTreeNode.test.js b/src/data-structures/tree/__test__/BinaryTreeNode.test.js
index 8eeda4d..e1d12e5 100644
--- a/src/data-structures/tree/__test__/BinaryTreeNode.test.js
+++ b/src/data-structures/tree/__test__/BinaryTreeNode.test.js
@@ -1,7 +1,7 @@
-import BinaryTreeNode from '../BinaryTreeNode';
+import BinaryTreeNode from "../BinaryTreeNode";
 
-describe('BinaryTreeNode', () => {
-  it('should create node', () => {
+describe("BinaryTreeNode", () => {
+  it("should create node", () => {
     const node = new BinaryTreeNode();
 
     expect(node).toBeDefined();
@@ -14,23 +14,19 @@ describe('BinaryTreeNode', () => {
     const rightNode = new BinaryTreeNode(3);
     const rootNode = new BinaryTreeNode(2);
 
-    rootNode
-      .setLeft(leftNode)
-      .setRight(rightNode);
+    rootNode.setLeft(leftNode).setRight(rightNode);
 
     expect(rootNode.value).toBe(2);
     expect(rootNode.left.value).toBe(1);
     expect(rootNode.right.value).toBe(3);
   });
 
-  it('should set parent', () => {
+  it("should set parent", () => {
     const leftNode = new BinaryTreeNode(1);
     const rightNode = new BinaryTreeNode(3);
     const rootNode = new BinaryTreeNode(2);
 
-    rootNode
-      .setLeft(leftNode)
-      .setRight(rightNode);
+    rootNode.setLeft(leftNode).setRight(rightNode);
 
     expect(rootNode.parent).toBeNull();
     expect(rootNode.left.parent.value).toBe(2);
@@ -38,28 +34,24 @@ describe('BinaryTreeNode', () => {
     expect(rootNode.right.parent).toEqual(rootNode);
   });
 
-  it('should traverse node', () => {
+  it("should traverse node", () => {
     const leftNode = new BinaryTreeNode(1);
     const rightNode = new BinaryTreeNode(3);
     const rootNode = new BinaryTreeNode(2);
 
-    rootNode
-      .setLeft(leftNode)
-      .setRight(rightNode);
+    rootNode.setLeft(leftNode).setRight(rightNode);
 
     expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);
 
-    expect(rootNode.toString()).toBe('1,2,3');
+    expect(rootNode.toString()).toBe("1,2,3");
   });
 
-  it('should remove child node', () => {
+  it("should remove child node", () => {
     const leftNode = new BinaryTreeNode(1);
     const rightNode = new BinaryTreeNode(3);
     const rootNode = new BinaryTreeNode(2);
 
-    rootNode
-      .setLeft(leftNode)
-      .setRight(rightNode);
+    rootNode.setLeft(leftNode).setRight(rightNode);
 
     expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);
 
@@ -73,14 +65,12 @@ describe('BinaryTreeNode', () => {
     expect(rootNode.traverseInOrder()).toEqual([2]);
   });
 
-  it('should replace child node', () => {
+  it("should replace child node", () => {
     const leftNode = new BinaryTreeNode(1);
     const rightNode = new BinaryTreeNode(3);
     const rootNode = new BinaryTreeNode(2);
 
-    rootNode
-      .setLeft(leftNode)
-      .setRight(rightNode);
+    rootNode.setLeft(leftNode).setRight(rightNode);
 
     expect(rootNode.traverseInOrder()).toEqual([1, 2, 3]);
 
@@ -89,12 +79,16 @@ describe('BinaryTreeNode', () => {
 
     expect(rootNode.traverseInOrder()).toEqual([1, 2, 3, 5]);
 
-    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(true);
+    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(
+      true
+    );
     expect(rootNode.right.value).toBe(5);
     expect(rootNode.right.right).toBeNull();
     expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);
 
-    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(false);
+    expect(rootNode.replaceChild(rootNode.right, rootNode.right.right)).toBe(
+      false
+    );
     expect(rootNode.traverseInOrder()).toEqual([1, 2, 5]);
 
     expect(rootNode.replaceChild(rootNode.right, replacementNode)).toBe(true);
@@ -103,10 +97,12 @@ describe('BinaryTreeNode', () => {
     expect(rootNode.replaceChild(rootNode.left, replacementNode)).toBe(true);
     expect(rootNode.traverseInOrder()).toEqual([5, 2, 5]);
 
-    expect(rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())).toBe(false);
+    expect(
+      rootNode.replaceChild(new BinaryTreeNode(), new BinaryTreeNode())
+    ).toBe(false);
   });
 
-  it('should calculate node height', () => {
+  it("should calculate node height", () => {
     const root = new BinaryTreeNode(1);
     const left = new BinaryTreeNode(3);
     const right = new BinaryTreeNode(2);
@@ -117,17 +113,13 @@ describe('BinaryTreeNode', () => {
     expect(root.height).toBe(0);
     expect(root.balanceFactor).toBe(0);
 
-    root
-      .setLeft(left)
-      .setRight(right);
+    root.setLeft(left).setRight(right);
 
     expect(root.height).toBe(1);
     expect(left.height).toBe(0);
     expect(root.balanceFactor).toBe(0);
 
-    left
-      .setLeft(grandLeft)
-      .setRight(grandRight);
+    left.setLeft(grandLeft).setRight(grandRight);
 
     expect(root.height).toBe(2);
     expect(left.height).toBe(1);
@@ -145,7 +137,7 @@ describe('BinaryTreeNode', () => {
     expect(root.balanceFactor).toBe(2);
   });
 
-  it('should calculate node height for right nodes as well', () => {
+  it("should calculate node height for right nodes as well", () => {
     const root = new BinaryTreeNode(1);
     const right = new BinaryTreeNode(2);
 
@@ -156,7 +148,7 @@ describe('BinaryTreeNode', () => {
     expect(root.balanceFactor).toBe(-1);
   });
 
-  it('should set null for left and right node', () => {
+  it("should set null for left and right node", () => {
     const root = new BinaryTreeNode(2);
     const left = new BinaryTreeNode(1);
     const right = new BinaryTreeNode(3);
@@ -174,9 +166,9 @@ describe('BinaryTreeNode', () => {
     expect(root.right).toBeNull();
   });
 
-  it('should be possible to create node with object as a value', () => {
-    const obj1 = { key: 'object_1', toString: () => 'object_1' };
-    const obj2 = { key: 'object_2' };
+  it("should be possible to create node with object as a value", () => {
+    const obj1 = { key: "object_1", toString: () => "object_1" };
+    const obj2 = { key: "object_2" };
 
     const node1 = new BinaryTreeNode(obj1);
     const node2 = new BinaryTreeNode(obj2);
@@ -193,26 +185,26 @@ describe('BinaryTreeNode', () => {
     expect(node2.value).toEqual(obj2);
     expect(node1.left).toBeNull();
 
-    expect(node1.toString()).toBe('object_1');
-    expect(node2.toString()).toBe('[object Object]');
+    expect(node1.toString()).toBe("object_1");
+    expect(node2.toString()).toBe("[object Object]");
   });
 
-  it('should be possible to attach meta information to the node', () => {
+  it("should be possible to attach meta information to the node", () => {
     const redNode = new BinaryTreeNode(1);
     const blackNode = new BinaryTreeNode(2);
 
-    redNode.meta.set('color', 'red');
-    blackNode.meta.set('color', 'black');
+    redNode.meta.set("color", "red");
+    blackNode.meta.set("color", "black");
 
-    expect(redNode.meta.get('color')).toBe('red');
-    expect(blackNode.meta.get('color')).toBe('black');
+    expect(redNode.meta.get("color")).toBe("red");
+    expect(blackNode.meta.get("color")).toBe("black");
   });
 
-  it('should detect right uncle', () => {
-    const grandParent = new BinaryTreeNode('grand-parent');
-    const parent = new BinaryTreeNode('parent');
-    const uncle = new BinaryTreeNode('uncle');
-    const child = new BinaryTreeNode('child');
+  it("should detect right uncle", () => {
+    const grandParent = new BinaryTreeNode("grand-parent");
+    const parent = new BinaryTreeNode("parent");
+    const uncle = new BinaryTreeNode("uncle");
+    const child = new BinaryTreeNode("child");
 
     expect(grandParent.uncle).not.toBeDefined();
     expect(parent.uncle).not.toBeDefined();
@@ -233,11 +225,11 @@ describe('BinaryTreeNode', () => {
     expect(child.uncle).toEqual(uncle);
   });
 
-  it('should detect left uncle', () => {
-    const grandParent = new BinaryTreeNode('grand-parent');
-    const parent = new BinaryTreeNode('parent');
-    const uncle = new BinaryTreeNode('uncle');
-    const child = new BinaryTreeNode('child');
+  it("should detect left uncle", () => {
+    const grandParent = new BinaryTreeNode("grand-parent");
+    const parent = new BinaryTreeNode("parent");
+    const uncle = new BinaryTreeNode("uncle");
+    const child = new BinaryTreeNode("child");
 
     expect(grandParent.uncle).not.toBeDefined();
     expect(parent.uncle).not.toBeDefined();
@@ -258,40 +250,37 @@ describe('BinaryTreeNode', () => {
     expect(child.uncle).toEqual(uncle);
   });
 
-  it('should be possible to set node values', () => {
-    const node = new BinaryTreeNode('initial_value');
+  it("should be possible to set node values", () => {
+    const node = new BinaryTreeNode("initial_value");
 
-    expect(node.value).toBe('initial_value');
+    expect(node.value).toBe("initial_value");
 
-    node.setValue('new_value');
+    node.setValue("new_value");
 
-    expect(node.value).toBe('new_value');
+    expect(node.value).toBe("new_value");
   });
 
-  it('should be possible to copy node', () => {
-    const root = new BinaryTreeNode('root');
-    const left = new BinaryTreeNode('left');
-    const right = new BinaryTreeNode('right');
+  it("should be possible to copy node", () => {
+    const root = new BinaryTreeNode("root");
+    const left = new BinaryTreeNode("left");
+    const right = new BinaryTreeNode("right");
 
-    root
-      .setLeft(left)
-      .setRight(right);
+    root.setLeft(left).setRight(right);
 
-    expect(root.toString()).toBe('left,root,right');
+    expect(root.toString()).toBe("left,root,right");
 
-    const newRoot = new BinaryTreeNode('new_root');
-    const newLeft = new BinaryTreeNode('new_left');
-    const newRight = new BinaryTreeNode('new_right');
+    const newRoot = new BinaryTreeNode("new_root");
+    const newLeft = new BinaryTreeNode("new_left");
+    const newRight = new BinaryTreeNode("new_right");
 
-    newRoot
-      .setLeft(newLeft)
-      .setRight(newRight);
+    newRoot.setLeft(newLeft).setRight(newRight);
 
-    expect(newRoot.toString()).toBe('new_left,new_root,new_right');
+    expect(newRoot.toString()).toBe("new_left,new_root,new_right");
 
     BinaryTreeNode.copyNode(root, newRoot);
 
-    expect(root.toString()).toBe('left,root,right');
-    expect(newRoot.toString()).toBe('left,root,right');
+    expect(root.toString()).toBe("left,root,right");
+    expect(newRoot.toString()).toBe("left,root,right");
   });
 });
+
diff --git a/src/data-structures/tree/avl-tree/AvlTree.js b/src/data-structures/tree/avl-tree/AvlTree.js
index 8a8b5d1..6e0ef68 100644
--- a/src/data-structures/tree/avl-tree/AvlTree.js
+++ b/src/data-structures/tree/avl-tree/AvlTree.js
@@ -1,4 +1,4 @@
-import BinarySearchTree from '../binary-search-tree/BinarySearchTree';
+import BinarySearchTree from "../binary-search-tree/BinarySearchTree";
 
 export default class AvlTree extends BinarySearchTree {
   /**
@@ -161,3 +161,4 @@ export default class AvlTree extends BinarySearchTree {
     rightNode.setLeft(rootNode);
   }
 }
+
diff --git a/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js b/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js
index cf64420..9cceb18 100644
--- a/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js
+++ b/src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js
@@ -1,32 +1,32 @@
-import AvlTree from '../AvlTree';
+import AvlTree from "../AvlTree";
 
-describe('AvlTree', () => {
-  it('should do simple left-left rotation', () => {
+describe("AvlTree", () => {
+  it("should do simple left-left rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(4);
     tree.insert(3);
     tree.insert(2);
 
-    expect(tree.toString()).toBe('2,3,4');
+    expect(tree.toString()).toBe("2,3,4");
     expect(tree.root.value).toBe(3);
     expect(tree.root.height).toBe(1);
 
     tree.insert(1);
 
-    expect(tree.toString()).toBe('1,2,3,4');
+    expect(tree.toString()).toBe("1,2,3,4");
     expect(tree.root.value).toBe(3);
     expect(tree.root.height).toBe(2);
 
     tree.insert(0);
 
-    expect(tree.toString()).toBe('0,1,2,3,4');
+    expect(tree.toString()).toBe("0,1,2,3,4");
     expect(tree.root.value).toBe(3);
     expect(tree.root.left.value).toBe(1);
     expect(tree.root.height).toBe(2);
   });
 
-  it('should do complex left-left rotation', () => {
+  it("should do complex left-left rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(30);
@@ -36,45 +36,45 @@ describe('AvlTree', () => {
 
     expect(tree.root.value).toBe(30);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('10,20,30,40');
+    expect(tree.toString()).toBe("10,20,30,40");
 
     tree.insert(25);
     expect(tree.root.value).toBe(30);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('10,20,25,30,40');
+    expect(tree.toString()).toBe("10,20,25,30,40");
 
     tree.insert(5);
     expect(tree.root.value).toBe(20);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('5,10,20,25,30,40');
+    expect(tree.toString()).toBe("5,10,20,25,30,40");
   });
 
-  it('should do simple right-right rotation', () => {
+  it("should do simple right-right rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(2);
     tree.insert(3);
     tree.insert(4);
 
-    expect(tree.toString()).toBe('2,3,4');
+    expect(tree.toString()).toBe("2,3,4");
     expect(tree.root.value).toBe(3);
     expect(tree.root.height).toBe(1);
 
     tree.insert(5);
 
-    expect(tree.toString()).toBe('2,3,4,5');
+    expect(tree.toString()).toBe("2,3,4,5");
     expect(tree.root.value).toBe(3);
     expect(tree.root.height).toBe(2);
 
     tree.insert(6);
 
-    expect(tree.toString()).toBe('2,3,4,5,6');
+    expect(tree.toString()).toBe("2,3,4,5,6");
     expect(tree.root.value).toBe(3);
     expect(tree.root.right.value).toBe(5);
     expect(tree.root.height).toBe(2);
   });
 
-  it('should do complex right-right rotation', () => {
+  it("should do complex right-right rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(30);
@@ -84,20 +84,20 @@ describe('AvlTree', () => {
 
     expect(tree.root.value).toBe(30);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('20,30,40,50');
+    expect(tree.toString()).toBe("20,30,40,50");
 
     tree.insert(35);
     expect(tree.root.value).toBe(30);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('20,30,35,40,50');
+    expect(tree.toString()).toBe("20,30,35,40,50");
 
     tree.insert(55);
     expect(tree.root.value).toBe(40);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('20,30,35,40,50,55');
+    expect(tree.toString()).toBe("20,30,35,40,50,55");
   });
 
-  it('should do left-right rotation', () => {
+  it("should do left-right rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(30);
@@ -106,10 +106,10 @@ describe('AvlTree', () => {
 
     expect(tree.root.height).toBe(1);
     expect(tree.root.value).toBe(25);
-    expect(tree.toString()).toBe('20,25,30');
+    expect(tree.toString()).toBe("20,25,30");
   });
 
-  it('should do right-left rotation', () => {
+  it("should do right-left rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(30);
@@ -118,10 +118,10 @@ describe('AvlTree', () => {
 
     expect(tree.root.height).toBe(1);
     expect(tree.root.value).toBe(35);
-    expect(tree.toString()).toBe('30,35,40');
+    expect(tree.toString()).toBe("30,35,40");
   });
 
-  it('should create balanced tree: case #1', () => {
+  it("should create balanced tree: case #1", () => {
     // @see: https://www.youtube.com/watch?v=rbg7Qf8GkQ4&t=839s
     const tree = new AvlTree();
 
@@ -131,40 +131,40 @@ describe('AvlTree', () => {
 
     expect(tree.root.value).toBe(2);
     expect(tree.root.height).toBe(1);
-    expect(tree.toString()).toBe('1,2,3');
+    expect(tree.toString()).toBe("1,2,3");
 
     tree.insert(6);
 
     expect(tree.root.value).toBe(2);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('1,2,3,6');
+    expect(tree.toString()).toBe("1,2,3,6");
 
     tree.insert(15);
 
     expect(tree.root.value).toBe(2);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('1,2,3,6,15');
+    expect(tree.toString()).toBe("1,2,3,6,15");
 
     tree.insert(-2);
 
     expect(tree.root.value).toBe(2);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('-2,1,2,3,6,15');
+    expect(tree.toString()).toBe("-2,1,2,3,6,15");
 
     tree.insert(-5);
 
     expect(tree.root.value).toBe(2);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('-5,-2,1,2,3,6,15');
+    expect(tree.toString()).toBe("-5,-2,1,2,3,6,15");
 
     tree.insert(-8);
 
     expect(tree.root.value).toBe(2);
     expect(tree.root.height).toBe(3);
-    expect(tree.toString()).toBe('-8,-5,-2,1,2,3,6,15');
+    expect(tree.toString()).toBe("-8,-5,-2,1,2,3,6,15");
   });
 
-  it('should create balanced tree: case #2', () => {
+  it("should create balanced tree: case #2", () => {
     // @see https://www.youtube.com/watch?v=7m94k2Qhg68
     const tree = new AvlTree();
 
@@ -177,16 +177,16 @@ describe('AvlTree', () => {
 
     expect(tree.root.value).toBe(18);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('6,9,18,21,22,43');
+    expect(tree.toString()).toBe("6,9,18,21,22,43");
 
     tree.insert(8);
 
     expect(tree.root.value).toBe(18);
     expect(tree.root.height).toBe(2);
-    expect(tree.toString()).toBe('6,8,9,18,21,22,43');
+    expect(tree.toString()).toBe("6,8,9,18,21,22,43");
   });
 
-  it('should do left right rotation and keeping left right node safe', () => {
+  it("should do left right rotation and keeping left right node safe", () => {
     const tree = new AvlTree();
 
     tree.insert(30);
@@ -199,16 +199,16 @@ describe('AvlTree', () => {
     tree.insert(5);
     tree.insert(12);
 
-    expect(tree.toString()).toBe('5,10,12,15,18,30,35,40,45');
+    expect(tree.toString()).toBe("5,10,12,15,18,30,35,40,45");
     expect(tree.root.height).toBe(3);
 
     tree.insert(11);
 
-    expect(tree.toString()).toBe('5,10,11,12,15,18,30,35,40,45');
+    expect(tree.toString()).toBe("5,10,11,12,15,18,30,35,40,45");
     expect(tree.root.height).toBe(3);
   });
 
-  it('should do left right rotation and keeping left right node safe', () => {
+  it("should do left right rotation and keeping left right node safe", () => {
     const tree = new AvlTree();
 
     tree.insert(30);
@@ -221,16 +221,16 @@ describe('AvlTree', () => {
     tree.insert(42);
     tree.insert(47);
 
-    expect(tree.toString()).toBe('10,15,18,30,35,40,42,45,47');
+    expect(tree.toString()).toBe("10,15,18,30,35,40,42,45,47");
     expect(tree.root.height).toBe(3);
 
     tree.insert(43);
 
-    expect(tree.toString()).toBe('10,15,18,30,35,40,42,43,45,47');
+    expect(tree.toString()).toBe("10,15,18,30,35,40,42,43,45,47");
     expect(tree.root.height).toBe(3);
   });
 
-  it('should remove values from the tree with right-right rotation', () => {
+  it("should remove values from the tree with right-right rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(10);
@@ -238,18 +238,18 @@ describe('AvlTree', () => {
     tree.insert(30);
     tree.insert(40);
 
-    expect(tree.toString()).toBe('10,20,30,40');
+    expect(tree.toString()).toBe("10,20,30,40");
 
     tree.remove(10);
 
-    expect(tree.toString()).toBe('20,30,40');
+    expect(tree.toString()).toBe("20,30,40");
     expect(tree.root.value).toBe(30);
     expect(tree.root.left.value).toBe(20);
     expect(tree.root.right.value).toBe(40);
     expect(tree.root.balanceFactor).toBe(0);
   });
 
-  it('should remove values from the tree with left-left rotation', () => {
+  it("should remove values from the tree with left-left rotation", () => {
     const tree = new AvlTree();
 
     tree.insert(10);
@@ -257,18 +257,18 @@ describe('AvlTree', () => {
     tree.insert(30);
     tree.insert(5);
 
-    expect(tree.toString()).toBe('5,10,20,30');
+    expect(tree.toString()).toBe("5,10,20,30");
 
     tree.remove(30);
 
-    expect(tree.toString()).toBe('5,10,20');
+    expect(tree.toString()).toBe("5,10,20");
     expect(tree.root.value).toBe(10);
     expect(tree.root.left.value).toBe(5);
     expect(tree.root.right.value).toBe(20);
     expect(tree.root.balanceFactor).toBe(0);
   });
 
-  it('should keep balance after removal', () => {
+  it("should keep balance after removal", () => {
     const tree = new AvlTree();
 
     tree.insert(1);
@@ -281,7 +281,7 @@ describe('AvlTree', () => {
     tree.insert(8);
     tree.insert(9);
 
-    expect(tree.toString()).toBe('1,2,3,4,5,6,7,8,9');
+    expect(tree.toString()).toBe("1,2,3,4,5,6,7,8,9");
     expect(tree.root.value).toBe(4);
     expect(tree.root.height).toBe(3);
     expect(tree.root.balanceFactor).toBe(-1);
@@ -295,9 +295,10 @@ describe('AvlTree', () => {
 
     expect(tree.contains(8)).toBeFalsy();
     expect(tree.contains(9)).toBeFalsy();
-    expect(tree.toString()).toBe('1,2,3,4,5,6,7');
+    expect(tree.toString()).toBe("1,2,3,4,5,6,7");
     expect(tree.root.value).toBe(4);
     expect(tree.root.height).toBe(2);
     expect(tree.root.balanceFactor).toBe(0);
   });
 });
+
diff --git a/src/data-structures/tree/binary-search-tree/BinarySearchTree.js b/src/data-structures/tree/binary-search-tree/BinarySearchTree.js
index b9e2dda..441f9eb 100644
--- a/src/data-structures/tree/binary-search-tree/BinarySearchTree.js
+++ b/src/data-structures/tree/binary-search-tree/BinarySearchTree.js
@@ -1,4 +1,4 @@
-import BinarySearchTreeNode from './BinarySearchTreeNode';
+import BinarySearchTreeNode from "./BinarySearchTreeNode";
 
 export default class BinarySearchTree {
   /**
@@ -42,3 +42,4 @@ export default class BinarySearchTree {
     return this.root.toString();
   }
 }
+
diff --git a/src/data-structures/tree/binary-search-tree/BinarySearchTreeNode.js b/src/data-structures/tree/binary-search-tree/BinarySearchTreeNode.js
index 314f8e0..d0c1959 100644
--- a/src/data-structures/tree/binary-search-tree/BinarySearchTreeNode.js
+++ b/src/data-structures/tree/binary-search-tree/BinarySearchTreeNode.js
@@ -1,12 +1,18 @@
-import BinaryTreeNode from '../BinaryTreeNode';
-import Comparator from '../../../utils/comparator/Comparator';
+import BinaryTreeNode from "../BinaryTreeNode";
+import Comparator from "../../../utils/comparator/Comparator";
 
 export default class BinarySearchTreeNode extends BinaryTreeNode {
   /**
    * @param {*} [value] - node value.
    * @param {function} [compareFunction] - comparator function for node values.
    */
-  constructor(value = null, compareFunction = undefined) {
+  constructor() {
+    let value =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
+    let compareFunction =
+      arguments.length > 1 && arguments[1] !== undefined
+        ? arguments[1]
+        : undefined;
     super(value);
 
     // This comparator is used to compare node values with each other.
@@ -91,10 +97,10 @@ export default class BinarySearchTreeNode extends BinaryTreeNode {
     const nodeToRemove = this.find(value);
 
     if (!nodeToRemove) {
-      throw new Error('Item not found in the tree');
+      throw new Error("Item not found in the tree");
     }
 
-    const { parent } = nodeToRemove;
+    const parent = nodeToRemove.parent;
 
     if (!nodeToRemove.left && !nodeToRemove.right) {
       // Node is a leaf and thus has no children.
@@ -149,3 +155,4 @@ export default class BinarySearchTreeNode extends BinaryTreeNode {
     return this.left.findMin();
   }
 }
+
diff --git a/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js b/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js
index 105f94b..8a4be69 100644
--- a/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js
+++ b/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTree.test.js
@@ -1,7 +1,7 @@
-import BinarySearchTree from '../BinarySearchTree';
+import BinarySearchTree from "../BinarySearchTree";
 
-describe('BinarySearchTree', () => {
-  it('should create binary search tree', () => {
+describe("BinarySearchTree", () => {
+  it("should create binary search tree", () => {
     const bst = new BinarySearchTree();
 
     expect(bst).toBeDefined();
@@ -11,19 +11,19 @@ describe('BinarySearchTree', () => {
     expect(bst.root.right).toBeNull();
   });
 
-  it('should insert values', () => {
+  it("should insert values", () => {
     const bst = new BinarySearchTree();
 
     const insertedNode1 = bst.insert(10);
     const insertedNode2 = bst.insert(20);
     bst.insert(5);
 
-    expect(bst.toString()).toBe('5,10,20');
+    expect(bst.toString()).toBe("5,10,20");
     expect(insertedNode1.value).toBe(10);
     expect(insertedNode2.value).toBe(20);
   });
 
-  it('should check if value exists', () => {
+  it("should check if value exists", () => {
     const bst = new BinarySearchTree();
 
     bst.insert(10);
@@ -34,25 +34,25 @@ describe('BinarySearchTree', () => {
     expect(bst.contains(40)).toBe(false);
   });
 
-  it('should remove nodes', () => {
+  it("should remove nodes", () => {
     const bst = new BinarySearchTree();
 
     bst.insert(10);
     bst.insert(20);
     bst.insert(5);
 
-    expect(bst.toString()).toBe('5,10,20');
+    expect(bst.toString()).toBe("5,10,20");
 
     const removed1 = bst.remove(5);
-    expect(bst.toString()).toBe('10,20');
+    expect(bst.toString()).toBe("10,20");
     expect(removed1).toBe(true);
 
     const removed2 = bst.remove(20);
-    expect(bst.toString()).toBe('10');
+    expect(bst.toString()).toBe("10");
     expect(removed2).toBe(true);
   });
 
-  it('should insert object values', () => {
+  it("should insert object values", () => {
     const nodeValueCompareFunction = (a, b) => {
       const normalizedA = a || { value: null };
       const normalizedB = b || { value: null };
@@ -64,9 +64,9 @@ describe('BinarySearchTree', () => {
       return normalizedA.value < normalizedB.value ? -1 : 1;
     };
 
-    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
-    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
-    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };
+    const obj1 = { key: "obj1", value: 1, toString: () => "obj1" };
+    const obj2 = { key: "obj2", value: 2, toString: () => "obj2" };
+    const obj3 = { key: "obj3", value: 3, toString: () => "obj3" };
 
     const bst = new BinarySearchTree(nodeValueCompareFunction);
 
@@ -74,10 +74,10 @@ describe('BinarySearchTree', () => {
     bst.insert(obj3);
     bst.insert(obj1);
 
-    expect(bst.toString()).toBe('obj1,obj2,obj3');
+    expect(bst.toString()).toBe("obj1,obj2,obj3");
   });
 
-  it('should be traversed to sorted array', () => {
+  it("should be traversed to sorted array", () => {
     const bst = new BinarySearchTree();
 
     bst.insert(10);
@@ -87,12 +87,13 @@ describe('BinarySearchTree', () => {
     bst.insert(25);
     bst.insert(6);
 
-    expect(bst.toString()).toBe('-20,-10,6,10,20,25');
+    expect(bst.toString()).toBe("-20,-10,6,10,20,25");
     expect(bst.root.height).toBe(2);
 
     bst.insert(4);
 
-    expect(bst.toString()).toBe('-20,-10,4,6,10,20,25');
+    expect(bst.toString()).toBe("-20,-10,4,6,10,20,25");
     expect(bst.root.height).toBe(3);
   });
 });
+
diff --git a/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js b/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js
index c9a2b6e..45d62b6 100644
--- a/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js
+++ b/src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js
@@ -1,7 +1,7 @@
-import BinarySearchTreeNode from '../BinarySearchTreeNode';
+import BinarySearchTreeNode from "../BinarySearchTreeNode";
 
-describe('BinarySearchTreeNode', () => {
-  it('should create binary search tree', () => {
+describe("BinarySearchTreeNode", () => {
+  it("should create binary search tree", () => {
     const bstNode = new BinarySearchTreeNode(2);
 
     expect(bstNode.value).toBe(2);
@@ -9,7 +9,7 @@ describe('BinarySearchTreeNode', () => {
     expect(bstNode.right).toBeNull();
   });
 
-  it('should insert in itself if it is empty', () => {
+  it("should insert in itself if it is empty", () => {
     const bstNode = new BinarySearchTreeNode();
     bstNode.insert(1);
 
@@ -18,57 +18,57 @@ describe('BinarySearchTreeNode', () => {
     expect(bstNode.right).toBeNull();
   });
 
-  it('should insert nodes in correct order', () => {
+  it("should insert nodes in correct order", () => {
     const bstNode = new BinarySearchTreeNode(2);
     const insertedNode1 = bstNode.insert(1);
 
     expect(insertedNode1.value).toBe(1);
-    expect(bstNode.toString()).toBe('1,2');
+    expect(bstNode.toString()).toBe("1,2");
     expect(bstNode.contains(1)).toBe(true);
     expect(bstNode.contains(3)).toBe(false);
 
     const insertedNode2 = bstNode.insert(3);
 
     expect(insertedNode2.value).toBe(3);
-    expect(bstNode.toString()).toBe('1,2,3');
+    expect(bstNode.toString()).toBe("1,2,3");
     expect(bstNode.contains(3)).toBe(true);
     expect(bstNode.contains(4)).toBe(false);
 
     bstNode.insert(7);
 
-    expect(bstNode.toString()).toBe('1,2,3,7');
+    expect(bstNode.toString()).toBe("1,2,3,7");
     expect(bstNode.contains(7)).toBe(true);
     expect(bstNode.contains(8)).toBe(false);
 
     bstNode.insert(4);
 
-    expect(bstNode.toString()).toBe('1,2,3,4,7');
+    expect(bstNode.toString()).toBe("1,2,3,4,7");
     expect(bstNode.contains(4)).toBe(true);
     expect(bstNode.contains(8)).toBe(false);
 
     bstNode.insert(6);
 
-    expect(bstNode.toString()).toBe('1,2,3,4,6,7');
+    expect(bstNode.toString()).toBe("1,2,3,4,6,7");
     expect(bstNode.contains(6)).toBe(true);
     expect(bstNode.contains(8)).toBe(false);
   });
 
-  it('should not insert duplicates', () => {
+  it("should not insert duplicates", () => {
     const bstNode = new BinarySearchTreeNode(2);
     bstNode.insert(1);
 
-    expect(bstNode.toString()).toBe('1,2');
+    expect(bstNode.toString()).toBe("1,2");
     expect(bstNode.contains(1)).toBe(true);
     expect(bstNode.contains(3)).toBe(false);
 
     bstNode.insert(1);
 
-    expect(bstNode.toString()).toBe('1,2');
+    expect(bstNode.toString()).toBe("1,2");
     expect(bstNode.contains(1)).toBe(true);
     expect(bstNode.contains(3)).toBe(false);
   });
 
-  it('should find min node', () => {
+  it("should find min node", () => {
     const node = new BinarySearchTreeNode(10);
 
     node.insert(20);
@@ -81,7 +81,7 @@ describe('BinarySearchTreeNode', () => {
     expect(node.findMin().value).toBe(1);
   });
 
-  it('should be possible to attach meta information to binary search tree nodes', () => {
+  it("should be possible to attach meta information to binary search tree nodes", () => {
     const node = new BinarySearchTreeNode(10);
 
     node.insert(20);
@@ -90,19 +90,19 @@ describe('BinarySearchTreeNode', () => {
     node.insert(40);
     const node2 = node.insert(1);
 
-    node.meta.set('color', 'red');
-    node1.meta.set('color', 'black');
-    node2.meta.set('color', 'white');
+    node.meta.set("color", "red");
+    node1.meta.set("color", "black");
+    node2.meta.set("color", "white");
 
-    expect(node.meta.get('color')).toBe('red');
+    expect(node.meta.get("color")).toBe("red");
 
     expect(node.findMin()).not.toBeNull();
     expect(node.findMin().value).toBe(1);
-    expect(node.findMin().meta.get('color')).toBe('white');
-    expect(node.find(30).meta.get('color')).toBe('black');
+    expect(node.findMin().meta.get("color")).toBe("white");
+    expect(node.find(30).meta.get("color")).toBe("black");
   });
 
-  it('should find node', () => {
+  it("should find node", () => {
     const node = new BinarySearchTreeNode(10);
 
     node.insert(20);
@@ -116,25 +116,25 @@ describe('BinarySearchTreeNode', () => {
     expect(node.find(5).value).toBe(5);
   });
 
-  it('should remove leaf nodes', () => {
+  it("should remove leaf nodes", () => {
     const bstRootNode = new BinarySearchTreeNode();
 
     bstRootNode.insert(10);
     bstRootNode.insert(20);
     bstRootNode.insert(5);
 
-    expect(bstRootNode.toString()).toBe('5,10,20');
+    expect(bstRootNode.toString()).toBe("5,10,20");
 
     const removed1 = bstRootNode.remove(5);
-    expect(bstRootNode.toString()).toBe('10,20');
+    expect(bstRootNode.toString()).toBe("10,20");
     expect(removed1).toBe(true);
 
     const removed2 = bstRootNode.remove(20);
-    expect(bstRootNode.toString()).toBe('10');
+    expect(bstRootNode.toString()).toBe("10");
     expect(removed2).toBe(true);
   });
 
-  it('should remove nodes with one child', () => {
+  it("should remove nodes with one child", () => {
     const bstRootNode = new BinarySearchTreeNode();
 
     bstRootNode.insert(10);
@@ -142,19 +142,19 @@ describe('BinarySearchTreeNode', () => {
     bstRootNode.insert(5);
     bstRootNode.insert(30);
 
-    expect(bstRootNode.toString()).toBe('5,10,20,30');
+    expect(bstRootNode.toString()).toBe("5,10,20,30");
 
     bstRootNode.remove(20);
-    expect(bstRootNode.toString()).toBe('5,10,30');
+    expect(bstRootNode.toString()).toBe("5,10,30");
 
     bstRootNode.insert(1);
-    expect(bstRootNode.toString()).toBe('1,5,10,30');
+    expect(bstRootNode.toString()).toBe("1,5,10,30");
 
     bstRootNode.remove(5);
-    expect(bstRootNode.toString()).toBe('1,10,30');
+    expect(bstRootNode.toString()).toBe("1,10,30");
   });
 
-  it('should remove nodes with two children', () => {
+  it("should remove nodes with two children", () => {
     const bstRootNode = new BinarySearchTreeNode();
 
     bstRootNode.insert(10);
@@ -164,43 +164,43 @@ describe('BinarySearchTreeNode', () => {
     bstRootNode.insert(15);
     bstRootNode.insert(25);
 
-    expect(bstRootNode.toString()).toBe('5,10,15,20,25,30');
+    expect(bstRootNode.toString()).toBe("5,10,15,20,25,30");
     expect(bstRootNode.find(20).left.value).toBe(15);
     expect(bstRootNode.find(20).right.value).toBe(30);
 
     bstRootNode.remove(20);
-    expect(bstRootNode.toString()).toBe('5,10,15,25,30');
+    expect(bstRootNode.toString()).toBe("5,10,15,25,30");
 
     bstRootNode.remove(15);
-    expect(bstRootNode.toString()).toBe('5,10,25,30');
+    expect(bstRootNode.toString()).toBe("5,10,25,30");
 
     bstRootNode.remove(10);
-    expect(bstRootNode.toString()).toBe('5,25,30');
+    expect(bstRootNode.toString()).toBe("5,25,30");
     expect(bstRootNode.value).toBe(25);
 
     bstRootNode.remove(25);
-    expect(bstRootNode.toString()).toBe('5,30');
+    expect(bstRootNode.toString()).toBe("5,30");
 
     bstRootNode.remove(5);
-    expect(bstRootNode.toString()).toBe('30');
+    expect(bstRootNode.toString()).toBe("30");
   });
 
-  it('should remove node with no parent', () => {
+  it("should remove node with no parent", () => {
     const bstRootNode = new BinarySearchTreeNode();
-    expect(bstRootNode.toString()).toBe('');
+    expect(bstRootNode.toString()).toBe("");
 
     bstRootNode.insert(1);
     bstRootNode.insert(2);
-    expect(bstRootNode.toString()).toBe('1,2');
+    expect(bstRootNode.toString()).toBe("1,2");
 
     bstRootNode.remove(1);
-    expect(bstRootNode.toString()).toBe('2');
+    expect(bstRootNode.toString()).toBe("2");
 
     bstRootNode.remove(2);
-    expect(bstRootNode.toString()).toBe('');
+    expect(bstRootNode.toString()).toBe("");
   });
 
-  it('should throw error when trying to remove not existing node', () => {
+  it("should throw error when trying to remove not existing node", () => {
     const bstRootNode = new BinarySearchTreeNode();
 
     bstRootNode.insert(10);
@@ -213,7 +213,7 @@ describe('BinarySearchTreeNode', () => {
     expect(removeNotExistingElementFromTree).toThrow();
   });
 
-  it('should be possible to use objects as node values', () => {
+  it("should be possible to use objects as node values", () => {
     const nodeValueComparatorCallback = (a, b) => {
       const normalizedA = a || { value: null };
       const normalizedB = b || { value: null };
@@ -225,31 +225,32 @@ describe('BinarySearchTreeNode', () => {
       return normalizedA.value < normalizedB.value ? -1 : 1;
     };
 
-    const obj1 = { key: 'obj1', value: 1, toString: () => 'obj1' };
-    const obj2 = { key: 'obj2', value: 2, toString: () => 'obj2' };
-    const obj3 = { key: 'obj3', value: 3, toString: () => 'obj3' };
+    const obj1 = { key: "obj1", value: 1, toString: () => "obj1" };
+    const obj2 = { key: "obj2", value: 2, toString: () => "obj2" };
+    const obj3 = { key: "obj3", value: 3, toString: () => "obj3" };
 
     const bstNode = new BinarySearchTreeNode(obj2, nodeValueComparatorCallback);
     bstNode.insert(obj1);
 
-    expect(bstNode.toString()).toBe('obj1,obj2');
+    expect(bstNode.toString()).toBe("obj1,obj2");
     expect(bstNode.contains(obj1)).toBe(true);
     expect(bstNode.contains(obj3)).toBe(false);
 
     bstNode.insert(obj3);
 
-    expect(bstNode.toString()).toBe('obj1,obj2,obj3');
+    expect(bstNode.toString()).toBe("obj1,obj2,obj3");
     expect(bstNode.contains(obj3)).toBe(true);
 
     expect(bstNode.findMin().value).toEqual(obj1);
   });
 
-  it('should abandon removed node', () => {
-    const rootNode = new BinarySearchTreeNode('foo');
-    rootNode.insert('bar');
-    const childNode = rootNode.find('bar');
-    rootNode.remove('bar');
+  it("should abandon removed node", () => {
+    const rootNode = new BinarySearchTreeNode("foo");
+    rootNode.insert("bar");
+    const childNode = rootNode.find("bar");
+    rootNode.remove("bar");
 
     expect(childNode.parent).toBeNull();
   });
 });
+
diff --git a/src/data-structures/tree/fenwick-tree/FenwickTree.js b/src/data-structures/tree/fenwick-tree/FenwickTree.js
index 9146fa1..00acb34 100644
--- a/src/data-structures/tree/fenwick-tree/FenwickTree.js
+++ b/src/data-structures/tree/fenwick-tree/FenwickTree.js
@@ -21,10 +21,10 @@ export default class FenwickTree {
    */
   increase(position, value) {
     if (position < 1 || position > this.arraySize) {
-      throw new Error('Position is out of allowed range');
+      throw new Error("Position is out of allowed range");
     }
 
-    for (let i = position; i <= this.arraySize; i += (i & -i)) {
+    for (let i = position; i <= this.arraySize; i += i & -i) {
       this.treeArray[i] += value;
     }
 
@@ -39,12 +39,12 @@ export default class FenwickTree {
    */
   query(position) {
     if (position < 1 || position > this.arraySize) {
-      throw new Error('Position is out of allowed range');
+      throw new Error("Position is out of allowed range");
     }
 
     let sum = 0;
 
-    for (let i = position; i > 0; i -= (i & -i)) {
+    for (let i = position; i > 0; i -= i & -i) {
       sum += this.treeArray[i];
     }
 
@@ -60,7 +60,7 @@ export default class FenwickTree {
    */
   queryRange(leftIndex, rightIndex) {
     if (leftIndex > rightIndex) {
-      throw new Error('Left index can not be greater than right one');
+      throw new Error("Left index can not be greater than right one");
     }
 
     if (leftIndex === 1) {
@@ -70,3 +70,4 @@ export default class FenwickTree {
     return this.query(rightIndex) - this.query(leftIndex - 1);
   }
 }
+
diff --git a/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js b/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js
index 0fd7165..0954212 100644
--- a/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js
+++ b/src/data-structures/tree/fenwick-tree/__test__/FenwickTree.test.js
@@ -1,7 +1,7 @@
-import FenwickTree from '../FenwickTree';
+import FenwickTree from "../FenwickTree";
 
-describe('FenwickTree', () => {
-  it('should create empty fenwick tree of correct size', () => {
+describe("FenwickTree", () => {
+  it("should create empty fenwick tree of correct size", () => {
     const tree1 = new FenwickTree(5);
     expect(tree1.treeArray.length).toBe(5 + 1);
 
@@ -13,7 +13,7 @@ describe('FenwickTree', () => {
     expect(tree2.treeArray.length).toBe(50 + 1);
   });
 
-  it('should create correct fenwick tree', () => {
+  it("should create correct fenwick tree", () => {
     const inputArray = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3];
 
     const tree = new FenwickTree(inputArray.length);
@@ -62,7 +62,7 @@ describe('FenwickTree', () => {
     expect(tree.queryRange(6, 9)).toBe(11);
   });
 
-  it('should correctly execute queries', () => {
+  it("should correctly execute queries", () => {
     const tree = new FenwickTree(5);
 
     tree.increase(1, 4);
@@ -82,7 +82,7 @@ describe('FenwickTree', () => {
     expect(tree.queryRange(1, 5)).toBe(19);
   });
 
-  it('should throw exceptions', () => {
+  it("should throw exceptions", () => {
     const tree = new FenwickTree(5);
 
     const increaseAtInvalidLowIndex = () => {
@@ -112,3 +112,4 @@ describe('FenwickTree', () => {
     expect(rangeQueryInvalidIndex).toThrowError();
   });
 });
+
diff --git a/src/data-structures/tree/red-black-tree/RedBlackTree.js b/src/data-structures/tree/red-black-tree/RedBlackTree.js
index 6e747af..ada784f 100644
--- a/src/data-structures/tree/red-black-tree/RedBlackTree.js
+++ b/src/data-structures/tree/red-black-tree/RedBlackTree.js
@@ -1,13 +1,13 @@
-import BinarySearchTree from '../binary-search-tree/BinarySearchTree';
+import BinarySearchTree from "../binary-search-tree/BinarySearchTree";
 
 // Possible colors of red-black tree nodes.
 const RED_BLACK_TREE_COLORS = {
-  red: 'red',
-  black: 'black',
+  red: "red",
+  black: "black",
 };
 
 // Color property name in meta information of the nodes.
-const COLOR_PROP_NAME = 'color';
+const COLOR_PROP_NAME = "color";
 
 export default class RedBlackTree extends BinarySearchTree {
   /**
@@ -37,7 +37,9 @@ export default class RedBlackTree extends BinarySearchTree {
    * @return {boolean}
    */
   remove(value) {
-    throw new Error(`Can't remove ${value}. Remove method is not implemented yet`);
+    throw new Error(
+      `Can't remove ${value}. Remove method is not implemented yet`
+    );
   }
 
   /**
@@ -127,7 +129,10 @@ export default class RedBlackTree extends BinarySearchTree {
     // Check what type of sibling is our grandParentNode is (left or right).
     let grandParentNodeIsLeft;
     if (grandGrandParent) {
-      grandParentNodeIsLeft = this.nodeComparator.equal(grandGrandParent.left, grandParentNode);
+      grandParentNodeIsLeft = this.nodeComparator.equal(
+        grandGrandParent.left,
+        grandParentNode
+      );
     }
 
     // Memorize grandParentNode's left node.
@@ -202,7 +207,10 @@ export default class RedBlackTree extends BinarySearchTree {
     // Check what type of sibling is our grandParentNode is (left or right).
     let grandParentNodeIsLeft;
     if (grandGrandParent) {
-      grandParentNodeIsLeft = this.nodeComparator.equal(grandGrandParent.left, grandParentNode);
+      grandParentNodeIsLeft = this.nodeComparator.equal(
+        grandGrandParent.left,
+        grandParentNode
+      );
     }
 
     // Memorize grandParentNode's right node.
@@ -321,3 +329,4 @@ export default class RedBlackTree extends BinarySearchTree {
     secondNode.meta.set(COLOR_PROP_NAME, firstColor);
   }
 }
+
diff --git a/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js b/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js
index 39e35f0..fb64043 100644
--- a/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js
+++ b/src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js
@@ -1,7 +1,7 @@
-import RedBlackTree from '../RedBlackTree';
+import RedBlackTree from "../RedBlackTree";
 
-describe('RedBlackTree', () => {
-  it('should always color first inserted node as black', () => {
+describe("RedBlackTree", () => {
+  it("should always color first inserted node as black", () => {
     const tree = new RedBlackTree();
 
     const firstInsertedNode = tree.insert(10);
@@ -10,11 +10,11 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeBlack(firstInsertedNode)).toBe(true);
     expect(tree.isNodeRed(firstInsertedNode)).toBe(false);
 
-    expect(tree.toString()).toBe('10');
+    expect(tree.toString()).toBe("10");
     expect(tree.root.height).toBe(0);
   });
 
-  it('should always color new leaf node as red', () => {
+  it("should always color new leaf node as red", () => {
     const tree = new RedBlackTree();
 
     const firstInsertedNode = tree.insert(10);
@@ -25,11 +25,11 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeRed(secondInsertedNode)).toBe(true);
     expect(tree.isNodeRed(thirdInsertedNode)).toBe(true);
 
-    expect(tree.toString()).toBe('5,10,15');
+    expect(tree.toString()).toBe("5,10,15");
     expect(tree.root.height).toBe(1);
   });
 
-  it('should balance itself', () => {
+  it("should balance itself", () => {
     const tree = new RedBlackTree();
 
     tree.insert(5);
@@ -39,11 +39,11 @@ describe('RedBlackTree', () => {
     tree.insert(25);
     tree.insert(30);
 
-    expect(tree.toString()).toBe('5,10,15,20,25,30');
+    expect(tree.toString()).toBe("5,10,15,20,25,30");
     expect(tree.root.height).toBe(3);
   });
 
-  it('should balance itself when parent is black', () => {
+  it("should balance itself when parent is black", () => {
     const tree = new RedBlackTree();
 
     const node1 = tree.insert(10);
@@ -85,14 +85,14 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeRed(node5)).toBe(true);
     expect(tree.isNodeRed(node6)).toBe(true);
 
-    expect(tree.toString()).toBe('-20,-10,6,10,20,25');
+    expect(tree.toString()).toBe("-20,-10,6,10,20,25");
     expect(tree.root.height).toBe(2);
 
     const node7 = tree.insert(4);
 
     expect(tree.root.left.value).toEqual(node2.value);
 
-    expect(tree.toString()).toBe('-20,-10,4,6,10,20,25');
+    expect(tree.toString()).toBe("-20,-10,4,6,10,20,25");
     expect(tree.root.height).toBe(3);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -105,7 +105,7 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeRed(node7)).toBe(true);
   });
 
-  it('should balance itself when uncle is red', () => {
+  it("should balance itself when uncle is red", () => {
     const tree = new RedBlackTree();
 
     const node1 = tree.insert(10);
@@ -118,7 +118,7 @@ describe('RedBlackTree', () => {
     const node8 = tree.insert(2);
     const node9 = tree.insert(8);
 
-    expect(tree.toString()).toBe('-20,-10,2,6,8,10,15,20,25');
+    expect(tree.toString()).toBe("-20,-10,2,6,8,10,15,20,25");
     expect(tree.root.height).toBe(3);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -133,7 +133,7 @@ describe('RedBlackTree', () => {
 
     const node10 = tree.insert(4);
 
-    expect(tree.toString()).toBe('-20,-10,2,4,6,8,10,15,20,25');
+    expect(tree.toString()).toBe("-20,-10,2,4,6,8,10,15,20,25");
     expect(tree.root.height).toBe(3);
 
     expect(tree.root.value).toBe(node5.value);
@@ -150,7 +150,7 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeBlack(node3)).toBe(true);
   });
 
-  it('should do left-left rotation', () => {
+  it("should do left-left rotation", () => {
     const tree = new RedBlackTree();
 
     const node1 = tree.insert(10);
@@ -159,7 +159,7 @@ describe('RedBlackTree', () => {
     const node4 = tree.insert(7);
     const node5 = tree.insert(15);
 
-    expect(tree.toString()).toBe('-10,7,10,15,20');
+    expect(tree.toString()).toBe("-10,7,10,15,20");
     expect(tree.root.height).toBe(2);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -170,7 +170,7 @@ describe('RedBlackTree', () => {
 
     const node6 = tree.insert(13);
 
-    expect(tree.toString()).toBe('-10,7,10,13,15,20');
+    expect(tree.toString()).toBe("-10,7,10,13,15,20");
     expect(tree.root.height).toBe(2);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -181,7 +181,7 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeRed(node3)).toBe(true);
   });
 
-  it('should do left-right rotation', () => {
+  it("should do left-right rotation", () => {
     const tree = new RedBlackTree();
 
     const node1 = tree.insert(10);
@@ -190,7 +190,7 @@ describe('RedBlackTree', () => {
     const node4 = tree.insert(7);
     const node5 = tree.insert(15);
 
-    expect(tree.toString()).toBe('-10,7,10,15,20');
+    expect(tree.toString()).toBe("-10,7,10,15,20");
     expect(tree.root.height).toBe(2);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -201,7 +201,7 @@ describe('RedBlackTree', () => {
 
     const node6 = tree.insert(17);
 
-    expect(tree.toString()).toBe('-10,7,10,15,17,20');
+    expect(tree.toString()).toBe("-10,7,10,15,17,20");
     expect(tree.root.height).toBe(2);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -212,7 +212,7 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeRed(node3)).toBe(true);
   });
 
-  it('should do recoloring, left-left and left-right rotation', () => {
+  it("should do recoloring, left-left and left-right rotation", () => {
     const tree = new RedBlackTree();
 
     const node1 = tree.insert(10);
@@ -225,7 +225,7 @@ describe('RedBlackTree', () => {
     const node8 = tree.insert(1);
     const node9 = tree.insert(9);
 
-    expect(tree.toString()).toBe('-20,-10,1,6,9,10,15,20,30');
+    expect(tree.toString()).toBe("-20,-10,1,6,9,10,15,20,30");
     expect(tree.root.height).toBe(3);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -240,11 +240,11 @@ describe('RedBlackTree', () => {
 
     tree.insert(4);
 
-    expect(tree.toString()).toBe('-20,-10,1,4,6,9,10,15,20,30');
+    expect(tree.toString()).toBe("-20,-10,1,4,6,9,10,15,20,30");
     expect(tree.root.height).toBe(3);
   });
 
-  it('should do right-left rotation', () => {
+  it("should do right-left rotation", () => {
     const tree = new RedBlackTree();
 
     const node1 = tree.insert(10);
@@ -254,7 +254,7 @@ describe('RedBlackTree', () => {
     const node5 = tree.insert(6);
     const node6 = tree.insert(30);
 
-    expect(tree.toString()).toBe('-20,-10,6,10,20,30');
+    expect(tree.toString()).toBe("-20,-10,6,10,20,30");
     expect(tree.root.height).toBe(2);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -274,7 +274,7 @@ describe('RedBlackTree', () => {
     expect(rightLeftNode.value).toBe(node3.value);
     expect(rightRightNode.value).toBe(node6.value);
 
-    expect(tree.toString()).toBe('-20,-10,6,10,20,25,30');
+    expect(tree.toString()).toBe("-20,-10,6,10,20,25,30");
     expect(tree.root.height).toBe(2);
 
     expect(tree.isNodeBlack(node1)).toBe(true);
@@ -286,7 +286,7 @@ describe('RedBlackTree', () => {
     expect(tree.isNodeRed(node6)).toBe(true);
   });
 
-  it('should do left-left rotation with left grand-parent', () => {
+  it("should do left-left rotation with left grand-parent", () => {
     const tree = new RedBlackTree();
 
     tree.insert(20);
@@ -295,11 +295,11 @@ describe('RedBlackTree', () => {
     tree.insert(10);
     tree.insert(5);
 
-    expect(tree.toString()).toBe('5,10,15,20,25');
+    expect(tree.toString()).toBe("5,10,15,20,25");
     expect(tree.root.height).toBe(2);
   });
 
-  it('should do right-right rotation with left grand-parent', () => {
+  it("should do right-right rotation with left grand-parent", () => {
     const tree = new RedBlackTree();
 
     tree.insert(20);
@@ -308,11 +308,11 @@ describe('RedBlackTree', () => {
     tree.insert(17);
     tree.insert(19);
 
-    expect(tree.toString()).toBe('15,17,19,20,25');
+    expect(tree.toString()).toBe("15,17,19,20,25");
     expect(tree.root.height).toBe(2);
   });
 
-  it('should throw an error when trying to remove node', () => {
+  it("should throw an error when trying to remove node", () => {
     const removeNodeFromRedBlackTree = () => {
       const tree = new RedBlackTree();
 
@@ -322,3 +322,4 @@ describe('RedBlackTree', () => {
     expect(removeNodeFromRedBlackTree).toThrowError();
   });
 });
+
diff --git a/src/data-structures/tree/segment-tree/SegmentTree.js b/src/data-structures/tree/segment-tree/SegmentTree.js
index f37d334..805c47a 100644
--- a/src/data-structures/tree/segment-tree/SegmentTree.js
+++ b/src/data-structures/tree/segment-tree/SegmentTree.js
@@ -1,4 +1,4 @@
-import isPowerOfTwo from '../../../algorithms/math/is-power-of-two/isPowerOfTwo';
+import isPowerOfTwo from "../../../algorithms/math/is-power-of-two/isPowerOfTwo";
 
 export default class SegmentTree {
   /**
@@ -27,7 +27,7 @@ export default class SegmentTree {
 
     if (isPowerOfTwo(inputArrayLength)) {
       // If original array length is a power of two.
-      segmentTreeArrayLength = (2 * inputArrayLength) - 1;
+      segmentTreeArrayLength = 2 * inputArrayLength - 1;
     } else {
       // If original array length is not a power of two then we need to find
       // next number that is a power of two and use it to calculate
@@ -36,7 +36,7 @@ export default class SegmentTree {
       const currentPower = Math.floor(Math.log2(inputArrayLength));
       const nextPower = currentPower + 1;
       const nextPowerOfTwoNumber = 2 ** nextPower;
-      segmentTreeArrayLength = (2 * nextPowerOfTwoNumber) - 1;
+      segmentTreeArrayLength = 2 * nextPowerOfTwoNumber - 1;
     }
 
     return new Array(segmentTreeArrayLength).fill(null);
@@ -72,15 +72,23 @@ export default class SegmentTree {
     // Split input array on two halves and process them recursively.
     const middleIndex = Math.floor((leftInputIndex + rightInputIndex) / 2);
     // Process left half of the input array.
-    this.buildTreeRecursively(leftInputIndex, middleIndex, this.getLeftChildIndex(position));
+    this.buildTreeRecursively(
+      leftInputIndex,
+      middleIndex,
+      this.getLeftChildIndex(position)
+    );
     // Process right half of the input array.
-    this.buildTreeRecursively(middleIndex + 1, rightInputIndex, this.getRightChildIndex(position));
+    this.buildTreeRecursively(
+      middleIndex + 1,
+      rightInputIndex,
+      this.getRightChildIndex(position)
+    );
 
     // Once every tree leaf is not empty we're able to build tree bottom up using
     // provided operation function.
     this.segmentTree[position] = this.operation(
       this.segmentTree[this.getLeftChildIndex(position)],
-      this.segmentTree[this.getRightChildIndex(position)],
+      this.segmentTree[this.getRightChildIndex(position)]
     );
   }
 
@@ -101,7 +109,7 @@ export default class SegmentTree {
       queryRightIndex,
       leftIndex,
       rightIndex,
-      position,
+      position
     );
   }
 
@@ -115,7 +123,13 @@ export default class SegmentTree {
    * @param {number} position - root position in binary tree
    * @return {number}
    */
-  rangeQueryRecursive(queryLeftIndex, queryRightIndex, leftIndex, rightIndex, position) {
+  rangeQueryRecursive(
+    queryLeftIndex,
+    queryRightIndex,
+    leftIndex,
+    rightIndex,
+    position
+  ) {
     if (queryLeftIndex <= leftIndex && queryRightIndex >= rightIndex) {
       // Total overlap.
       return this.segmentTree[position];
@@ -134,7 +148,7 @@ export default class SegmentTree {
       queryRightIndex,
       leftIndex,
       middleIndex,
-      this.getLeftChildIndex(position),
+      this.getLeftChildIndex(position)
     );
 
     const rightOperationResult = this.rangeQueryRecursive(
@@ -142,7 +156,7 @@ export default class SegmentTree {
       queryRightIndex,
       middleIndex + 1,
       rightIndex,
-      this.getRightChildIndex(position),
+      this.getRightChildIndex(position)
     );
 
     return this.operation(leftOperationResult, rightOperationResult);
@@ -154,7 +168,7 @@ export default class SegmentTree {
    * @return {number}
    */
   getLeftChildIndex(parentIndex) {
-    return (2 * parentIndex) + 1;
+    return 2 * parentIndex + 1;
   }
 
   /**
@@ -163,6 +177,7 @@ export default class SegmentTree {
    * @return {number}
    */
   getRightChildIndex(parentIndex) {
-    return (2 * parentIndex) + 2;
+    return 2 * parentIndex + 2;
   }
 }
+
diff --git a/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js b/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js
index 7832f3e..e4f3a51 100644
--- a/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js
+++ b/src/data-structures/tree/segment-tree/__test__/SegmentTree.test.js
@@ -1,57 +1,72 @@
-import SegmentTree from '../SegmentTree';
+import SegmentTree from "../SegmentTree";
 
-describe('SegmentTree', () => {
-  it('should build tree for input array #0 with length of power of two', () => {
+describe("SegmentTree", () => {
+  it("should build tree for input array #0 with length of power of two", () => {
     const array = [-1, 2];
     const segmentTree = new SegmentTree(array, Math.min, Infinity);
 
     expect(segmentTree.segmentTree).toEqual([-1, -1, 2]);
-    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
+    expect(segmentTree.segmentTree.length).toBe(2 * array.length - 1);
   });
 
-  it('should build tree for input array #1 with length of power of two', () => {
+  it("should build tree for input array #1 with length of power of two", () => {
     const array = [-1, 2, 4, 0];
     const segmentTree = new SegmentTree(array, Math.min, Infinity);
 
     expect(segmentTree.segmentTree).toEqual([-1, -1, 0, -1, 2, 4, 0]);
-    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
+    expect(segmentTree.segmentTree.length).toBe(2 * array.length - 1);
   });
 
-  it('should build tree for input array #0 with length not of power of two', () => {
+  it("should build tree for input array #0 with length not of power of two", () => {
     const array = [0, 1, 2];
     const segmentTree = new SegmentTree(array, Math.min, Infinity);
 
     expect(segmentTree.segmentTree).toEqual([0, 0, 2, 0, 1, null, null]);
-    expect(segmentTree.segmentTree.length).toBe((2 * 4) - 1);
+    expect(segmentTree.segmentTree.length).toBe(2 * 4 - 1);
   });
 
-  it('should build tree for input array #1 with length not of power of two', () => {
+  it("should build tree for input array #1 with length not of power of two", () => {
     const array = [-1, 3, 4, 0, 2, 1];
     const segmentTree = new SegmentTree(array, Math.min, Infinity);
 
     expect(segmentTree.segmentTree).toEqual([
-      -1, -1, 0, -1, 4, 0, 1, -1, 3, null, null, 0, 2, null, null,
+      -1,
+      -1,
+      0,
+      -1,
+      4,
+      0,
+      1,
+      -1,
+      3,
+      null,
+      null,
+      0,
+      2,
+      null,
+      null,
     ]);
-    expect(segmentTree.segmentTree.length).toBe((2 * 8) - 1);
+
+    expect(segmentTree.segmentTree.length).toBe(2 * 8 - 1);
   });
 
-  it('should build max array', () => {
+  it("should build max array", () => {
     const array = [-1, 2, 4, 0];
     const segmentTree = new SegmentTree(array, Math.max, -Infinity);
 
     expect(segmentTree.segmentTree).toEqual([4, 2, 4, -1, 2, 4, 0]);
-    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
+    expect(segmentTree.segmentTree.length).toBe(2 * array.length - 1);
   });
 
-  it('should build sum array', () => {
+  it("should build sum array", () => {
     const array = [-1, 2, 4, 0];
-    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);
+    const segmentTree = new SegmentTree(array, (a, b) => a + b, 0);
 
     expect(segmentTree.segmentTree).toEqual([5, 1, 4, -1, 2, 4, 0]);
-    expect(segmentTree.segmentTree.length).toBe((2 * array.length) - 1);
+    expect(segmentTree.segmentTree.length).toBe(2 * array.length - 1);
   });
 
-  it('should do min range query on power of two length array', () => {
+  it("should do min range query on power of two length array", () => {
     const array = [-1, 3, 4, 0, 2, 1];
     const segmentTree = new SegmentTree(array, Math.min, Infinity);
 
@@ -63,7 +78,7 @@ describe('SegmentTree', () => {
     expect(segmentTree.rangeQuery(2, 2)).toBe(4);
   });
 
-  it('should do min range query on not power of two length array', () => {
+  it("should do min range query on not power of two length array", () => {
     const array = [-1, 2, 4, 0];
     const segmentTree = new SegmentTree(array, Math.min, Infinity);
 
@@ -75,7 +90,7 @@ describe('SegmentTree', () => {
     expect(segmentTree.rangeQuery(2, 2)).toBe(4);
   });
 
-  it('should do max range query', () => {
+  it("should do max range query", () => {
     const array = [-1, 3, 4, 0, 2, 1];
     const segmentTree = new SegmentTree(array, Math.max, -Infinity);
 
@@ -87,9 +102,9 @@ describe('SegmentTree', () => {
     expect(segmentTree.rangeQuery(3, 3)).toBe(0);
   });
 
-  it('should do sum range query', () => {
+  it("should do sum range query", () => {
     const array = [-1, 3, 4, 0, 2, 1];
-    const segmentTree = new SegmentTree(array, (a, b) => (a + b), 0);
+    const segmentTree = new SegmentTree(array, (a, b) => a + b, 0);
 
     expect(segmentTree.rangeQuery(0, 5)).toBe(9);
     expect(segmentTree.rangeQuery(0, 1)).toBe(2);
@@ -99,3 +114,4 @@ describe('SegmentTree', () => {
     expect(segmentTree.rangeQuery(3, 3)).toBe(0);
   });
 });
+
diff --git a/src/data-structures/trie/Trie.js b/src/data-structures/trie/Trie.js
index bd618d2..364f143 100644
--- a/src/data-structures/trie/Trie.js
+++ b/src/data-structures/trie/Trie.js
@@ -1,7 +1,7 @@
-import TrieNode from './TrieNode';
+import TrieNode from "./TrieNode";
 
 // Character that we will use for trie tree root.
-const HEAD_CHARACTER = '*';
+const HEAD_CHARACTER = "*";
 
 export default class Trie {
   constructor() {
@@ -29,7 +29,9 @@ export default class Trie {
    * @return {Trie}
    */
   deleteWord(word) {
-    const depthFirstDelete = (currentNode, charIndex = 0) => {
+    const depthFirstDelete = function (currentNode) {
+      let charIndex =
+        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
       if (charIndex >= word.length) {
         // Return if we're trying to delete the character that is out of word's scope.
         return;
@@ -47,7 +49,7 @@ export default class Trie {
       depthFirstDelete(nextNode, charIndex + 1);
 
       // Since we're going to delete a word let's un-mark its last character isCompleteWord flag.
-      if (charIndex === (word.length - 1)) {
+      if (charIndex === word.length - 1) {
         nextNode.isCompleteWord = false;
       }
 
@@ -108,3 +110,4 @@ export default class Trie {
     return currentNode;
   }
 }
+
diff --git a/src/data-structures/trie/TrieNode.js b/src/data-structures/trie/TrieNode.js
index f650743..2f13ba6 100644
--- a/src/data-structures/trie/TrieNode.js
+++ b/src/data-structures/trie/TrieNode.js
@@ -1,11 +1,13 @@
-import HashTable from '../hash-table/HashTable';
+import HashTable from "../hash-table/HashTable";
 
 export default class TrieNode {
   /**
    * @param {string} character
    * @param {boolean} isCompleteWord
    */
-  constructor(character, isCompleteWord = false) {
+  constructor(character) {
+    let isCompleteWord =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
     this.character = character;
     this.isCompleteWord = isCompleteWord;
     this.children = new HashTable();
@@ -24,7 +26,9 @@ export default class TrieNode {
    * @param {boolean} isCompleteWord
    * @return {TrieNode}
    */
-  addChild(character, isCompleteWord = false) {
+  addChild(character) {
+    let isCompleteWord =
+      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
     if (!this.children.has(character)) {
       this.children.set(character, new TrieNode(character, isCompleteWord));
     }
@@ -47,11 +51,7 @@ export default class TrieNode {
     // Delete childNode only if:
     // - childNode has NO children,
     // - childNode.isCompleteWord === false.
-    if (
-      childNode
-      && !childNode.isCompleteWord
-      && !childNode.hasChildren()
-    ) {
+    if (childNode && !childNode.isCompleteWord && !childNode.hasChildren()) {
       this.children.delete(character);
     }
 
@@ -86,9 +86,10 @@ export default class TrieNode {
    */
   toString() {
     let childrenAsString = this.suggestChildren().toString();
-    childrenAsString = childrenAsString ? `:${childrenAsString}` : '';
-    const isCompleteString = this.isCompleteWord ? '*' : '';
+    childrenAsString = childrenAsString ? `:${childrenAsString}` : "";
+    const isCompleteString = this.isCompleteWord ? "*" : "";
 
     return `${this.character}${isCompleteString}${childrenAsString}`;
   }
 }
+
diff --git a/src/data-structures/trie/__test__/Trie.test.js b/src/data-structures/trie/__test__/Trie.test.js
index 4d60ad9..7082388 100644
--- a/src/data-structures/trie/__test__/Trie.test.js
+++ b/src/data-structures/trie/__test__/Trie.test.js
@@ -1,94 +1,97 @@
-import Trie from '../Trie';
+import Trie from "../Trie";
 
-describe('Trie', () => {
-  it('should create trie', () => {
+describe("Trie", () => {
+  it("should create trie", () => {
     const trie = new Trie();
 
     expect(trie).toBeDefined();
-    expect(trie.head.toString()).toBe('*');
+    expect(trie.head.toString()).toBe("*");
   });
 
-  it('should add words to trie', () => {
+  it("should add words to trie", () => {
     const trie = new Trie();
 
-    trie.addWord('cat');
+    trie.addWord("cat");
 
-    expect(trie.head.toString()).toBe('*:c');
-    expect(trie.head.getChild('c').toString()).toBe('c:a');
+    expect(trie.head.toString()).toBe("*:c");
+    expect(trie.head.getChild("c").toString()).toBe("c:a");
 
-    trie.addWord('car');
-    expect(trie.head.toString()).toBe('*:c');
-    expect(trie.head.getChild('c').toString()).toBe('c:a');
-    expect(trie.head.getChild('c').getChild('a').toString()).toBe('a:t,r');
-    expect(trie.head.getChild('c').getChild('a').getChild('t').toString()).toBe('t*');
+    trie.addWord("car");
+    expect(trie.head.toString()).toBe("*:c");
+    expect(trie.head.getChild("c").toString()).toBe("c:a");
+    expect(trie.head.getChild("c").getChild("a").toString()).toBe("a:t,r");
+    expect(trie.head.getChild("c").getChild("a").getChild("t").toString()).toBe(
+      "t*"
+    );
   });
 
-  it('should delete words from trie', () => {
+  it("should delete words from trie", () => {
     const trie = new Trie();
 
-    trie.addWord('carpet');
-    trie.addWord('car');
-    trie.addWord('cat');
-    trie.addWord('cart');
-    expect(trie.doesWordExist('carpet')).toBe(true);
-    expect(trie.doesWordExist('car')).toBe(true);
-    expect(trie.doesWordExist('cart')).toBe(true);
-    expect(trie.doesWordExist('cat')).toBe(true);
+    trie.addWord("carpet");
+    trie.addWord("car");
+    trie.addWord("cat");
+    trie.addWord("cart");
+    expect(trie.doesWordExist("carpet")).toBe(true);
+    expect(trie.doesWordExist("car")).toBe(true);
+    expect(trie.doesWordExist("cart")).toBe(true);
+    expect(trie.doesWordExist("cat")).toBe(true);
 
     // Try to delete not-existing word first.
-    trie.deleteWord('carpool');
-    expect(trie.doesWordExist('carpet')).toBe(true);
-    expect(trie.doesWordExist('car')).toBe(true);
-    expect(trie.doesWordExist('cart')).toBe(true);
-    expect(trie.doesWordExist('cat')).toBe(true);
-
-    trie.deleteWord('carpet');
-    expect(trie.doesWordExist('carpet')).toEqual(false);
-    expect(trie.doesWordExist('car')).toEqual(true);
-    expect(trie.doesWordExist('cart')).toBe(true);
-    expect(trie.doesWordExist('cat')).toBe(true);
-
-    trie.deleteWord('cat');
-    expect(trie.doesWordExist('car')).toEqual(true);
-    expect(trie.doesWordExist('cart')).toBe(true);
-    expect(trie.doesWordExist('cat')).toBe(false);
-
-    trie.deleteWord('car');
-    expect(trie.doesWordExist('car')).toEqual(false);
-    expect(trie.doesWordExist('cart')).toBe(true);
-
-    trie.deleteWord('cart');
-    expect(trie.doesWordExist('car')).toEqual(false);
-    expect(trie.doesWordExist('cart')).toBe(false);
+    trie.deleteWord("carpool");
+    expect(trie.doesWordExist("carpet")).toBe(true);
+    expect(trie.doesWordExist("car")).toBe(true);
+    expect(trie.doesWordExist("cart")).toBe(true);
+    expect(trie.doesWordExist("cat")).toBe(true);
+
+    trie.deleteWord("carpet");
+    expect(trie.doesWordExist("carpet")).toEqual(false);
+    expect(trie.doesWordExist("car")).toEqual(true);
+    expect(trie.doesWordExist("cart")).toBe(true);
+    expect(trie.doesWordExist("cat")).toBe(true);
+
+    trie.deleteWord("cat");
+    expect(trie.doesWordExist("car")).toEqual(true);
+    expect(trie.doesWordExist("cart")).toBe(true);
+    expect(trie.doesWordExist("cat")).toBe(false);
+
+    trie.deleteWord("car");
+    expect(trie.doesWordExist("car")).toEqual(false);
+    expect(trie.doesWordExist("cart")).toBe(true);
+
+    trie.deleteWord("cart");
+    expect(trie.doesWordExist("car")).toEqual(false);
+    expect(trie.doesWordExist("cart")).toBe(false);
   });
 
-  it('should suggests next characters', () => {
+  it("should suggests next characters", () => {
     const trie = new Trie();
 
-    trie.addWord('cat');
-    trie.addWord('cats');
-    trie.addWord('car');
-    trie.addWord('caption');
+    trie.addWord("cat");
+    trie.addWord("cats");
+    trie.addWord("car");
+    trie.addWord("caption");
 
-    expect(trie.suggestNextCharacters('ca')).toEqual(['t', 'r', 'p']);
-    expect(trie.suggestNextCharacters('cat')).toEqual(['s']);
-    expect(trie.suggestNextCharacters('cab')).toBeNull();
+    expect(trie.suggestNextCharacters("ca")).toEqual(["t", "r", "p"]);
+    expect(trie.suggestNextCharacters("cat")).toEqual(["s"]);
+    expect(trie.suggestNextCharacters("cab")).toBeNull();
   });
 
-  it('should check if word exists', () => {
+  it("should check if word exists", () => {
     const trie = new Trie();
 
-    trie.addWord('cat');
-    trie.addWord('cats');
-    trie.addWord('carpet');
-    trie.addWord('car');
-    trie.addWord('caption');
-
-    expect(trie.doesWordExist('cat')).toBe(true);
-    expect(trie.doesWordExist('cats')).toBe(true);
-    expect(trie.doesWordExist('carpet')).toBe(true);
-    expect(trie.doesWordExist('car')).toBe(true);
-    expect(trie.doesWordExist('cap')).toBe(false);
-    expect(trie.doesWordExist('call')).toBe(false);
+    trie.addWord("cat");
+    trie.addWord("cats");
+    trie.addWord("carpet");
+    trie.addWord("car");
+    trie.addWord("caption");
+
+    expect(trie.doesWordExist("cat")).toBe(true);
+    expect(trie.doesWordExist("cats")).toBe(true);
+    expect(trie.doesWordExist("carpet")).toBe(true);
+    expect(trie.doesWordExist("car")).toBe(true);
+    expect(trie.doesWordExist("cap")).toBe(false);
+    expect(trie.doesWordExist("call")).toBe(false);
   });
 });
+
diff --git a/src/data-structures/trie/__test__/TrieNode.test.js b/src/data-structures/trie/__test__/TrieNode.test.js
index c12c011..813105d 100644
--- a/src/data-structures/trie/__test__/TrieNode.test.js
+++ b/src/data-structures/trie/__test__/TrieNode.test.js
@@ -1,90 +1,91 @@
-import TrieNode from '../TrieNode';
+import TrieNode from "../TrieNode";
 
-describe('TrieNode', () => {
-  it('should create trie node', () => {
-    const trieNode = new TrieNode('c', true);
+describe("TrieNode", () => {
+  it("should create trie node", () => {
+    const trieNode = new TrieNode("c", true);
 
-    expect(trieNode.character).toBe('c');
+    expect(trieNode.character).toBe("c");
     expect(trieNode.isCompleteWord).toBe(true);
-    expect(trieNode.toString()).toBe('c*');
+    expect(trieNode.toString()).toBe("c*");
   });
 
-  it('should add child nodes', () => {
-    const trieNode = new TrieNode('c');
+  it("should add child nodes", () => {
+    const trieNode = new TrieNode("c");
 
-    trieNode.addChild('a', true);
-    trieNode.addChild('o');
+    trieNode.addChild("a", true);
+    trieNode.addChild("o");
 
-    expect(trieNode.toString()).toBe('c:a,o');
+    expect(trieNode.toString()).toBe("c:a,o");
   });
 
-  it('should get child nodes', () => {
-    const trieNode = new TrieNode('c');
+  it("should get child nodes", () => {
+    const trieNode = new TrieNode("c");
 
-    trieNode.addChild('a');
-    trieNode.addChild('o');
+    trieNode.addChild("a");
+    trieNode.addChild("o");
 
-    expect(trieNode.getChild('a').toString()).toBe('a');
-    expect(trieNode.getChild('a').character).toBe('a');
-    expect(trieNode.getChild('o').toString()).toBe('o');
-    expect(trieNode.getChild('b')).toBeUndefined();
+    expect(trieNode.getChild("a").toString()).toBe("a");
+    expect(trieNode.getChild("a").character).toBe("a");
+    expect(trieNode.getChild("o").toString()).toBe("o");
+    expect(trieNode.getChild("b")).toBeUndefined();
   });
 
-  it('should check if node has children', () => {
-    const trieNode = new TrieNode('c');
+  it("should check if node has children", () => {
+    const trieNode = new TrieNode("c");
 
     expect(trieNode.hasChildren()).toBe(false);
 
-    trieNode.addChild('a');
+    trieNode.addChild("a");
 
     expect(trieNode.hasChildren()).toBe(true);
   });
 
-  it('should check if node has specific child', () => {
-    const trieNode = new TrieNode('c');
+  it("should check if node has specific child", () => {
+    const trieNode = new TrieNode("c");
 
-    trieNode.addChild('a');
-    trieNode.addChild('o');
+    trieNode.addChild("a");
+    trieNode.addChild("o");
 
-    expect(trieNode.hasChild('a')).toBe(true);
-    expect(trieNode.hasChild('o')).toBe(true);
-    expect(trieNode.hasChild('b')).toBe(false);
+    expect(trieNode.hasChild("a")).toBe(true);
+    expect(trieNode.hasChild("o")).toBe(true);
+    expect(trieNode.hasChild("b")).toBe(false);
   });
 
-  it('should suggest next children', () => {
-    const trieNode = new TrieNode('c');
+  it("should suggest next children", () => {
+    const trieNode = new TrieNode("c");
 
-    trieNode.addChild('a');
-    trieNode.addChild('o');
+    trieNode.addChild("a");
+    trieNode.addChild("o");
 
-    expect(trieNode.suggestChildren()).toEqual(['a', 'o']);
+    expect(trieNode.suggestChildren()).toEqual(["a", "o"]);
   });
 
-  it('should delete child node if the child node has NO children', () => {
-    const trieNode = new TrieNode('c');
-    trieNode.addChild('a');
-    expect(trieNode.hasChild('a')).toBe(true);
+  it("should delete child node if the child node has NO children", () => {
+    const trieNode = new TrieNode("c");
+    trieNode.addChild("a");
+    expect(trieNode.hasChild("a")).toBe(true);
 
-    trieNode.removeChild('a');
-    expect(trieNode.hasChild('a')).toBe(false);
+    trieNode.removeChild("a");
+    expect(trieNode.hasChild("a")).toBe(false);
   });
 
-  it('should NOT delete child node if the child node has children', () => {
-    const trieNode = new TrieNode('c');
-    trieNode.addChild('a');
-    const childNode = trieNode.getChild('a');
-    childNode.addChild('r');
+  it("should NOT delete child node if the child node has children", () => {
+    const trieNode = new TrieNode("c");
+    trieNode.addChild("a");
+    const childNode = trieNode.getChild("a");
+    childNode.addChild("r");
 
-    trieNode.removeChild('a');
-    expect(trieNode.hasChild('a')).toEqual(true);
+    trieNode.removeChild("a");
+    expect(trieNode.hasChild("a")).toEqual(true);
   });
 
-  it('should NOT delete child node if the child node completes a word', () => {
-    const trieNode = new TrieNode('c');
+  it("should NOT delete child node if the child node completes a word", () => {
+    const trieNode = new TrieNode("c");
     const IS_COMPLETE_WORD = true;
-    trieNode.addChild('a', IS_COMPLETE_WORD);
+    trieNode.addChild("a", IS_COMPLETE_WORD);
 
-    trieNode.removeChild('a');
-    expect(trieNode.hasChild('a')).toEqual(true);
+    trieNode.removeChild("a");
+    expect(trieNode.hasChild("a")).toEqual(true);
   });
 });
+
diff --git a/src/playground/__test__/playground.test.js b/src/playground/__test__/playground.test.js
index 84a3e83..5de4ed5 100644
--- a/src/playground/__test__/playground.test.js
+++ b/src/playground/__test__/playground.test.js
@@ -1,8 +1,9 @@
-import playground from '../playground';
+import playground from "../playground";
 
-describe('playground', () => {
-  it('should return correct results', () => {
+describe("playground", () => {
+  it("should return correct results", () => {
     // Replace the next dummy test with your playground function tests.
     expect(playground()).toBe(120);
   });
 });
+
diff --git a/src/playground/playground.js b/src/playground/playground.js
index b8c5b21..5b84c13 100644
--- a/src/playground/playground.js
+++ b/src/playground/playground.js
@@ -1,5 +1,5 @@
 // Import any algorithmic dependencies you need for your playground code here.
-import factorial from '../algorithms/math/factorial/factorial';
+import factorial from "../algorithms/math/factorial/factorial";
 
 // Write your playground code inside the playground() function.
 // Test your code from __tests__/playground.test.js
@@ -10,3 +10,4 @@ function playground() {
 }
 
 export default playground;
+
diff --git a/src/utils/comparator/Comparator.js b/src/utils/comparator/Comparator.js
index f5c41b5..09e8775 100644
--- a/src/utils/comparator/Comparator.js
+++ b/src/utils/comparator/Comparator.js
@@ -80,3 +80,4 @@ export default class Comparator {
     this.compare = (a, b) => compareOriginal(b, a);
   }
 }
+
diff --git a/src/utils/comparator/__test__/Comparator.test.js b/src/utils/comparator/__test__/Comparator.test.js
index 33cecc2..6349b9e 100644
--- a/src/utils/comparator/__test__/Comparator.test.js
+++ b/src/utils/comparator/__test__/Comparator.test.js
@@ -1,16 +1,16 @@
-import Comparator from '../Comparator';
+import Comparator from "../Comparator";
 
-describe('Comparator', () => {
-  it('should compare with default comparator function', () => {
+describe("Comparator", () => {
+  it("should compare with default comparator function", () => {
     const comparator = new Comparator();
 
     expect(comparator.equal(0, 0)).toBe(true);
     expect(comparator.equal(0, 1)).toBe(false);
-    expect(comparator.equal('a', 'a')).toBe(true);
+    expect(comparator.equal("a", "a")).toBe(true);
     expect(comparator.lessThan(1, 2)).toBe(true);
     expect(comparator.lessThan(-1, 2)).toBe(true);
-    expect(comparator.lessThan('a', 'b')).toBe(true);
-    expect(comparator.lessThan('a', 'ab')).toBe(true);
+    expect(comparator.lessThan("a", "b")).toBe(true);
+    expect(comparator.lessThan("a", "ab")).toBe(true);
     expect(comparator.lessThan(10, 2)).toBe(false);
     expect(comparator.lessThanOrEqual(10, 2)).toBe(false);
     expect(comparator.lessThanOrEqual(1, 1)).toBe(true);
@@ -22,7 +22,7 @@ describe('Comparator', () => {
     expect(comparator.greaterThanOrEqual(0, 10)).toBe(false);
   });
 
-  it('should compare with custom comparator function', () => {
+  it("should compare with custom comparator function", () => {
     const comparator = new Comparator((a, b) => {
       if (a.length === b.length) {
         return 0;
@@ -31,20 +31,21 @@ describe('Comparator', () => {
       return a.length < b.length ? -1 : 1;
     });
 
-    expect(comparator.equal('a', 'b')).toBe(true);
-    expect(comparator.equal('a', '')).toBe(false);
-    expect(comparator.lessThan('b', 'aa')).toBe(true);
-    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(false);
-    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(true);
-    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
+    expect(comparator.equal("a", "b")).toBe(true);
+    expect(comparator.equal("a", "")).toBe(false);
+    expect(comparator.lessThan("b", "aa")).toBe(true);
+    expect(comparator.greaterThanOrEqual("a", "aa")).toBe(false);
+    expect(comparator.greaterThanOrEqual("aa", "a")).toBe(true);
+    expect(comparator.greaterThanOrEqual("a", "a")).toBe(true);
 
     comparator.reverse();
 
-    expect(comparator.equal('a', 'b')).toBe(true);
-    expect(comparator.equal('a', '')).toBe(false);
-    expect(comparator.lessThan('b', 'aa')).toBe(false);
-    expect(comparator.greaterThanOrEqual('a', 'aa')).toBe(true);
-    expect(comparator.greaterThanOrEqual('aa', 'a')).toBe(false);
-    expect(comparator.greaterThanOrEqual('a', 'a')).toBe(true);
+    expect(comparator.equal("a", "b")).toBe(true);
+    expect(comparator.equal("a", "")).toBe(false);
+    expect(comparator.lessThan("b", "aa")).toBe(false);
+    expect(comparator.greaterThanOrEqual("a", "aa")).toBe(true);
+    expect(comparator.greaterThanOrEqual("aa", "a")).toBe(false);
+    expect(comparator.greaterThanOrEqual("a", "a")).toBe(true);
   });
 });
+
