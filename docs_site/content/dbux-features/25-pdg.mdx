---
title: "PDG: Program Dependency Graph"
sidebar_class_name: sidebar-call-graph
slug: /pdg
---

import CodeBlock from '@comp/CodeBlock';
import HSpace from '@comp/HSpace';
import Term from '@comp/Term';
import Img from '@comp/Img';
import TOC from '@comp/TOC';

<TOC toc={toc} />

<!-- <hr />

<a className="flex flex-row flex-center-slim" href="https://www.reddit.com/r/ProgrammerHumor/comments/rvco1a/asynchronous_proggraming_be_like/">
  "Asynchronous Programming be like..."
  <HSpace space="4rem" />
  <Img maxWidth="200px" title="Asynchronous Programming is hard" src="async-hard.gif" />
</a>

<hr /> -->


## What is the Asynchronous Call Graph (ACG)?

The Asynchronous Call Graph (ACG) is the [call graph](./08-call-graph.mdx) in `Async` mode. You can see the ACG by opening the [call graph](./08-call-graph.mdx) and switching to `Async` mode (by clicking the `Sync` button in the [toolbar](./08-call-graph.mdx#toolbar)). The two call graph modes share many features, including the toolbar buttons, coloring and more, as explained [here](./08-call-graph.mdx#toolbar).

`Sync` mode allows inspecting children and children of children of file and function executions. However, it simply puts <Term term="call graph roots" /> on a single linear vertical timeline. The ACG, on the other hand, uncovers the hidden connections between those roots on multiple vertical timelines and connections rendered between them.
In other words, `Sync` mode is great for inspecting control flow **within** individual <Term term="call graph roots" />, while `Async` mode is great for inspecting control flow **between** them.
In many debugging scenarios, you probably want to toggle between the two modes, as you investigate the control flow of an application.

## Why?

[Asynchronous JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous) and its relatives, [parallel programming](https://en.wikipedia.org/wiki/Parallel_programming) and [concurrent computing](https://en.wikipedia.org/wiki/Concurrent_computing), lead to much more complex execution pattern than their non-asynchronous, non-parallel, non-concurrent counterparts. In fact, asynchronous semantics are one of the most daunting aspects of JavaScript that software developers have to deal with on a day-to-day basis, making it <span className="cursor-help highlight-on-hover" title="This is a generic statement, so phrased for dramatic effect, not for accuracy.">feared by many, underestimated by the rest<sup>*</sup></span>.

With the ACG we hope to make asynchronous JavaScript a lot easier to understand and digest. It presents a clear picture of an application's asynchronous control flow, and makes many types of <Term term="race conditions" /> visually obvious. It can also help uncover lacking error propagation and a lot more. For example, if your application's ACG has many individual columns, but a low level of actual concurrency (things don't actually happen concurrently), it might indicate that you (i) forgot to `await` or otherwise chain or nest your promises, or maybe (ii) are suffering from legacy code involving asynchronous callbacks and potential callback hell, that would benefit from re-writing using modern explicit asynchronous semantics.
<!-- TODO: examples for visible race conditions -->
